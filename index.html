<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="小小的天，大大的梦">
<meta property="og:type" content="website">
<meta property="og:title" content="Jay-Luo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jay-Luo">
<meta property="og:description" content="小小的天，大大的梦">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jay-Luo">
<meta name="twitter:description" content="小小的天，大大的梦">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Jay-Luo</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bc6214a71594310d314698ac546aca76";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jay-Luo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小小的天，大大的梦</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/07/kettle-8.2安装手册/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/07/kettle-8.2安装手册/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-07T01:08:16+08:00">
                2021-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>本编文章主要介绍如何安装kettle 8.2</p>
<h1 id="2-准备"><a href="#2-准备" class="headerlink" title="2 准备"></a>2 准备</h1><p>  1) 安装jdk1.8(已在上一章说明)<br>  2) 下载kettle 8.2安装包：<em><a href="https://sourceforge.net/projects/pentaho/files/latest/download?aliId=137249511" target="_blank" rel="noopener">https://sourceforge.net/projects/pentaho/files/latest/download?aliId=137249511</a></em></p>
<h1 id="3-安装kettle-8-2"><a href="#3-安装kettle-8-2" class="headerlink" title="3 安装kettle 8.2"></a>3 安装kettle 8.2</h1><p>  1) 解压下载的安装包<br>  2) 进入目录pdi-ce-8.2.0.0-342 <strong>-&gt;</strong> data-integration <strong>-&gt;</strong> ,打开spoon.bat<br><img src="https://note.youdao.com/yws/public/resource/9ad28471772957ddecb1e977ed1a2ac0/xmlnote/756323DEC83E480591D11BCA91374CAA/11798" alt="spoon-bat"><br>  3) 出现以上页面，代表安装成功<br><img src="https://note.youdao.com/yws/public/resource/9ad28471772957ddecb1e977ed1a2ac0/xmlnote/91E0C60484FE4C479393623963B9E000/11800" alt="success-page"></p>
<h1 id="4-如何运行kettle脚本程序"><a href="#4-如何运行kettle脚本程序" class="headerlink" title="4 如何运行kettle脚本程序"></a>4 如何运行kettle脚本程序</h1><p>  1) 下载kettle脚本程序.zip,并重命名成后缀为zip压缩包：<em><a href="http://192.168.2.45:1174/AAYQAf__AAAAAQAAAAAAAAAAyUKMcgAORL6xOFABvf-aoA" target="_blank" rel="noopener">http://192.168.2.45:1174/AAYQAf__AAAAAQAAAAAAAAAAyUKMcgAORL6xOFABvf-aoA</a></em><br>  2) 解压压缩包，获取rest2file.ktr脚本程序<br>  3) 点击打开按钮并选择存放脚本的指定位置<br><img src="https://note.youdao.com/yws/public/resource/9ad28471772957ddecb1e977ed1a2ac0/xmlnote/EBB099C55A0546829ED332FA7A088B08/11802" alt="open"><br>  4) 执行脚本，并看当前脚本返回结果<br><img src="https://note.youdao.com/yws/public/resource/9ad28471772957ddecb1e977ed1a2ac0/xmlnote/EF8D1FB29DEE49DBA679A3C5F6C9610A/11804" alt="perform"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/07/kettle在项目中应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/07/kettle在项目中应用/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-07T01:07:46+08:00">
                2021-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着发展，公司后续对接的项目对大数据量的存储和清洗需求越来越旺盛，我有幸接触这个项目并成为其中开发一员，致力于构建了一个底层的ETL清洗服务。这也是我首次调部门的第一个项目。</p>
<h2 id="Kettle的介绍"><a href="#Kettle的介绍" class="headerlink" title="Kettle的介绍"></a>Kettle的介绍</h2><p>Kettle从名称就可以知道“水壶”，顾名思义就是封装了很多内置功能，它是一个ETL的开源工具。Kettle就像一个容纳器，将很多ETL所需要的功能都涵盖进去，形成一个独立的生态系统。</p>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>下图可以看出,kettle包含了丰富的功能。</p>
<p><img src="https://note.youdao.com/yws/public/resource/9ad28471772957ddecb1e977ed1a2ac0/xmlnote/A8E422918CF347FFA48CDE9904FBBE0D/11674" alt="Kettle功能图"></p>
<html><br><center>kettle功能图</center><br></html>

<h3 id="为什么使用kettle"><a href="#为什么使用kettle" class="headerlink" title="为什么使用kettle"></a>为什么使用kettle</h3><p>基于Kettle开发了一段时间，也逐渐深入了解到kettle的优势。以下是我使用Kettle以来个人的观点：</p>
<p>优势：</p>
<ul>
<li>内置众多的成熟稳定开源组件，天然支持多种ETL业务场景。</li>
<li>kettle设计是基于职责单一原则，各个组件独立，不相互依赖。因此提高重用性。</li>
<li>构建任务脚本简单，通过PC客户端拖拉组件的方式就能轻松实现转化任务。因此不用有编程基础的人都能够自行实现。</li>
<li>kettle有独立的官网，上面文档较为完善，但是可能市面上不怎么流行，网上关于kettle的问题并不是很多。</li>
</ul>
<p>劣势：</p>
<ul>
<li>组件繁多，有额外的学习门槛。</li>
<li>没有提供Web端的开发页面，只有PC客户端，因此开发人员只能通过客户端调试并开发。</li>
<li>由于基于开源组件开发，调试难度相对较大。线上部署测试难度大。</li>
<li>天然包含众多组件，偏重量级开源框架，因此打包会比较大。</li>
<li>不支持对非结构化文本的解释，如非结构化网页html、爬虫、不支持对流的操作和传输、难以支持逻辑较为复杂的业务流程，如数据融合，数据分析等。</li>
<li>开发自定义组件相对复杂，调试比较难。</li>
</ul>
<p>我大大小小也基于kettle开发过几十个脚本，但是往全公司推广确实举步维艰，因为需要学习成本，这个也跟公司的架构有关系（主要原因）。一旦脚本众多，维护起来就越来越麻烦，特别对于过于复杂的脚本来说，没几多人愿意维护起来。</p>
<h3 id="Kettle安装与使用"><a href="#Kettle安装与使用" class="headerlink" title="Kettle安装与使用"></a>Kettle安装与使用</h3><p><a href="http://note.youdao.com/noteshare?id=28505b7348b9d73ed38d8da36bfd1425&amp;sub=171D26FDD37442F184CA9B8947192B95" target="_blank" rel="noopener">Kettle安装使用</a></p>
<h3 id="集成Kettle"><a href="#集成Kettle" class="headerlink" title="集成Kettle"></a>集成Kettle</h3><ol>
<li>添加Maven<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;kettle.version&gt;8.3.0.0-371&lt;/kettle.version&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;kettle-core&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;kettle-engine&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;kettle-dbdialog&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>需要额外添加Pentaho自身的仓库，不然下载不了对应的Jar包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">  	&lt;repository&gt;</span><br><span class="line">      &lt;id&gt;pentaho-public&lt;/id&gt;</span><br><span class="line">      &lt;name&gt;Pentaho Public&lt;/name&gt;</span><br><span class="line">      &lt;url&gt;http://nexus.pentaho.org/content/groups/omni&lt;/url&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>代码集成</li>
</ol>
<ul>
<li><p>加载插件并进行kettle环境的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean init() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		if (pluginDir != null) &#123;</span><br><span class="line">			// Load plugins</span><br><span class="line">			StepPluginType.getInstance().getPluginFolders().add(new PluginFolder(pluginDir, false, true));</span><br><span class="line">		&#125;</span><br><span class="line">		KettleEnvironment.init();</span><br><span class="line">	&#125; catch (KettleException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		Log.error(&quot;kettle executor init&quot;,e);</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行Trans任务具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath  脚本路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramMap  脚本参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> level 脚本输出日志级别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">runTrans</span><span class="params">(String filePath, Map&lt;String, String&gt; paramMap,String level)</span> </span>&#123;</span><br><span class="line">		Trans trans = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			</span><br><span class="line">			LOG.info(<span class="string">"Running trans &#123;&#125;..."</span>, filePath);</span><br><span class="line">			<span class="keyword">long</span> st = System.currentTimeMillis();</span><br><span class="line">			</span><br><span class="line">			TransMeta transMeta = <span class="keyword">new</span> TransMeta(filePath);    <span class="comment">//构建Tran文件元数据对象</span></span><br><span class="line">			</span><br><span class="line">			trans = <span class="keyword">new</span> Trans(transMeta);   <span class="comment">//构建Trans任务</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置Trans里面输入的参数</span></span><br><span class="line">			<span class="keyword">if</span> (paramMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span>( String param: paramMap.keySet() ) &#123;</span><br><span class="line">					trans.setParameterValue( param, paramMap.get(param));</span><br><span class="line">					transMeta.setParameterValue( param, paramMap.get(param));</span><br><span class="line">				&#125;		</span><br><span class="line">				trans.activateParameters();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//执行Trans任务的脚本</span></span><br><span class="line">			trans.execute(<span class="keyword">null</span>);</span><br><span class="line">			trans.waitUntilFinished();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (trans.getErrors() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				LOG.error(<span class="string">"There are errors while running transformation! Error Code: &#123;&#125;"</span>, trans.getErrors());</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">long</span> dt = System.currentTimeMillis() - st;</span><br><span class="line">				LOG.info(<span class="string">"Run trans &#123;&#125; finish in &#123;&#125; ms"</span>, filePath, dt);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">if</span>(!trans.isFinished())&#123;</span><br><span class="line">				trans.stopAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>运行</li>
</ol>
<p>到了这部基本上已经可以跑kettle生成的trans的脚本，如果还想增加调度的功能话可以集成quartz调度包、市面上比较流行的saturn、xxl-job等调度框架，或者基于公司的业务架构来自行实现调度框架也是可以。以上的框架我也有使用过并进行对比和集成。后面会有一章节额外说明，这里就不详细说了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://community.hitachivantara.com/s/article/data-integration-kettle" target="_blank" rel="noopener">kettle官网</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/07/Kettle自定义插件开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/07/Kettle自定义插件开发/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-07T01:07:28+08:00">
                2021-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着业务种类越来越多，kettle内置的插件也逐渐满足不了各种业务需求，因此需要通过kettle自定义插件的方式来满足业务的需求。</p>
<h2 id="kettle插件"><a href="#kettle插件" class="headerlink" title="kettle插件"></a>kettle插件</h2><p>开发kettle的业务插件也有一段时间，整理了一下大概也有十多个，大概如下：</p>
<ol>
<li><p>ESDB Output组件：Pipeline ESDB Output组件是一个Kettle的扩展插件，用于将数据输出到ESDB（自研发的地球科学数据库）中。</p>
</li>
<li><p>ESDB 字段映射组件：要用于将数据字段名称映射成规范的编码。比如我们提供了一份《气象行业字段标准编码》的文件，里面包含了CIMISS字段、IDEA字段与标准编码的映射。那么在采集CIMISS数据，或者IDEA数据时，就可以通过该组件，将字段名转换为标准的编码，最后才通过ESDB Output插件，进行入库。<br>每个行业（如气象、水利等），都可以整理一份字段标准编码CSV文件, 然后利用该组件进行自动匹配。规范字段编码的意义，在于对于不同的系统（比如不同省份的相似系统），数据查询的时候，可以通过统一的字段进行查询。比如地表温度，可以通过gst字段进行查询，无论该数据是来源于CIMISS，还是来源IDEA，还是来源于本地客户提供的数据。</p>
</li>
<li><p>Pipeline 通用组件：pipeline 通用组件,为用户开发自定义转换的插件提供统一的界面展示和配置操作。</p>
</li>
<li><p>Pipeline 通用组件-经纬度转换组件：pipeline 通用组件 经纬度转换组件,为用户提供经纬度转换坐标系（WGS84、GCJ_02、BD_09之间相互转换）的功能。</p>
</li>
<li><p>Pipeline 通用组件-站点插值组件：pipeline 通用组件-插值组件,为用户提供站点插值成格点数据的功能。</p>
</li>
<li><p>Pipeline 通用组件-idea（intgetdata2d接口）格点解析组件：格点解析组件,为用户提供解析intgetdata2d接口格点数据的功能</p>
</li>
<li>Pipeline 列合并组件：为用户提供针对某个字段，多行数据合并成一行数据的功能，合并后的对象是一个List对象。</li>
<li>Pipeline 多值映射组件：为用户提供值映射的功能。</li>
<li>Pipeline 通用组件-idea-byte转格点：dea（qpe、qpf接口）byte转格点解析组件,为用户提供byte转格点数据的功能。由于qpe与qpf接口返回格点数据经过base64加密，因此该插件会先base64解密然后将byte转换成格点数据</li>
<li>Pipeline 通用组件-格点双线性插值：为用户格点插值的功能（双线性插值）。</li>
<li>Pipeline 通用组件-气象文件读取插件（网格文件）：</li>
<li>Pipeline 通用组件-RestClientNew插件：提供读取rest接口的功能，主要是增加超时设置，kettle自带的restClient插值没有读取超时机制，如果接口卡住，连接会一直保持，所以新增本插件支持读取超时设置功能。</li>
<li>Pipeline 通用组件-多行数据转JSON插件：多行数据转JSON插件,提供把一行或多行数据根据分组字段合并成json字符串。</li>
<li>Pipeline 图片压缩插件：用于将图片进一步压缩的组件。</li>
<li>Pipeline 图片生成gif动图插件：能够将多张图片生成多张含有时间信息的图片，并将生成后的图片聚合成一张gif动态图片。</li>
</ol>
<h2 id="开发自定义插件"><a href="#开发自定义插件" class="headerlink" title="开发自定义插件"></a>开发自定义插件</h2><p>本章简单记录我认为开发属于自己步骤插件的要点，要想完整搭建参考<a href="https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins" target="_blank" rel="noopener">自定义步骤插件开发</a>。</p>
<h3 id="四个接口"><a href="#四个接口" class="headerlink" title="四个接口"></a>四个接口</h3><p>开发前提条件首先要了解四个接口</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>基础类</th>
<th>主要职责</th>
</tr>
</thead>
<tbody>
<tr>
<td>StepMetaInterface</td>
<td>BaseStepMeta</td>
<td>1.存储step设置信息<br>2.验证step设置信息<br>3.序列化step设置信息<br>4.提供获取step类的方法</td>
</tr>
<tr>
<td>StepDialogInterface</td>
<td>org.pentaho.di.ui.trans.step.BaseStepDialog</td>
<td>step属性信息配置窗口</td>
</tr>
<tr>
<td>StepInterface</td>
<td>BaseStep</td>
<td>执行数据行的功能流程</td>
</tr>
<tr>
<td>StepDataInterface</td>
<td>BaseStepData</td>
<td>存储处理中的数据状态</td>
</tr>
</tbody>
</table>
<p>以下我结合代码尽量</p>
<h3 id="实现StepMetaInterface"><a href="#实现StepMetaInterface" class="headerlink" title="实现StepMetaInterface"></a>实现StepMetaInterface</h3><p>该接口主要是对步骤元数据信息进行操作。</p>
<p>接口常用方法介绍：</p>
<ul>
<li>setDefault()：每次创建新步骤并将该步骤配置分配或设置为合理的默认值时，都会调用此方法。创建新步骤时，PDI客户端（Spoon）将使用此处设置的值。这是确保将步设置初始化为非空值的好地方。在序列化和对话框填充中，空值的处理可能很麻烦，因此大多数PDI步骤实现对于所有步骤设置都坚持非空值。</li>
<li><p>clone()：在PDI客户端中复制步骤时，将调用此方法。它返回步骤元对象的深层副本。如果步骤配置存储在可修改的对象（例如列表或自定义帮助对象）中，则实现类必须创建正确的深层副本，这一点至关重要。</p>
</li>
<li><p>getXML()：每当步骤将其设置序列化为XML时，PDI都会调用此方法。在PDI客户端中保存转换时会调用它。该方法返回一个XML字符串，其中包含序列化的步骤设置。该字符串包含一系列XML标记，每个设置一个标记。辅助类org.pentaho.di.core.xml.XMLHandler构造XML字符串。</p>
</li>
<li>loadXML()：每当步骤从XML读取其设置时，PDI都会调用此方法。包含步骤设置的XML节点作为参数传入。再次，帮助程序类 org.pentaho.di.core.xml.XMLHandler从XML节点读取步骤设置。</li>
<li>saveRep()：每当步骤将其设置保存到PDI存储库时，PDI都会调用此方法。作为第一个参数传入的存储库对象提供了一组用于序列化步骤设置的方法。调用存储库序列化方法时，该步骤将传入的转换ID和步骤ID用作标识符。</li>
<li>readRep()：每当步骤从PDI存储库中读取其配置时，PDI都会调用此方法。使用存储库序列化方法时，参数中给出的步骤ID用作标识符。</li>
</ul>
<p>获取其他实例</p>
<ul>
<li>public StepDialogInterface getDialog()</li>
<li>public StepInterface getStep()</li>
<li>public StepDataInterface getStepData()</li>
</ul>
<p>StepMetaInterface必须使用Step Java注释对实现的类进行注释。提供以下注释属性：<br>属性|描述<br>—|—<br>id | 该步骤的全局唯一ID<br>image | 步骤的png图标图像的资源位置<br>name | 该步骤的简短标签<br>description    | 该步骤的详细说明<br>categoryDescription |    步骤的类别应显示在PDI步骤树中。例如输入，输出，变换等。<br>i18nPackageName |如果i18nPackageName在批注属性中提供了该属性，则将name，description和categoryDe​​scription的值解释为 i18n相对于给定包中包含的消息束的键。<br>可以以扩展形式的i18n:<packagename>键来提供键，以指定与i18nPackageName属性中给定的包不同的包。</packagename></p>
<h3 id="实现StepDialogInterface"><a href="#实现StepDialogInterface" class="headerlink" title="实现StepDialogInterface"></a>实现StepDialogInterface</h3><p>该接口主要用于实现窗口的功能，以及设置属性信息的入口。打开步骤设置时候都会实例化dialog传入到StepMetaInterface接口对象并调用open()方法。</p>
<p>接口常用方法介绍：</p>
<ul>
<li>open()：仅在确认或取消对话框后，此方法才返回。</li>
</ul>
<h3 id="实现StepInterface"><a href="#实现StepInterface" class="headerlink" title="实现StepInterface"></a>实现StepInterface</h3><p>StepInterface当转换运行时，类实现负责实际的行处理。</p>
<p><img src="https://note.youdao.com/yws/public/resource/9ad28471772957ddecb1e977ed1a2ac0/xmlnote/9B1127DC0D95467C84BDA85446348950/12098" alt="StepInterface"></p>
<p>接口常用方法介绍：</p>
<ul>
<li><p>init()：当转换准备开始执行时，将调用该方法初始化资源。</p>
</li>
<li><p>processRow()：转换开始执行该方法，读取上一步骤传递下来的行数据，直到没有行就调用setOutputDone()返回false。</p>
</li>
<li><p>dispose()：转换完成后，PDI将调用该方法取消init()分配的资源。</p>
</li>
</ul>
<h3 id="实现StepDataInterface"><a href="#实现StepDataInterface" class="headerlink" title="实现StepDataInterface"></a>实现StepDataInterface</h3><p>类实现StepInterface不会在其任何字段中存储处理状态。取而代之的StepDataInterface是，使用一个附加的类实现来存储处理状态，包括状态标志，索引，缓存表，数据库连接，文件句柄等</p>
<h2 id="部署步骤插件"><a href="#部署步骤插件" class="headerlink" title="部署步骤插件"></a>部署步骤插件</h2><ol>
<li>创建一个包含您的插件类和资源的JAR文件</li>
<li>创建一个新文件夹，为其命名，然后将您的JAR文件放在该文件夹中</li>
<li>将刚创建的插件文件夹放置在特定位置，以供PDI查找。根据您使用PDI的方式，您需要按如下方式将插件文件夹复制到一个或多个位置。<ul>
<li>部署到PDI客户端（Spoon）或Carte：</li>
<li>将plugin文件夹复制到以下位置： design-tools / data-integration / plugins / steps。</li>
<li>重新启动PDI客户端。重新启动PDI客户端后，可以使用新的作业条目。</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://help.pentaho.com/Documentation/8.3/Developer_center/Embed_and_extend_PDI_functionality" target="_blank" rel="noopener">Kettle开发中心</a></p>
<p><a href="https://help.pentaho.com/Documentation/8.3/Developer_center/Extend_Pentaho_Data_Integration" target="_blank" rel="noopener">扩展Pentaho数据集成</a></p>
<p><a href="https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins" target="_blank" rel="noopener">自定义步骤插件开发</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/27/视频总览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/27/视频总览/" itemprop="url">视频总览（必看）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-27T11:16:39+08:00">
                2021-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h2><p><img src="/images/video/视频总览.png" alt="视频总览图"></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>上图是在视频开发组上将近一年多的开发经验累积的知识点，以便日后能快速预览。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/26/流媒体基础知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/26/流媒体基础知识点/" itemprop="url">流媒体基础知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-26T11:16:39+08:00">
                2021-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>学习流媒体之前，应该要首先知道流媒体相关基础知识点，这样能够更好地掌握流媒体</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>流媒体是什么？按照我个人理解就是将音视频数据转化成能够在互联网进行播放的一种流式技术。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>操作系统的扩展名，常用的视频保存格式有：mp4、avi、mpg等</p>
<h3 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h3><p>封装格式（Format），也称多媒体容器（Multimedia Container），是将已编码压缩好的视频轨道、音频轨道和元数据（视频基本信息如标题、字幕等）按照一定的格式规范，打包放到一个文件中，形成特定文件格式的视频文件。</p>
<h3 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h3><p>硬编解码：通过硬件实现编解码，减轻CPU计算的负担，如GPU等</p>
<p>软编解码：如 H264、H265、MPEG-4等编解码算法，更消耗CPU</p>
<h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>视频编码方式将视频数据进行压缩或者解压。一般来说压缩技术都会有损数据的</p>
<p>视频编码格式：</p>
<ol>
<li>H.26X系列：<ul>
<li>H261：主要在老的视频会议和视频电话产品中使用。</li>
<li>H263：主要用在视频会议、视频电话和网络视频上。</li>
<li>H264：视频压缩技术，比较普及和广发使用，在媒体项目中也是会经常接触，目前市面上多数的流媒体服务都支持H264编码的视频</li>
<li>H265：高效视频压缩技术，同比H264来说压缩效率提高了50%（同画面质量的情况下），而且还支持4K/8K的视频效果，未来会是趋势。但是目前市面上普遍的播放器支持度并不高，flv协议则不支持H265的格式编码的视频。</li>
</ul>
</li>
<li>MPEG系列<ul>
<li>MPEG-1第二部分：主要使用在VCD上，有些在线视频也使用这种格式，该编解码器的质量大致上和原有的VHS录像带相当。</li>
<li>MPEG-2第二部分：等同于H.262，使用在DVD、SVCD和大多数数字视频广播系统和有线分布系统（Cable Distribution Systems）中。</li>
<li>MPEG-4第二部分：可以使用在网络传输、广播和媒体存储上，比起MPEG-2和第一版的H.263，它的压缩性能有所提高。</li>
<li>MPEG-4第十部分：技术上和ITU-TH.264是相同的标准，二者合作，诞生了H.264/AVC标准，ITU-T将其命名为H.264，而ISO/IEC称它为MPEG-4高级视频编码（Advanced Video Coding，AVC）。</li>
</ul>
</li>
<li>AVS：我国自主知识产权的信源编码标准</li>
</ol>
<p>音频编码格式：</p>
<ol>
<li>AAC：ACC是MPEG-4中的音频标准（常见）</li>
<li>AMR</li>
<li>PCM</li>
<li>ogg(ogg vorbis音频)</li>
<li>AC3(DVD 专用音频编码)</li>
<li>DTS(DVD 专用音频编码)</li>
<li>APE(monkey’s 音频)</li>
<li>AU(sun 格式)</li>
<li>WMA</li>
</ol>
<p>音频编码方案之间音质比较（AAC，MP3，WMA等）结果： AAC+ &gt; MP3PRO &gt; AAC&gt; RealAudio &gt; WMA &gt; MP3</p>
<h3 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h3><p>视频转码（Video Transcoding）是指将已经压缩编码的视频码流转换成另一个视频码流</p>
<h3 id="转封装"><a href="#转封装" class="headerlink" title="转封装"></a>转封装</h3><p>转封装指的是将视频或音频的封装格式进行转换，如将AVI的视频转换为MP4，其间并不会进行音视频的编码和解码工作，而是直接将视频和音频压缩码流从一种封装格式文件中获取出来然后打包成另一种封装格式的文件。相比转码，转封装有两大特点：</p>
<pre><code>处理速度极快。音视频编解码过程十分复杂，占据了转码的绝大部分时间。转封装不需要进行编码和解码，节约了大量的处理时间。

音视频质量无损。没有解码（解压缩）和编码（压缩）过程，所以不会有音视频的压缩损伤。
</code></pre><p>转封装后的文件与原始文件的分辨率、码率等几乎一致，故播放时也称其为“原画”。</p>
<h3 id="码流与码率"><a href="#码流与码率" class="headerlink" title="码流与码率"></a>码流与码率</h3><p>码率（Bitrate）是指视频文件在单位时间内使用的数据流量，也叫码流或码流率，是视频编码中画面质量控制最重要的部分。量度单位为“比特每秒”（bit/s或bps），常使用Kbps（每秒多少千个比特）或Mbps。一般来说同样分辨率下，视频文件的码率越大，压缩比就越小，画面质量就越高。码率越大，说明单位时间内取样率越大，数据流精度就越高，处理出来的文件就越接近原始文件，图像质量越好，画质越清晰，要求播放设备的解码能力也越高。</p>
<pre><code>当然，码率越大，文件体积也越大，其计算公式是文件体积=时间X码率/8。例如，网络上常见的一部60分钟的码率为1Mbps的720P的视频文件，其体积就大概为3600秒×1Mb/8=450MB。
</code></pre><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>视频分辨率是指视频成像产品所成图像的大小或尺寸。分辨率决定了视频画面细节的精细程度。通常情况下，视频的分辨率越高，所包含的像素就越多，画面就越清晰。</p>
<p>480P : 640 x 480 个像素点</p>
<p>720P : 1280 x 720 个像素点</p>
<p>1080P : 1920 x 1080 个像素点</p>
<pre><code>分辨率是决定码率的主要因素，不同的分辨率要采用不同的码率。总体而言，视频的分辨率越高，所要求的码率也越大，但并不总是如此，不同分辨率都有合理的码率选择范围。
所谓“合理的范围”指的是，如果低于这个范围，视频画面质量会很差；如果高于这个范围，画面提升有限甚至几乎无提升，且浪费网络流量和存储空间。 
</code></pre><h3 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h3><p>帧率（Frame Rate）是单位时间内视频显示帧数的量度单位，也就是每秒钟刷新的图片的帧数，量度单位为“每秒显示帧数”（Frame Per Second，FPS）或“赫兹”</p>
<p>关于帧率有如下几个基础数据：</p>
<ul>
<li>帧率越高，cpu消耗就高</li>
<li>秀场视频直播，一般帧率20fps</li>
<li>普通视频直播，一般帧率15fps</li>
</ul>
<h3 id="GOP（关键帧间隔）"><a href="#GOP（关键帧间隔）" class="headerlink" title="GOP（关键帧间隔）"></a>GOP（关键帧间隔）</h3><p>GOP（Group of Pictures）是一组以 MPEG 编码的影片或视讯串流内部的连续图像，以 I 帧开头，到下一个 I 帧结束</p>
<ul>
<li>I 帧(Intra Coded Picture)：又称帧内编码帧，为关键帧，是一种自带全部信息的独立帧，无需参考其他图像便可独立进行解码，可以简单理解为一张静态画面。视频序列中的第一个帧始终都是I 帧，每个 GOP 由I 帧开始。</li>
<li>P 帧(Predictive Coded Picture)：又称帧间预测编码帧，需要参考前面的I帧才能进行编码。表示的是当前帧画面与前一帧（前一帧可能是I帧也可能是P帧）的差别。解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。与I帧相比，P帧通常占用更少的数据位，但不足是，由于P帧对前面的P和I参考帧有着复杂的依赖性，因此对传输错误非常敏感</li>
<li>B 帧(Bidirectionally Predictive Coded Pictures)：又称双向预测编码帧，也就是B帧记录的是本帧与前后帧的差别。也就是说要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是对解码性能要求较高。</li>
</ul>
<p>GOP值表示关键帧的间隔(即两个关键帧之间的帧数)，也就是两个IDR帧之间的距离，一个帧组的最大帧数。一般而言，每一秒视频至少需要使用 1 个关键帧。增加关键帧个数可改善视频质量，但会同时增加带宽和网络负载。GOP值（帧数）除以帧率即为时间间隔，如阿里云视频点播默认的GOP值为250帧，帧率为25fps，则时间间隔为10秒。</p>
<p>GOP值需要控制在合理范围，以平衡视频质量、文件大小（网络带宽）和seek效果（拖动、快进的响应速度）等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.加大GOP值有利于减小视频文件大小，但也不宜设置过大，太大则会导致GOP后部帧的画面失真，影响视频质量。</span><br><span class="line"></span><br><span class="line">2.GOP值也是影响视频seek响应速度的关键因素，seek时播放器需要定位到离指定位置最近的前一个关键帧，如果GOP太大意味着距离指定位置可能越远（需要解码的预测帧就越多）、seek响应的时间（缓冲时间）也越长。</span><br><span class="line"></span><br><span class="line">3.由于P、B帧的复杂度大于I帧，GOP值过大，过多的P、B帧会影响编码效率，使编码效率降低。</span><br><span class="line"></span><br><span class="line">4.但如果设置过小的GOP值，则需要提高视频的输出码率，以确保画面质量不会降低，故会增加网络带宽。</span><br></pre></td></tr></table></figure>
<h3 id="IDR-帧对齐"><a href="#IDR-帧对齐" class="headerlink" title="IDR 帧对齐"></a>IDR 帧对齐</h3><p>IDR帧（Instantaneous Decoding Refresh Picture），即时解码刷新帧，是 I 帧的一种。与普通 I 帧的区别在于，一个 IDR 帧之后的所有帧都不能引用该 IDR 帧之前的帧的内容；相反，对于普通的 I 帧，其后的 P 帧和 B 帧可以引用该普通 I 帧之前的其他 I 帧。在编码和解码中为了方便，将首个I帧和其他I帧区别开，称为IDR，这样就方便控制编码和解码流程</p>
<h3 id="图像存储格式yuv"><a href="#图像存储格式yuv" class="headerlink" title="图像存储格式yuv"></a>图像存储格式yuv</h3><p>YUV格式，与我们熟知的RGB类似，YUV也是一种颜色编码方法。YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p>
<p>YUV与RGB相比：<br>YUV是利用一个亮度（Y）、两个色差(U,V)来代替传统的RGB三原色来压缩图像。传统的RGB三原色使用红绿蓝三原色表示一个像素，每种原色占用一个字节（8bit），因此一个像素用RGB表示则需要8 * 3=24bit。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.码率与分辨率有关系，分辨率决定码率的主要因素，跟帧率没关，帧率关系着画面流畅度和cpu消耗</p>
<p>2.I帧可以看作一张完整的画面，P帧需要与缓存之前画面生成图像，而B帧则就需要记录前后画面画面生成图像。一般来说网络上的电影都会使用B帧，因为压缩率高，带宽消耗相对比较低。压缩率一般是 I帧（7）&lt; P帧（20） &lt; B帧（50）</p>
<p>3.一般来说，硬编码相比一般性能高，效率高，但移植和实现都比较困难，而软编码则实现简单，但性能相比就低一点。</p>
<blockquote>
<p>PS:<br>在项目遇到过一次坑就是关于视频YUV的问题，由于海康和大华的颜色编码不是相同，海康设备使用了YV12格式，而大华使用了YUV420格式，但是程序统一使用了YUV420，因此海康的画面出现了色差问题。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/232291020" target="_blank" rel="noopener">音视频&amp;流媒体的原理以及基础入门知识
</a></p>
<p><a href="https://help.aliyun.com/document_detail/99380.html?spm=a2c4g.11186623.6.553.28b0c149c65swI" target="_blank" rel="noopener">基础概念</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/Gateway源码分析(二)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/25/Gateway源码分析(二)/" itemprop="url">Gateway源码分析（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-25T11:16:39+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>这一章开始记录我开始Gateway阅读之路，看下究竟是如何实现网关。</p>
<h1 id="个人疑问"><a href="#个人疑问" class="headerlink" title="个人疑问"></a>个人疑问</h1><ol>
<li><p>Gateway的网关框架是如何接收请求并转发</p>
</li>
<li><p>如何执行Filter</p>
</li>
<li><p>如何加载路由、过滤器、断言等信息</p>
</li>
</ol>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactI&gt;</span><br><span class="line">	&lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>还是一样的图<br><img src="/images/video/gateway网关图.png" alt="Gateway框架"></p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>gateway-core.jar是gateway的核心包，主要的实现都在里面。阅读代码前最好先知道个个包的主要功能.</p>
<p><img src="/images/video/gateway的jar包架构图.png" alt="包组成"></p>
<ul>
<li>actuate</li>
</ul>
<p>该包主要是gateway自带的一个控制器GatewayControllerEndpoint，该endpiont提供了关于filter及routes的信息查询以及指定route信息更新的rest api，这给web界面提供管理配置功能提供了极大的便利</p>
<ul>
<li>config</li>
</ul>
<p>该包主要是Gateway的配置实体类，譬如yml上面的配置GatewayProperties、全局的跨域配置GlobalCorsProperties等等。</p>
<ul>
<li>discovery</li>
</ul>
<p>该包主要是实现服务发现的功能。从服务注册中心获取服务注册信息，然后配置相应的路由</p>
<ul>
<li>event</li>
</ul>
<p>该包是一些发布事件的定义。</p>
<ul>
<li>filter</li>
</ul>
<p>该包包含了gateway所有内置的过滤器。</p>
<ul>
<li>handler</li>
</ul>
<p>该包主要包括了所有内置的Predicates断言，RoutePredicateHandlerMapping类是一个实现了将接收请求到转发到filter里面的功能，FilteringWebHandler主要是构造过滤器链。</p>
<ul>
<li>route</li>
</ul>
<p>该包主要是定义路由信息，构造路由等。</p>
<ul>
<li>support</li>
</ul>
<p>该包主要是一些工具方法。用于全局。</p>
<h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="问题一：如何转发请求"><a href="#问题一：如何转发请求" class="headerlink" title="问题一：如何转发请求"></a>问题一：如何转发请求</h3><h4 id="DispatchHandler类"><a href="#DispatchHandler类" class="headerlink" title="DispatchHandler类"></a>DispatchHandler类</h4><p>WebFlux请求转发核心类：DispatchHandler</p>
<p>DispatchHandler内部主要的私有字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerResultHandler&gt; resultHandlers;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>HandlerMapping</td>
<td>映射请求到一个处理器。该映射是基于一定的标准、细节因不同HandlerMapping而不同。<br>例如有注解控制器, 简单URL匹配映射等等。<br>主要的HandlerMapping实现：<br>1.有RequestMappingHandlerMapping对于注解的@RequestMapping。<br>2.RouterFunctionMapping 对应于函数式端点路由。<br>3.SimpleUrlHandlerMappingURI路径模式的显式注册。<br>4.WebHandler的实例</td>
</tr>
<tr>
<td>HandlerAdapter</td>
<td>帮助DispatcherHandler调用映射的请求的处理器，而不管该处理程序实际上是如何调用的。<br>例如执行一个注解控制器需要解释注解。其主要目的是帮助DispatcherHandler隐藏实现的细节。</td>
</tr>
<tr>
<td>HandlerResultHandler</td>
<td>处理程序调用的结果并最后确定响应。<br>1.ResponseEntityResultHandler：ResponseEntity，处理@Controller实例。<br>2.ServerResponseResultHandler：ServerResponse，处理函数式端点。<br>3.ResponseBodyResultHandler：处理从@ResponseBody方法和@RestController类的返回值。<br>4.ViewResolutionResultHandler：处理成CharSequence,View, Model, Map, Rendering等其他的模型属性。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Mono.error(HANDLER_NOT_FOUND_EXCEPTION);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Flux.fromIterable(<span class="keyword">this</span>.handlerMappings)</span><br><span class="line">			.concatMap(mapping -&gt; mapping.getHandler(exchange))</span><br><span class="line">			.next()</span><br><span class="line">			.switchIfEmpty(Mono.error(HANDLER_NOT_FOUND_EXCEPTION))</span><br><span class="line">			.flatMap(handler -&gt; invokeHandler(exchange, handler))</span><br><span class="line">			.flatMap(result -&gt; handleResult(exchange, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心方法主要做了三个步骤：</p>
<ol>
<li>匹配每一个不同HandlerMapping，使用首先匹配的那个。</li>
<li>执行器被找到就会找到对应的HandlerAdapter,然后就会将返回结果返回到HandlerResult里。</li>
<li>HandlerResult会给出一个合适的处理器去完成直接写到响应里面或者使用View来渲染的处理。</li>
</ol>
<h4 id="RoutePredicateHandlerMapping类"><a href="#RoutePredicateHandlerMapping类" class="headerlink" title="RoutePredicateHandlerMapping类"></a>RoutePredicateHandlerMapping类</h4><p>刚说完DispatchHandler的类，就到HandlerMapping了，类RoutePredicateHandlerMapping实现了HandlerMapping。</p>
<p>其核心私有字段分别有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FilteringWebHandler webHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RouteLocator routeLocator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer managmentPort;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>Bean类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>webHandler</td>
<td>构建过滤器的责任链</td>
</tr>
<tr>
<td>routeLocator</td>
<td>路由的定义信息</td>
</tr>
<tr>
<td>managmentPort</td>
<td>gateway管理端口</td>
</tr>
</tbody>
</table>
<p>其核心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Mono&lt;?&gt; getHandlerInternal(ServerWebExchange exchange) &#123;</span><br><span class="line">	<span class="comment">// don't handle requests on the management port if set</span></span><br><span class="line">	<span class="keyword">if</span> (managmentPort != <span class="keyword">null</span> &amp;&amp; exchange.getRequest().getURI().getPort() == managmentPort.intValue()) &#123;</span><br><span class="line">		<span class="keyword">return</span> Mono.empty();</span><br><span class="line">	&#125;</span><br><span class="line">	exchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lookupRoute(exchange)</span><br><span class="line">			<span class="comment">// .log("route-predicate-handler-mapping", Level.FINER) //name this</span></span><br><span class="line">			.flatMap((Function&lt;Route, Mono&lt;?&gt;&gt;) r -&gt; &#123;</span><br><span class="line">				exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Mapping ["</span> + getExchangeDesc(exchange) + <span class="string">"] to "</span> + r);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				exchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);</span><br><span class="line">				<span class="keyword">return</span> Mono.just(webHandler);</span><br><span class="line">			&#125;).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">				exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">"No RouteDefinition found for ["</span> + getExchangeDesc(exchange) + <span class="string">"]"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该核心方法做了几件事：</p>
<ol>
<li>找到合适的路由lookupRoute方法。</li>
<li>将路由信息放到ServerWebExchange请求线程的属性里，以便整个运行随时可用。</li>
<li>执行webHandler中的过滤器链。==（后面会介绍如何执行）==</li>
</ol>
<p>lookupRoute执行过程：</p>
<ol>
<li>通过routeLocator的获取所有配置好的路由信息。 ==（后面会介绍如何加载路由信息、过滤器、断言）==</li>
<li>匹配每一个路由的断言，是否符合，若符合则返回对应的路由信息。若不符合则next()下一个路由的断言匹配。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Mono&lt;Route&gt; <span class="title">lookupRoute</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.routeLocator</span><br><span class="line">			.getRoutes()</span><br><span class="line">			<span class="comment">//individually filter routes so that filterWhen error delaying is not a problem</span></span><br><span class="line">			.concatMap(route -&gt; Mono</span><br><span class="line">					.just(route)</span><br><span class="line">					.filterWhen(r -&gt; &#123;</span><br><span class="line">						<span class="comment">// add the current route we are testing</span></span><br><span class="line">						exchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());</span><br><span class="line">						<span class="keyword">return</span> r.getPredicate().apply(exchange);</span><br><span class="line">					&#125;)</span><br><span class="line">					<span class="comment">//instead of immediately stopping main flux due to error, log and swallow it</span></span><br><span class="line">					.doOnError(e -&gt; logger.error(<span class="string">"Error applying predicate for route: "</span>+route.getId(), e))</span><br><span class="line">					.onErrorResume(e -&gt; Mono.empty())</span><br><span class="line">			)</span><br><span class="line">			<span class="comment">// .defaultIfEmpty() put a static Route not found</span></span><br><span class="line">			<span class="comment">// or .switchIfEmpty()</span></span><br><span class="line">			<span class="comment">// .switchIfEmpty(Mono.&lt;Route&gt;empty().log("noroute"))</span></span><br><span class="line">			.next()</span><br><span class="line">			<span class="comment">//<span class="doctag">TODO:</span> error handling</span></span><br><span class="line">			.map(route -&gt; &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Route matched: "</span> + route.getId());</span><br><span class="line">				&#125;</span><br><span class="line">				validateRoute(route, exchange);</span><br><span class="line">				<span class="keyword">return</span> route;</span><br><span class="line">			&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题二：如何执行Filter"><a href="#问题二：如何执行Filter" class="headerlink" title="问题二：如何执行Filter"></a>问题二：如何执行Filter</h3><h4 id="如何执行Filter-FilteringWebHandler类"><a href="#如何执行Filter-FilteringWebHandler类" class="headerlink" title="如何执行Filter(FilteringWebHandler类)"></a>如何执行Filter(FilteringWebHandler类)</h4><p>执行流程：</p>
<ol>
<li>初始化时候构造好全局的过滤器集合。</li>
<li>合并路由上配置的过滤器与全局过滤器</li>
<li>排序好所有过滤器传入DefaultGatewayFilterChain的责任链里执行。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Mono&lt;Void&gt; handle(ServerWebExchange exchange) &#123;</span><br><span class="line">	Route route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);</span><br><span class="line">	List&lt;GatewayFilter&gt; gatewayFilters = route.getFilters();</span><br><span class="line"></span><br><span class="line">	List&lt;GatewayFilter&gt; combined = new ArrayList&lt;&gt;(this.globalFilters);</span><br><span class="line">	combined.addAll(gatewayFilters);</span><br><span class="line">	//TODO: needed or cached?</span><br><span class="line">	AnnotationAwareOrderComparator.sort(combined);</span><br><span class="line"></span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Sorted gatewayFilterFactories: &quot;+ combined);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return new DefaultGatewayFilterChain(combined).filter(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>责任链是一个常用的编程设计模式，它能够将请求与处理步骤解耦，请求操作对链内部的执行透明，而且每个链子都有自己具体实现，能够自由组装复用，不相互影响，使得代码更加简洁。不过责任联在调试方面相对来说比较麻烦，不便于观察等缺点。</p>
<p>看下如何构造一个责任联，内部类DefaultGatewayFilterChain<br>的filter方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultGatewayFilterChain</span> <span class="keyword">implements</span> <span class="title">GatewayFilterChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> List&lt;GatewayFilter&gt; filters;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">DefaultGatewayFilterChain</span><span class="params">(List&lt;GatewayFilter&gt; filters)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.filters = filters;</span><br><span class="line">			<span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">DefaultGatewayFilterChain</span><span class="params">(DefaultGatewayFilterChain parent, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.filters = parent.getFilters();</span><br><span class="line">			<span class="keyword">this</span>.index = index;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> List&lt;GatewayFilter&gt; <span class="title">getFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> filters;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Mono.defer(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.index &lt; filters.size()) &#123;</span><br><span class="line">					GatewayFilter filter = filters.get(<span class="keyword">this</span>.index);</span><br><span class="line">					DefaultGatewayFilterChain chain = <span class="keyword">new</span> DefaultGatewayFilterChain(<span class="keyword">this</span>, <span class="keyword">this</span>.index + <span class="number">1</span>);</span><br><span class="line">					<span class="keyword">return</span> filter.filter(exchange, chain);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> Mono.empty(); <span class="comment">// complete</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="问题三：如何加载路由、过滤器、断言等信息"><a href="#问题三：如何加载路由、过滤器、断言等信息" class="headerlink" title="问题三：如何加载路由、过滤器、断言等信息"></a>问题三：如何加载路由、过滤器、断言等信息</h3><h4 id="RouteDefinitionRouteLocator类"><a href="#RouteDefinitionRouteLocator类" class="headerlink" title="RouteDefinitionRouteLocator类"></a>RouteDefinitionRouteLocator类</h4><ul>
<li>获取路由信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Flux&lt;Route&gt; getRoutes() &#123;</span><br><span class="line">	return this.routeDefinitionLocator.getRouteDefinitions()</span><br><span class="line">			.map(this::convertToRoute)</span><br><span class="line">			//TODO: error handling</span><br><span class="line">			.map(route -&gt; &#123;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;RouteDefinition matched: &quot; + route.getId());</span><br><span class="line">				&#125;</span><br><span class="line">				return route;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* TODO: trace logging</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;RouteDefinition did not match: &quot; + routeDefinition.getId());</span><br><span class="line">		&#125;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==this.routeDefinitionLocator.getRouteDefinitions()== 初始化首次加载获取配置文件中定义的路由信息并存于缓存中以便下次使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public CachingRouteDefinitionLocator(RouteDefinitionLocator delegate) &#123;</span><br><span class="line">		this.delegate = delegate;</span><br><span class="line">		routeDefinitions = CacheFlux.lookup(cache, &quot;routeDefs&quot;, RouteDefinition.class)</span><br><span class="line">				.onCacheMissResume(this.delegate::getRouteDefinitions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>==convertToRoute==则是将配置信息定义的路由信息转变为真正内部使用的路由实体，具体实现如下：</p>
<ol>
<li>组装断言链表</li>
<li>获取配置信息定义过滤器</li>
<li>组装成真正路由对象Route<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Route convertToRoute(RouteDefinition routeDefinition) &#123;</span><br><span class="line">		AsyncPredicate&lt;ServerWebExchange&gt; predicate = combinePredicates(routeDefinition);</span><br><span class="line">		List&lt;GatewayFilter&gt; gatewayFilters = getFilters(routeDefinition);</span><br><span class="line"></span><br><span class="line">		return Route.async(routeDefinition)</span><br><span class="line">				.asyncPredicate(predicate)</span><br><span class="line">				.replaceFilters(gatewayFilters)</span><br><span class="line">				.build();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其实这段代码使用了一个设计模式就是建造者模式。该模式能将构建和实现分离开来，建造者能逐步细化而不影响其它模块功能。不过建造者对产品会依赖，当产品发生变化，建造者相应也需要改变。所以这种模式建议用在比较简化的建造者依赖类上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return Route.async(routeDefinition)</span><br><span class="line">				.asyncPredicate(predicate)</span><br><span class="line">				.replaceFilters(gatewayFilters)</span><br><span class="line">				.build();</span><br></pre></td></tr></table></figure>
<p><img src="/images/video/Router的结构图.png" alt="建造者模式"></p>
<p>“断言”的功能在我看来实现得是非常巧妙的，所有断言正如过滤器一样都有一个共同的父类AbstractRoutePredicateFactory，实现apply的方法。看个例子：</p>
<p>PathRoutePredicateFactory断言类：作用是匹配请求uri资源。可以看出返回的是一个Predicate的实例，这样的好处就是在下次执行只会执行return返回的这一部分代码功能，不再需要执行配置行的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Predicate&lt;ServerWebExchange&gt; apply(Config config) &#123;</span><br><span class="line">	final ArrayList&lt;PathPattern&gt; pathPatterns = new ArrayList&lt;&gt;();</span><br><span class="line">	synchronized (this.pathPatternParser) &#123;</span><br><span class="line">		pathPatternParser.setMatchOptionalTrailingSeparator(config.isMatchOptionalTrailingSeparator());</span><br><span class="line">		config.getPatterns().forEach(pattern -&gt; &#123;</span><br><span class="line">			PathPattern pathPattern = this.pathPatternParser.parse(pattern);</span><br><span class="line">			pathPatterns.add(pathPattern);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	return exchange -&gt; &#123;</span><br><span class="line">		PathContainer path = parsePath(exchange.getRequest().getURI().getPath());</span><br><span class="line"></span><br><span class="line">		Optional&lt;PathPattern&gt; optionalPathPattern = pathPatterns.stream()</span><br><span class="line">				.filter(pattern -&gt; pattern.matches(path))</span><br><span class="line">				.findFirst();</span><br><span class="line"></span><br><span class="line">		if (optionalPathPattern.isPresent()) &#123;</span><br><span class="line">			PathPattern pathPattern = optionalPathPattern.get();</span><br><span class="line">			traceMatch(&quot;Pattern&quot;, pathPattern.getPatternString(), path, true);</span><br><span class="line">			PathMatchInfo pathMatchInfo = pathPattern.matchAndExtract(path);</span><br><span class="line">			putUriTemplateVariables(exchange, pathMatchInfo.getUriVariables());</span><br><span class="line">			return true;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			traceMatch(&quot;Pattern&quot;, config.getPatterns(), path, false);</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过Flux.zip方法连成一条断言链子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private AsyncPredicate&lt;ServerWebExchange&gt; combinePredicates(RouteDefinition routeDefinition) &#123;</span><br><span class="line">	List&lt;PredicateDefinition&gt; predicates = routeDefinition.getPredicates();</span><br><span class="line">	AsyncPredicate&lt;ServerWebExchange&gt; predicate = lookup(routeDefinition, predicates.get(0));</span><br><span class="line"></span><br><span class="line">	for (PredicateDefinition andPredicate : predicates.subList(1, predicates.size())) &#123;</span><br><span class="line">		AsyncPredicate&lt;ServerWebExchange&gt; found = lookup(routeDefinition, andPredicate);</span><br><span class="line">		predicate = predicate.and(found);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return predicate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">default AsyncPredicate&lt;T&gt; and(AsyncPredicate&lt;? super T&gt; other) &#123;</span><br><span class="line">	Objects.requireNonNull(other, &quot;other must not be null&quot;);</span><br><span class="line"></span><br><span class="line">	return t -&gt; Flux.zip(apply(t), other.apply(t))</span><br><span class="line">			.map(tuple -&gt; tuple.getT1() &amp;&amp; tuple.getT2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实到这里这一章就差不多了，基本上Gateway的主要总体框架功能就这些。这一次的阅读源码能够使我对lambda表达式的用处更深刻，而且，对这种响应式流的理解更进一步了，后续还会持续学习关于netty reactor的用法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/FFmpeg学习与使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/25/FFmpeg学习与使用/" itemprop="url">FFmpeg学习与使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-25T11:16:39+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本节主要记录下FFmpeg的使用方法以及如何用于视频项目上作一个简单的介绍</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FFmpeg是一款多媒体处理工具，内部包含了解码、编码、转码、解密的操作命令。正式由于FFmpeg太强大，目前大部分流媒体服务都会或多或小使用到FFmpeg的功能，所以我们有必要学习下FFmpeg的使用指令。</p>
<h2 id="常用命令以及解析"><a href="#常用命令以及解析" class="headerlink" title="常用命令以及解析"></a>常用命令以及解析</h2><h3 id="主要成分："><a href="#主要成分：" class="headerlink" title="主要成分："></a>主要成分：</h3><ol>
<li>libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能；</li>
<li>libavcodec：用于各种类型声音/图像编解码；</li>
<li>libavutil：包含一些公共的工具函数；</li>
<li>libswscale：用于视频场景比例缩放、色彩映射转换；</li>
<li>libpostproc：用于后期效果处理；</li>
<li>ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等；</li>
<li>ffsever：一个 HTTP 多媒体即时广播串流服务器；</li>
<li>ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示；</li>
</ol>
<h3 id="ffprobe"><a href="#ffprobe" class="headerlink" title="ffprobe"></a>ffprobe</h3><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -rtsp_transport tcp -i &quot;rtsp://10.128.184.34:554/01?Short=1&amp;Token=vEKOlIYbbCFseXHTjO3kbtEKZGZ4eyRExIkPU+yWWPA=&amp;DomainCode=6a7c1a077a004406a344a1f260d86e41&amp;UserId=6&amp;&quot;</span><br></pre></td></tr></table></figure></p>
<p>-rtsp_transport tcp/udp：选择以TCP还是UDP方式打开<br>·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。<br>-show_format filename：展示格式<br>-show_frames filename：显示帧信息</p>
<h3 id="ffplay"><a href="#ffplay" class="headerlink" title="ffplay"></a>ffplay</h3><p>播放文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay xxx.mp3 -ast 1 -loop 10</span><br></pre></td></tr></table></figure></p>
<p>-loop num：循环次数</p>
<p>-[ast|vst] 1：选择播放[音频|视频]</p>
<h3 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h3><p>FFmpeg参数太多，以下是我举例了项目中实际用到的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -loglevel quiet &#123;[decoder]&#125;  &#123;[tcp]&#125; -i &quot;&#123;[rtsp]&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>·-re：代表按照帧率发送，尤其在作为推流工具的时候一定要加入该参数，否则ffmpeg会按照最高速率向流媒体服务器不停地发送数据</p>
<p>-loglevel [debug|quiet|error]：日志级别记录</p>
<p>·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。</p>
<p>截图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -re -loglevel quiet &#123;[tcp]&#125; -i \&quot;&#123;[rtsp]&#125;\&quot; -an &#123;[size]&#125;  -vframes 1 -y -f image2 &#123;[pattern]&#125;.jpg</span><br></pre></td></tr></table></figure></p>
<p>-an：视频静音</p>
<p>·-y：覆盖已有文件。</p>
<p>·-f fmt：指定格式（音频或者视频格式）。</p>
<p>推流转码成h264<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -loglevel debug  -rtsp_transport tcp -i &quot;rtsp://10.128.184.34:554/01?Short=1&amp;Token=yWSkzfBj71Yja67n9Y65SXDN97TCCOzBveNwOB53Lh8=&amp;DomainCode=6a7c1a077a004406a344a1f260d86e41&amp;UserId=6&amp;&quot; -an -s 1280x720  -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp</span><br></pre></td></tr></table></figure></p>
<p>-analyzeduration：设置码流分析时间</p>
<p>-probesize：探测时长，这个设置的时间越长，视频打开得越慢</p>
<p>·-vcodec [codec|smart_h264]：强制使用codec编解码方式（’copy’代表不进行重新编码）,smart_h264实现h264编码</p>
<p>·-s size：指定分辨率（320×240）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;[ffmpeg]&#125; -loglevel error &#123;[decoder]&#125; -i &#123;[rtsp]&#125; &#123;[copy]&#125; &#123;[encoder]&#125; -an -threads 10 -tune zerolatency -crf &#123;[crf]&#125; -g 1 -r &#123;[frameRate]&#125; -preset ultrafast -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp</span><br></pre></td></tr></table></figure>
<p>crf num：<br>为恒定质量（无比特率目标）和受限质量（最大比特率目标）模式设置质量/大小折衷。有效范围是0到63，数字越大表示质量越低，输出大小越小。仅在设置时使用；默认情况下，仅使用比特率目标</p>
<p>threads num：选定的编解码器实现支持多线程，则设置要使用的线程数。</p>
<p>tune [zerolatency|fastdecode|psnr|ssim]：主要配合视频类型和视觉优化的参数。zerolatency零延迟，用在需要非常低的延迟的情况下，比如电视电话会议的编码；fastdecode可以快速解码的参数； psnr为提高psnr做了优化的参数；ssim为提高ssim做了优化的参数； </p>
<p>preset type：预设类型。</p>
<p>r num：帧率</p>
<p>g size：设置GOP的大小</p>
<h2 id="项目中如何是使用"><a href="#项目中如何是使用" class="headerlink" title="项目中如何是使用"></a>项目中如何是使用</h2><p>由于ffmpeg太强大，在视频网关的项目中，我们经常会使用到ffmpeg。主要使用到有两方面，一个是截图，一个是将h265的视频数据格式转码成h264或者更改视频的分辨率功能等。为什么在项目中会使用到FFmpeg呢，其实像海康和大华第三方的厂商都会有对应的sdk,但是像截图之类的功能不能很好支持各种分辨率的截图，所以喔们考虑到使用FFmpeg来结合起来，以下是关于项目的流程图。</p>
<p><img src="/images/video/流程图.jpg" alt="FFmpeg使用流程"></p>
<p>其实在项目上，我们一般会使用FFmpeg来进行截图，如上述说因为能够定制化配置截图得大小以及色差得调节等，而第三方厂商sdk一般都是默认尺寸，扩展性不高（如海康和大华）。而且，使用FFmpeg得扩展性会比较高。但是FFmpeg并不是万能，对于有一些私有的RTSP等可能也会存在失败的情况，所以在项目中如果FFmpeg截图不成功都会采用对应厂商sdk进行兜底截图，保证图片能够生成并且可用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.ffmpeg.org/documentation.html" target="_blank" rel="noopener">FFmpeg官网</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/流媒体协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/25/流媒体协议/" itemprop="url">流媒体协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-25T11:16:39+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>总结我在流媒体项目中接触到且使用过的所有协议</p>
<h1 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h1><p><img src="/images/video/agreement.png" alt="image"></p>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><p>学习流媒体的协议，首当其冲就是学习TCP与UDP的协议，因为基本的协议都是基于这两种协议来传输</p>
<h2 id="RTP与RTCP"><a href="#RTP与RTCP" class="headerlink" title="RTP与RTCP"></a>RTP与RTCP</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>RTP实时流传输协议，是用于Internet上针对多媒体数据流的一种传输协议。RTP位于传输层，基于UDP之上。RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，服务质量由RTCP来提供。</p>
<p>RTCP是实时传输控制协议，RTCP收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等，服务器可以利用这些信息动态的改变传输速率，甚至改变净荷的类型。RTCP消息也被封装为UDP数据报进行传输</p>
<p>一般而言,目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个 给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的 UDP端口＋1），这样就构成一个UDP端口对。 RTP的发送过程如下，接收过程则相反。</p>
<h3 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h3><h4 id="RTP协议结构"><a href="#RTP协议结构" class="headerlink" title="RTP协议结构"></a>RTP协议结构</h4><p><img src="/images/video/RTCP协议.png" alt="RTP协议结构"></p>
<p>RTP分组头部的各字段含义为：</p>
<p>V：RTP版本号。为“10”。</p>
<p>P：填充指示位。P为“1”时表示分组结尾含有1个或多个填充字节，其中这部分不属于有效载荷。</p>
<p>X：扩展指示位。X为“1”时，则表示固定头部后还有一个扩展头部，这种情况较复杂，很少使用。</p>
<p>CC：CSRC计数。指示固定头部后的CSRC的个数</p>
<p>M：标志。</p>
<p>PT：负载类型。表示RTP分组的负载类型。我们常用的有</p>
<table>
<thead>
<tr>
<th>Payload Type</th>
<th>Codec</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>PCM μ -Law</td>
</tr>
<tr>
<td>8</td>
<td>PCM-A Law</td>
</tr>
<tr>
<td>9</td>
<td>G..722 audio codec</td>
</tr>
<tr>
<td>4</td>
<td>G..723 audio codec</td>
</tr>
<tr>
<td>15</td>
<td>G..728 audio codec</td>
</tr>
<tr>
<td>18</td>
<td>G..729 audio codec</td>
</tr>
<tr>
<td>34</td>
<td>G..763 audio codec</td>
</tr>
<tr>
<td>31</td>
<td>G..761 audio codec</td>
</tr>
</tbody>
</table>
<p>序列号：序号顾名思义就是表示RTP分组的次序。初值为随机数，每发送一个增加1。可供接收方检测分组丢失和恢复分组次序。</p>
<p>时间戳：表示RTP分组第一个字节的取样时刻。其初值为随机数，每个采用周期加1。如果每次传送20ms的数据，由于音频的采样频率为8000Hz，即每20ms有160次采样，则每传送20ms的数据，时戳增加160。</p>
<p>SSRC：同步源标识(Synchronous Source)。表示信号的同步源，其值应随机选择，以保证同一个RTP会话中任意两个同步源的SSRC标识不同。</p>
<p>CSRC：分信源(贡献源)标识(Contributing Source)。识别该数据包中的有效载荷的贡献源。换句话说，CSRC标识由混合器插入，其值就是组成复合信号的各个分信号的SSRC标识，用以标识各个组成分信号的信源。RTP分组的头部最多可以包含15个CSRC标识，其数目由CC字段指明。</p>
<h4 id="RTCP协议结构"><a href="#RTCP协议结构" class="headerlink" title="RTCP协议结构"></a>RTCP协议结构</h4><p><img src="/images/video/RTP协议.jpg" alt="RTCP"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">版本（V）：同RTP包头域。</span><br><span class="line"></span><br><span class="line">填充（P）：同RTP包头域。</span><br><span class="line"></span><br><span class="line">接收报告计数器（RC）：5比特，该SR包中的接收报告块的数目，可以为零。</span><br><span class="line"></span><br><span class="line">包类型（PT）：8比特，SR包是200。</span><br><span class="line"></span><br><span class="line">长度域（Length）：16比特，其中存放的是该SR包以32比特为单位的总长度减一。</span><br><span class="line"></span><br><span class="line">同步源（SSRC of sender）：SR包发送者的同步源标识符。与对应RTP包中的SSRC一样。</span><br><span class="line"></span><br><span class="line">NTP Timestamp（Network time protocol）SR包发送时的绝对时间值。NTP的作用是同步不同的RTP媒体流。</span><br><span class="line"></span><br><span class="line">RTP Timestamp：与NTP时间戳对应，与RTP数据包中的RTP时间戳具有相同的单位和随机初始值。</span><br><span class="line"></span><br><span class="line">Sender’s packet count：从开始发送包到产生这个SR包这段时间里，发送者发送的RTP数据包的总数. SSRC改变时，这个域清零。</span><br><span class="line"></span><br><span class="line">Sender`s octet count：从开始发送包到产生这个SR包这段时间里，发送者发送的净荷数据的总字节数（不包括头部和填充）。发送者改变其SSRC时，这个域要清零。</span><br><span class="line"></span><br><span class="line">同步源n的SSRC标识符：该报告块中包含的是从该源接收到的包的统计信息。</span><br><span class="line"></span><br><span class="line">丢失率（Fraction Lost）：表明从上一个SR或RR包发出以来从同步源n(SSRC_n)来的RTP数据包的丢失率。</span><br><span class="line"></span><br><span class="line">累计的包丢失数目：从开始接收到SSRC_n的包到发送SR,从SSRC_n传过来的RTP数据包的丢失总数。</span><br><span class="line"></span><br><span class="line">收到的扩展最大序列号：从SSRC_n收到的RTP数据包中最大的序列号，</span><br><span class="line"></span><br><span class="line">接收抖动（Interarrival jitter）：RTP数据包接受时间的统计方差估计</span><br><span class="line"></span><br><span class="line">上次SR时间戳（Last SR,LSR）：取最近从SSRC_n收到的SR包中的NTP时间戳的中间32比特。如果目前还没收到SR包，则该域清零。</span><br><span class="line"></span><br><span class="line">上次SR以来的延时（Delay since last SR,DLSR）：上次从SSRC_n收到SR包到发送本报告的延时。</span><br></pre></td></tr></table></figure>
<p>根据所携带的控制信息不同RTCP信息包可分为RR（接收者报告包）、SR（源报告包）、SEDS（源描述包）、BYE（离开申明）和APP（特殊应用包）五类5类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>缩写表示</th>
<th>用途</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>SR（Sender Report）</td>
<td>发送端报告</td>
<td>发送端报告包，用于发送和接收活动源的统计信息；</td>
</tr>
<tr>
<td>201</td>
<td>RR（Receiver Report）</td>
<td>接收端报告</td>
<td>接收者报告包，用于接收非活动站的统计信息；</td>
</tr>
<tr>
<td>202</td>
<td>SDES（Source Description Items）</td>
<td>源点描述</td>
<td>源描述包，用于报告和站点相关的信息，包括CNAME；</td>
</tr>
<tr>
<td>203</td>
<td>BYE</td>
<td>结束传输</td>
<td>断开RTCP包，是站点离开系统的报告，表示结束；</td>
</tr>
<tr>
<td>204</td>
<td>APP</td>
<td>特定应用</td>
<td>应用特定函数。</td>
</tr>
</tbody>
</table>
<h2 id="RTSP"><a href="#RTSP" class="headerlink" title="RTSP"></a>RTSP</h2><p><img src="/images/video/RTSP协议.png" alt="image"></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>实时串流协议（应用层）,TCP/IP协议体系中的一个应用层协议，RTSP位于RTP和RTCP之上，可以基于TCP或者UDP来完成数据传输。RTSP实时性比较，扩展性比较好（UDP,TCP传输数据）。rtsp流主要是控制流媒体的行为动作，提供了诸如暂停，快进等控制，而它本身并不传输流媒体数。</p>
<h3 id="协议介绍-1"><a href="#协议介绍-1" class="headerlink" title="协议介绍"></a>协议介绍</h3><ol>
<li>RTSP结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtsp://admin:a12345678@47.106.89.193:10000/h264/ch33/main/av_stream</span><br></pre></td></tr></table></figure>
<p>结构：<br>rtsp://user:pwd@host:port/abs_path/content_name</p>
<p>user:摄像头设备的登陆用户名</p>
<p>pwd:摄像头设备的登陆密码</p>
<p>host:摄像头有效的域名或是IP地址</p>
<p>port:端口号，对于RTSP协议来说，缺省的端口号为554</p>
<p>abs_path:媒体流资源标识</p>
<ol>
<li>方法定义</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th>方向</th>
<th>对象</th>
<th>要求</th>
<th>含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DESCRIBE</td>
<td>C-&gt;S</td>
<td>P，S</td>
<td>推荐</td>
<td>检查演示或媒体对象的描述，也允许使用接收头指定用户理解的描述格式。DESCRIBE的答复-响应组成媒体RTSP初始阶段</td>
</tr>
<tr>
<td style="text-align:center">ANNOUNCE</td>
<td>C-&gt;S,S-&gt;C</td>
<td>P，S</td>
<td>可选</td>
<td>当从用户发往服务器时，ANNOUNCE将请求URL识别的演示或媒体对象描述发送给服务器；反之，ANNOUNCE实时更新连接描述。如新媒体流加入演示，整个演示描述再次发送，而不仅仅是附加组件，使组件能被删除</td>
</tr>
<tr>
<td style="text-align:center">GET_PARAMETER</td>
<td>C-&gt;S,S-&gt;C</td>
<td>P，S</td>
<td>可选</td>
<td>GET_PARAMETER请求检查URL指定的演示与媒体的参数值。没有实体体时，GET_PARAMETER也许能用来测试用户与服务器的连通情况</td>
</tr>
<tr>
<td style="text-align:center">OPTIONS</td>
<td>C-&gt;S,S-&gt;C</td>
<td>P，S</td>
<td>要求</td>
<td>可在任意时刻发出OPTIONS请求，如用户打算尝试非标准请求，并不影响服务器状态</td>
</tr>
<tr>
<td style="text-align:center">PAUSE</td>
<td>C-&gt;S</td>
<td>P，S</td>
<td>推荐</td>
<td>PAUSE请求引起流发送临时中断。如请求URL命名一个流，仅回放和记录被停止；如请求URL命名一个演示或流组，演示或组中所有当前活动的流发送都停止。恢复回放或记录后，必须维持同步。在SETUP消息中连接头超时参数所指定时段期间被暂停后，尽管服务器可能关闭连接并释放资源，但服务器资源会被预订</td>
</tr>
<tr>
<td style="text-align:center">PLAY</td>
<td>C-&gt;S</td>
<td>P，S</td>
<td>要求</td>
<td>PLAY告诉服务器以SETUP指定的机制开始发送数据；直到一些SETUP请求被成功响应，客户端才可发布PLAY请求。PLAY请求将正常播放时间设置在所指定范围的起始处，发送流数据直到范围的结束处。PLAY请求可排成队列，服务器将PLAY请求排成队列，顺序执行</td>
</tr>
<tr>
<td style="text-align:center">RECORD</td>
<td>C-&gt;S</td>
<td>P，S</td>
<td>可选</td>
<td>该方法根据演示描述初始化媒体数据记录范围，时标反映开始和结束时间；如没有给出时间范围，使用演示描述提供的开始和结束时间。如连接已经启动，立即开始记录，服务器数据请求URL或其他URL决定是否存储记录的数据；如服务器没有使用URL请求，响应应为201（创建），并包含描述请求状态和参考新资源的实体与位置头。支持现场演示记录的媒体服务器必须支持时钟范围格式，smpte格式没有意义</td>
</tr>
<tr>
<td style="text-align:center">REDIRECT</td>
<td>S-&gt;C</td>
<td>P，S</td>
<td>可选</td>
<td>重定向请求通知客户端连接到另一服务器地址。它包含强制头地址，指示客户端发布URL请求；也可能包括参数范围，以指明重定向何时生效。若客户端要继续发送或接收URL媒体，客户端必须对当前连接发送TEARDOWN请求，而对指定主执新连接发送SETUP请求</td>
</tr>
<tr>
<td style="text-align:center">SETUP</td>
<td>C-&gt;S</td>
<td>S</td>
<td>要求</td>
<td>对URL的SETUP请求指定用于流媒体的传输机制。客户端对正播放的流发布一个SETUP请求，以改变服务器允许的传输参数。如不允许这样做，响应错误为”455 Method Not Valid In This State”。为了透过防火墙，客户端必须指明传输参数，即使对这些参数没有影响</td>
</tr>
<tr>
<td style="text-align:center">SET_PARAMETER</td>
<td>C-&gt;S,S-&gt;C</td>
<td>P，S</td>
<td>可选</td>
<td>这个方法请求设置演示或URL指定流的参数值。请求仅应包含单个参数，允许客户端决定某个特殊请求为何失败。如请求包含多个参数，所有参数可成功设置，服务器必须只对该请求起作用。服务器必须允许参数可重复设置成同一值，但不让改变参数值。注意：媒体流传输参数必须用SETUP命令设置。将设置传输参数限制为SETUP有利于防火墙。将参数划分成规则排列形式，结果有更多有意义的错误指示</td>
</tr>
<tr>
<td style="text-align:center">TEARDOWN</td>
<td>C-&gt;S</td>
<td>S</td>
<td>要求</td>
<td>TEARDOWN请求停止给定URL流发送，释放相关资源。如URL是此演示URL，任何RTSP连接标识不再有效。除非全部传输参数是连接描述定义的，SETUP请求必须在连接可再次播放前发布</td>
</tr>
</tbody>
</table>
<ol>
<li><p>交互流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">C表示RTSP客户端,S表示RTSP服务端</span><br><span class="line"></span><br><span class="line">1. 第一步：查询服务器端可用方法</span><br><span class="line">1.C-&gt;S:OPTION request //询问S有哪些方法可用</span><br><span class="line"></span><br><span class="line">1.S-&gt;C:OPTION response //S回应信息的public头字段中包括提供的所有可用方法</span><br><span class="line"></span><br><span class="line">2. 第二步：得到媒体描述信息</span><br><span class="line">2.C-&gt;S:DESCRIBE request //要求得到S提供的媒体描述信息</span><br><span class="line"></span><br><span class="line">2.S-&gt;C:DESCRIBE response //S回应媒体描述信息，一般是sdp信息</span><br><span class="line"></span><br><span class="line">3. 第三步：建立RTSP会话</span><br><span class="line">3.C-&gt;S:SETUP request //通过Transport头字段列出可接受的传输选项，请求S建立会话</span><br><span class="line"></span><br><span class="line">3.S-&gt;C:SETUP response //S建立会话，通过Transport头字段返回选择的具体转输选项，并返回建立的Session ID;</span><br><span class="line"></span><br><span class="line">4. 第四步：请求开始传送数据</span><br><span class="line">4.C-&gt;S:PLAY request //C请求S开始发送数据</span><br><span class="line"></span><br><span class="line">4.S-&gt;C:PLAY response //S回应该请求的信息</span><br><span class="line"></span><br><span class="line">5. 第五步： 数据传送播放中</span><br><span class="line">S-&gt;C:发送流媒体数据 // 通过RTP协议传送数据</span><br><span class="line"></span><br><span class="line">6. 第六步：关闭会话，退出</span><br><span class="line">6.C-&gt;S:TEARDOWN request //C请求关闭会话</span><br><span class="line"></span><br><span class="line">6.S-&gt;C:TEARDOWN response //S回应该请求</span><br></pre></td></tr></table></figure>
</li>
<li><p>RTSP与HTTP区别</p>
</li>
</ol>
<ul>
<li>RTSP中客户端和服务器都可以发出请求,HTTP只能客户端发起请求；</li>
<li>RTSP相比HTTP提供多种方法定义</li>
<li>RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据</li>
</ul>
<h2 id="SDP-SIP"><a href="#SDP-SIP" class="headerlink" title="SDP/SIP"></a>SDP/SIP</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>SIP与SDP这两个协议会在国标视频上会出现比较多。其中一般会与RTSP等协议共同</p>
<p>SIP它是一个基于文本的应用层控制协议，独立于底层传输协议，用于建立、修改和终止IP网络上的双方或多方多媒体会话</p>
<p>SDP（Session Description Protocol）是一个用来描述多媒体会话的应用层控制协议，它是一个基于文本的协议，用于会话建立过程中的媒体类型和编码方案的协商等</p>
<h3 id="协议介绍-2"><a href="#协议介绍-2" class="headerlink" title="协议介绍"></a>协议介绍</h3><h4 id="SIP介绍"><a href="#SIP介绍" class="headerlink" title="SIP介绍"></a>SIP介绍</h4><ol>
<li>SIP 角色</li>
</ol>
<table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户代理（UA）</td>
<td>用户代理客户端（UAC）和用户代理服务器（UAS）组成，UAC负责发起呼叫，UAS负责接收呼叫并作出响应</td>
</tr>
<tr>
<td>代理服务器（PS）</td>
<td>通过它把来自用户代理客户端（UAC）的请求转发到用户代理服务端（UAS），并把UAS的响应消息转发回UAC</td>
</tr>
<tr>
<td>注册服务器（register server）</td>
<td>是具有接收注册请求、将请求中携带的信息进行保存并提供本域内位置服务的功能服务器</td>
</tr>
<tr>
<td>重定向服务器（redirect server）</td>
<td>负责规划SIP呼叫路由。它将获得的呼叫下一跳地址信息告诉呼叫方，以使呼叫方根据此地址直接向下一跳发出请求，此后重定向服务器退出呼叫过程。</td>
</tr>
</tbody>
</table>
<ol>
<li><p>SIP请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">是客户端发给服务器激活一个SIP操作的消息，由一个方法名（Method）、一个请求URI（Request-URI）和一个协议版本 （SIP-Version）组成，三个部分之间以空格（SP）间隔。</span><br><span class="line"></span><br><span class="line">Request-Line  =  Method + SP + Request-URI + SP + SIP-Version + CRLF</span><br><span class="line"></span><br><span class="line">RFC中定义了6中请求：</span><br><span class="line"></span><br><span class="line">INVITE：表明接收用户或服务被邀请加入一个会话；也可以使用这种方式来修改先前建立会话的特性；成功响应（200 OK）表明被叫方愿意参与会话；</span><br><span class="line"></span><br><span class="line">ACK：确认UAC已经接收到了INVITE请求的最终响应（只与INVITE请求一起使用）；用于结束一个200 OK响应；若INVITE请求中不含有会话描述信息，ACK可以包含一个最终会话描述的消息体；</span><br><span class="line"></span><br><span class="line">OPTION：UA用此向UAS查询它的功能；</span><br><span class="line"></span><br><span class="line">BYE：用于终结一个先前建立的会话；</span><br><span class="line"></span><br><span class="line">CANCEL：使UAC和网络服务器取消一个正在进行的请求（如INVITE）；</span><br><span class="line"></span><br><span class="line">REGISTER：客户端注册其目前的位置信息；</span><br></pre></td></tr></table></figure>
</li>
<li><p>SIP响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">服务器向客户端发送SIP响应，指明客户端先前发送给服务器的SIP请求的状态；由一个协议版本（SIP-Version），一个状态码（Status-Code）和一个原因说明（Reason-Phrase）组成，类似于请求消息，三个部分之间也以空格字符（SP）间隔。</span><br><span class="line"></span><br><span class="line">Status-Line := SIP-Version + SP + Status-Code + SP + Reason-Phrase + CRLF</span><br><span class="line"></span><br><span class="line">状态码是一个100～699之间的3位正整数（具体参见后面附录），它表示对于一个请求消息的响应结果；原因说明是一串可以显示的字符，用于对响应的状态码进行简短说明。</span><br><span class="line"></span><br><span class="line">1xx：临时响应 （Provisional）；之前的请求消息已经收到，并准备接着处理后面的请求消息。</span><br><span class="line"></span><br><span class="line">2xx：成功响应 （Success）； 操作成功，请求消息已被收到并且成功地处理。</span><br><span class="line"></span><br><span class="line">3xx：重定向响应 （Redirection）； 服务器向客户端返回其它可能的位置，客户端应当根据响应中包含的地址信息向另一个服务器重发请求消息。</span><br><span class="line"></span><br><span class="line">4xx： 客户端错误 （Client Error）； 请求由于客户端的错误而失败，客户端可以根据响应状态码修改并重发刚才的请求消息。</span><br><span class="line"></span><br><span class="line">5xx：服务器错误 （Server Error） ；请求由于服务器的错误而失败，客户端可以向另一个服务器重发请求消息。</span><br><span class="line"></span><br><span class="line">6xx：全局错误（Global Failure）； 请求失败，客户端不应该再向任何服务器重发该请求消息。</span><br></pre></td></tr></table></figure>
</li>
<li><p>标题头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">遵从HTTP标题头（RFC2616）定义的同样格式：每个标题头由字段名，紧跟着冒号(:)和字段组成。</span><br><span class="line"></span><br><span class="line">主要标题头（详情参见</span><br><span class="line"></span><br><span class="line">SIP常见头域（header）说明</span><br><span class="line"></span><br><span class="line">From：定义请求发起者（通常是发送者AOR），包含SIP或SIP URI和一个可选的显示名字；</span><br><span class="line"></span><br><span class="line">To：定义了请求的接收者（通常是接收者AOR），包含SIP或SIP URI和一个可选的显示名字；因重定向和转移，SIP请求不一定发送给‘希望的’接收者；</span><br><span class="line"></span><br><span class="line">Call-ID：定义了一系列的SIP消息，对所有由对话中的UA发送的所有SIP请求和响应，Call-ID必须唯一；</span><br><span class="line"></span><br><span class="line">Cseq：由一个整数值和一个方式名称组成，在一个对话中标识和序列SIP请求，也区分重传和新消息；</span><br><span class="line"></span><br><span class="line">Via：定义请求路径和响应要发送的地址；</span><br><span class="line"></span><br><span class="line">Contact：定义US希望接收新SIP请求的SIP或SIPS URI（实际地址）；</span><br><span class="line"></span><br><span class="line">Allow：列出产生SIP消息的UA所支持的功能集合；</span><br><span class="line"></span><br><span class="line">Supported：列出所有UA支持的SIP扩展（RFC3262）；</span><br><span class="line"></span><br><span class="line">Require：包含远端UA必须支持的SIP扩展；</span><br><span class="line"></span><br><span class="line">Content-Type：请求或响应的消息体类型；</span><br><span class="line"></span><br><span class="line">Content-Length：请求或响应的消息体的大小（十进制）；</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="SDP协议"><a href="#SDP协议" class="headerlink" title="SDP协议"></a>SDP协议</h4><p>SDP协议内容(具体可参考国标规范文档)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 v=:Version ，表示协议的版本号</span><br><span class="line">2 o=: Origin,表示源。值域中各项的含义依次是username(用户名)，sess-id(会话ID)，sess-version(会话版本号)，nettype(网络类型)，addrtype(地址类型)，unucast-address(单播地址)。</span><br><span class="line">3 s=:Session Name,表示本sdp所描述的session的名称</span><br><span class="line">4 c=:Connection Data 链接数据。其中值域中以空格分配的两个字段分贝是网络类型和网络地址，以后的RTP流就会发到该地址上。</span><br><span class="line">5 b=:Badwidth type，带宽类型</span><br><span class="line">6 t=:Timing ,起止时间，0表示无限</span><br><span class="line">7 m=:audio Media Type,媒体类型。audio表示音频，50452表示音频端口号，RTP/AVR是传输协议；后面是支持的Codec类型，与RTP流中的PayloadType(载荷类型)相对应，在这里分别是8,0,98和101,8和0分别代表PCMA和PCMU，他们属于静态编码，大于95的编码都属于动态编码，需要在后面使用“a=rtpmap”进行说明。</span><br><span class="line">8 a=: Attributes,属性。 它用于描述上面的音频的属性。如本例中98代表8000hz的ILBC编码，101代表RFC2833dtmf事件。a=sendrecv表示该媒体流可用于收和发，其他的还有sendonly(仅收)，recvonly(仅发)和inactive(不收不发)</span><br><span class="line">9 v=:Video，视频。</span><br></pre></td></tr></table></figure></p>
<h4 id="点播流程"><a href="#点播流程" class="headerlink" title="点播流程"></a>点播流程</h4><p>为了更加熟悉SIP的流程，截取点播流程的流程图。可以看出，SIP传输过程当中都会有SDP的使用。</p>
<p><img src="/images/video/wps2.png" alt="SIP点播流程"></p>
<h2 id="RTMP-HTTP-HLS-HTTP-FLV"><a href="#RTMP-HTTP-HLS-HTTP-FLV" class="headerlink" title="RTMP/HTTP-HLS/HTTP-FLV"></a>RTMP/HTTP-HLS/HTTP-FLV</h2><p>RTMP、HTTP-HLS与HTTP-FLV目前市面上比较常用的流媒体协议，都能基于浏览器来观看。</p>
<ul>
<li><p>RTMP：实时消息传送协议，基于FLASH播放器的私有协议，默认使用端口 1935。RTMP一般被切割一个个块（chunk）的形式基于TCP协议上传输的明文协议。市面上的摄像头基本都会支持RTMP的形式，而且RTMP一般延时在 1-3s 之间相对延时较低，不过目前来说谷歌禁用了FLASH，可能对RTMP支持可能有所减弱</p>
</li>
<li><p>HTTP-HLS：HTTP Live Streaming，苹果公司基于HTTP的流媒体传输协议。工作原理是在服务端将视频流切片成ts小文件形式，通过m3u8索引文件访问ts文件。不过HLS的延迟在10s以上，且文件比较碎片化比较难以保存，但是有利有弊，正因为有ts文件落地，可支持回放等功能。</p>
</li>
<li><p>HTTP-FLV：Flash Video，主要是将音视频数据封装成FLV格式，然后通过 HTTP 协议传输给客户端。像B站都是使用该协议进行PC页面播放。FLV延迟比较低。</p>
</li>
<li><p>ws-flv：ws-flv直播技术基本与http-flv一致，无非是传输介质换成了websocket协议，除了解除了http-flv不能同时打开过多同域名下的直播窗口的限制，其他技术特性、参数基本与http-flv一致。目前看，ws-flv既适合视频监控(可以同时打开多路监控视频)也适合视频直播行业，是rtmp很高的升级替代方案。</p>
</li>
<li>webrtc：webrtc是谷歌主导的视频通话技术标准，目前各大主流浏览器都兼容该标准。通过该技术，用户可以在浏览器上实现无插件的视频通话，该技术也可以用于实现低延时的视频直播。目前业界也有很多基于webrtc的应用和产品，但是很多局限于视频聊天等低延时交互式场景，在视频监控领域，目前还尚未流行。而且该技术栈目前还在持续更新，技术难点太多，要与视频监控领域融合还需时日。</li>
</ul>
<h3 id="协议介绍-3"><a href="#协议介绍-3" class="headerlink" title="协议介绍"></a>协议介绍</h3><h4 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h4><p><img src="/images/video/hls-message.png" alt="RTMP"></p>
<p>具体可参考：<a href="https://www.jianshu.com/p/d511d59b185c" target="_blank" rel="noopener">RTMP协议详解</a></p>
<h4 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h4><p><a href="https://www.jianshu.com/p/d511d59b185c" target="_blank" rel="noopener">HLS协议详解</a></p>
<p>以下简单介绍下m3u8的相关内容</p>
<p><img src="/images/video/hls.png" alt="m3u8"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">EXTM3U：每个M3U文件第一行必须是这个tag，请标示作用</span><br><span class="line"></span><br><span class="line">EXT-X-MEDIA-SEQUENCE:7</span><br><span class="line">每一个media URI 在 PlayList中只有唯一的序号，相邻之间序号+1, 一个media URI并不是必须要包含的，如果没有，默认为0</span><br><span class="line"></span><br><span class="line">EXTINF:</span><br><span class="line">duration 指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效，title是下载资源的url</span><br><span class="line"></span><br><span class="line">EXT-X-TARGETDURATION</span><br><span class="line">指定最大的媒体段时间长（秒）。所以#EXTINF中指定的时间长度必须小于或是等于这个最大值。这个tag在整个PlayList文件中只能出现一 次（在嵌套的情况下，一般有真正ts url的m3u8才会出现该tag）</span><br><span class="line"></span><br><span class="line">EXT-X-KEY</span><br><span class="line">表示怎么对media segments进行解码。其作用范围是下次该tag出现前的所有media URI，属性为NONE 或者 AES-128。NONE表示 URI以及IV（Initialization Vector）属性必须不存在， AES-128(Advanced EncryptionStandard)表示URI必须存在，IV可以不存在。</span><br><span class="line">对于AES-128的情况，keytag和URI属性共同表示了一个key文件，通过URI可以获得这个key，如果没有IV（Initialization Vector）,则使用序列号作为IV进行编解码，将序列号的高位赋到16个字节的buffer中，左边补0；如果有IV，则将改值当成16个字节的16进制数。</span><br><span class="line"></span><br><span class="line">EXT-X-PROGRAM-DATE-TIME</span><br><span class="line">将一个绝对时间或是日期和一个媒体段中的第一个sample相关联，只对下一个meida URI有效，格式如#EXT-X-PROGRAM-DATE-TIME:</span><br><span class="line">For example: #EXT-X-PROGRAM-DATE-TIME:2010-02-19T14:54:23.031+08:00</span><br><span class="line"></span><br><span class="line">EXT-X-ALLOW-CACHE</span><br><span class="line">是否允许做cache，这个可以在PlayList文件中任意地方出现，并且最多出现一次，作用效果是所有的媒体段。格式如下：#EXT-X-ALLOW-CACHE:</span><br><span class="line"></span><br><span class="line">EXT-X-PLAYLIST-TYPE</span><br><span class="line">提供关于PlayList的可变性的信息， 这个对整个PlayList文件有效，是可选的，格式如下：#EXT-X-PLAYLIST-TYPE:：如果是VOD，则服务器不能改变PlayList 文件；如果是EVENT，则服务器不能改变或是删除PlayList文件中的任何部分，但是可以向该文件中增加新的一行内容。</span><br><span class="line"></span><br><span class="line">EXT-X-ENDLIST</span><br><span class="line">表示PlayList的末尾了，它可以在PlayList中任意位置出现，但是只能出现一个，格式如下：#EXT-X-ENDLIST</span><br><span class="line"></span><br><span class="line">EXT-X-MEDIA</span><br><span class="line">被用来在PlayList中表示相同内容的不用语种/译文的版本，比如可以通过使用3个这种tag表示3中不用语音的音频，或者用2个这个tag表示不同角度的video在PlayLists中。这个标签是独立存在的，属性包含：</span><br><span class="line">URI：如果没有，则表示这个tag描述的可选择版本在主PlayList的EXT-X-STREAM-INF中存在;</span><br><span class="line">TYPE:AUDIO and VIDEO;</span><br><span class="line">GROUP-ID:具有相同ID的MEDIAtag，组成一组样式；</span><br><span class="line">LANGUAGE：确定使用的主要语言</span><br><span class="line">NAME：人类可读的语言的翻译</span><br><span class="line">DEFAULT：YES或是NO，默认是No，如果是YES，则客户端会以这种选项来播放，除非用户自己进行选择。</span><br><span class="line">AUTOSELECT：YES或是NO，默认是No，如果是YES，则客户端会根据当前播放环境来进行选择（用户没有根据自己偏好进行选择的前提下）。</span><br><span class="line"></span><br><span class="line">EXT-X-STREAM-INF</span><br><span class="line">指定一个包含多媒体信息的 media URI 作为PlayList，一般做M3U8的嵌套使用，它只对紧跟后面的URI有效，格式如下：#EXT-X-STREAM-INF:有以下属性：</span><br><span class="line">BANDWIDTH：带宽，必须有。</span><br><span class="line">PROGRAM-ID：该值是一个十进制整数，惟一地标识一个在PlayList文件范围内的特定的描述。一个PlayList 文件中可能包含多个有相同ID的此tag。</span><br><span class="line">CODECS：不是必须的。</span><br><span class="line">RESOLUTION：分辨率。</span><br><span class="line">AUDIO：这个值必须和AUDIO类别的“EXT-X-MEDIA”标签中“GROUP-ID”属性值相匹配。</span><br><span class="line">VIDEO：同上</span><br></pre></td></tr></table></figure>
<h4 id="FLV"><a href="#FLV" class="headerlink" title="FLV"></a>FLV</h4><p><a href="https://zhuanlan.zhihu.com/p/287220" target="_blank" rel="noopener">FLV协议详解</a></p>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p><img src="/images/video/协议性能对比.png" alt="协议性能对比"></p>
<h2 id="PES-TS-ES流"><a href="#PES-TS-ES流" class="headerlink" title="PES/TS/ES流"></a>PES/TS/ES流</h2><p>PES、TS、ES流都是用于封装视频、音频数据的数据流。</p>
<p>ES流（Elementary Stream）：基本码流，不分段的音频、视频或其他信息的连续码流。</p>
<p>PES流：把基本流ES分割成段，并加上相应头文件打包成形的打包基本码流。</p>
<p>PS流（Program Stream）：节目流，将具有共同时间基准的一个或多个PES组合（复合）而成的单一数据流（用于播放或编辑系统，如m2p）。</p>
<p>TS流（Transport Stream）：传输流，将具有共同时间基准或独立时间基准的一个或多个PES组合（复合）而成的单一数据流（用于数据传输）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面列了很多我在项目中所有用到过的协议，每种协议都有不同的封装格式以及各自不同属性，个人觉得对于开发者或者使用者来说不一定每种协议都要面面俱到，平常大概知道他们具体作用性能和普遍的属性之类就可以，到真正使用的时候再去深入了解，反而会更高效。以下，我总结下这段时间来对这几个协议的了解：<br>    <img src="/images/video/zlm.png" alt="协议"></p>
<p>根据上图可以看出，一般来说推流的方式可能会议国标方式或者接入海康、大华等厂商的摄像头来直接推流到流媒体，而从流媒体转码成flv,hls等不同协议供客户端来拉流访问。</p>
<p>参考</p>
<ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/72917813" target="_blank" rel="noopener">关于RTSP/RTP/RTCP</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/news/387488" target="_blank" rel="noopener">会话初始协议SIP与SDP简介</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/48100533" target="_blank" rel="noopener">RTMP、HTTP-FLV、HLS，你了解常见的三大直播协议吗
</a></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/gateway源码分析(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/25/gateway源码分析(一)/" itemprop="url">Gateway源码分析（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-25T11:16:39+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当选用了SpringCloud Gateway作为视频项目的网关之后,出于学习的心态，看下视频网关是如何构造起来的。</p>
<h2 id="Spring-WebFlux学习"><a href="#Spring-WebFlux学习" class="headerlink" title="Spring WebFlux学习"></a>Spring WebFlux学习</h2><p>阅读源码之前首先学习下WebFlux基础概念和相关常用的API</p>
<p>Spring WebFlux简单说是与Spring MVC类似的一门响应式异步非阻塞Web端控制框架。与Spring MVC有着相同功能的注解</p>
<ol>
<li>什么是响应式编程(Reactive)</li>
</ol>
<p>官方解释：</p>
<blockquote>
<p>The term, “reactive,”  refers to programming models that are built around reacting to change<br>响应式编程是一种围绕对变化作出反应而构建的编程模型。</p>
</blockquote>
<p>后面给出了例子：</p>
<blockquote>
<p>network components reacting to I/O events, UI controllers reacting to mouse events, and others. In that sense, non-blocking is reactive, because, instead of being blocked, we are now in the mode of reacting to notifications as operations complete or data becomes available.<br>网络组件对IO事件的响应，UI控制器对鼠标事件的响应。从这个意义上说，非阻塞也是响应式,因为我们现在也是在操作完成或者数据可用的时候作出响应的模式，而不是被阻塞。</p>
</blockquote>
<ol>
<li>什么是背压（back pressure）</li>
</ol>
<p>官方解析：</p>
<blockquote>
<p>Reactive Streams is a small spec (also adopted in Java 9) that defines the interaction between asynchronous components with back pressure. For example a data repository (acting as Publisher) can produce data that an HTTP server (acting as Subscriber) can then write to the response. The main purpose of Reactive Streams is to let the subscriber control how quickly or how slowly the publisher produces data.<br>响应式流是一个小小的规范，定义了带有背压异步组件交互。例如，数据仓库（作为发布者）产生数据使HTTP服务（作为订阅者）能响应。主要目的就是响应式能让订阅者控制发布者发布数据的快与慢。</p>
</blockquote>
<p>其实上述说白了就是订阅者能够通过生产者需要多小数据，这样能够以免生产者无限量产生数据压垮订阅者。</p>
<ol>
<li>SpringMVC与WebFlux选择<br><img src="https://docs.spring.io/spring-framework/docs/current/reference/html/images/spring-mvc-and-webflux-venn.png" alt="webFlux&amp;SpringMVC"></li>
</ol>
<ul>
<li><p>如果您有运行正常的Spring MVC应用程序，则无需更改。命令式编程是编写，理解和调试代码的最简单方法。您有最大的库选择空间，因为从历史上看，大多数库都是阻塞的。</p>
</li>
<li><p>如果您已经在选择无阻塞的Web堆栈，Spring WebFlux可以提供与该领域其他服务器相同的执行模型优势，还可以选择服务器（Netty，Tomcat，Jetty，Undertow和Servlet 3.1+容器），选择编程模型（带注释的控制器和功能性Web端点），以及选择反应式库（Reactor，RxJava或其他）。</p>
</li>
<li><p>如果您对与Java 8 lambda或Kotlin一起使用的轻量级功能性Web框架感兴趣，则可以使用Spring WebFlux功能性Web端点。对于要求较低复杂性的较小应用程序或微服务（可以受益于更高的透明度和控制）而言，这也是一个不错的选择。</p>
</li>
<li><p>在微服务架构中，您可以混合使用带有Spring MVC或Spring WebFlux控制器或带有Spring WebFlux功能端点的应用程序。在两个框架中都支持相同的基于注释的编程模型，这使得重用知识变得更加容易，同时还为正确的工作选择了正确的工具。</p>
</li>
<li><p>评估应用程序的一种简单方法是检查其依赖关系。如果您要使用阻塞性持久性API（JPA，JDBC）或网络API，则Spring MVC至少是通用体系结构的最佳选择。使用Reactor和RxJava在单独的线程上执行阻塞调用在技术上是可行的，但您不会充分利用非阻塞Web堆栈。</p>
</li>
<li><p>如果您的Spring MVC应用程序具有对远程服务的调用，请尝试使用active WebClient。您可以直接从Spring MVC控制器方法返回反应类型（Reactor，RxJava或其他）。每个呼叫的等待时间或呼叫之间的相互依赖性越大，好处就越明显。Spring MVC控制器也可以调用其他反应式组件。</p>
</li>
</ul>
<ol>
<li>WebFlux提供了两种模型</li>
</ol>
<ul>
<li>注解控制器（Annotated Controllers）：与Spring MVC有一致的注解，都是基于spring-web模型。一个显著的区别是，WebFlux也支持响应式@RequestBody参数。</li>
<li>函数终端（Functional Endpoints）：基于Lambda,轻量级和函数编程模型。提供了大量的方法来路由和处理请求。与注解控制器（Annotated Controllers）最大区别就是函数端模型能够负责请求的从头到尾的处理而不是只是通过声明注解然后回调。</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>两个Publisher接口：Flux与Mono。两者区别在于Flux是代表多个元素的发布者，Mono是单个元素的发布者.</p>
<p>Mono 实现了 Publisher 接口，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">empty()：创建一个不包含任何元素，只发布结束消息的序列。</span><br><span class="line">just()：可以指定序列中包含的全部元素。创建出来的 Mono序列在发布这些元素之后会自动结束。</span><br><span class="line">justOrEmpty()：从一个 Optional 对象或可能为 null 的对象中创建 Mono。只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。</span><br><span class="line">error(Throwable error)：创建一个只包含错误消息的序列。</span><br><span class="line">never()：创建一个不包含任何消息通知的序列。</span><br><span class="line">fromCallable()、fromCompletionStage()、fromFuture()、fromRunnable()和 fromSupplier()：分别从 Callable、CompletionStage、CompletableFuture、Runnable 和 Supplier 中创建 Mono。</span><br><span class="line">delay(Duration duration)和 delayMillis(long duration)：创建一个 Mono 序列，在指定的延迟时间之后，产生数字 0 作为唯一值。</span><br><span class="line">create()：通过 create()方法来使用 MonoSink 来创建 Mono。</span><br></pre></td></tr></table></figure></p>
<p>Flux<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">just：可以指定序列中包含的全部元素。创建出来的 Flux 序列在发布这些元素之后会自动结束。</span><br><span class="line">fromArray、fromIterable、fromStream：可以从一个数组、Iterable 对象或 Stream 对象中创建 Flux 对象。</span><br><span class="line">empty()：创建一个不包含任何元素，只发布结束消息的序列,在响应式编程中，流的传递是基于元素的，empty表示没有任何元素，所以不会进行后续传递，需要用switchIfEmpty等处理</span><br><span class="line">error(Throwable error)：创建一个只包含错误消息的序列。</span><br><span class="line">never()：创建一个不包含任何消息通知的序列。使用示例：</span><br><span class="line">range(int start, int count)：创建包含从 start 起始的 count 个数量的 Integer 对象的序列。</span><br><span class="line">intervalMillis(long period)： interval()方法的作用相同，只不过该方法通过毫秒数来指定时间间隔和延迟时间。</span><br><span class="line">create()：与 generate()方法的不同之处在于所使用的是 FluxSink 对象。FluxSink 支持同步和异步的消息产生，并且可以在一次调用中产生多个元素。</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章主要是简单记录下WebFlux的介绍以及简单说明下WebFlux相关的几个概念。WebFlux的官方文档还是相对比较完善的，里面都有挺详细的说明，我就不一一照搬到这里。下一章就开始阅读Gateway的代码，看下Gateway里面是如何使用WebFlux构建网关。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#spring-webflux" target="_blank" rel="noopener">webFlux官网</a></li>
</ul>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/92460075" target="_blank" rel="noopener">外行人都能看得懂的WebFlux</a></li>
</ul>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485692&amp;idx=1&amp;sn=a6b3f040b13fa2324992b11a927e34dc&amp;chksm=ebd749fddca0c0eb1b05c08ede7ee4a44699584fbc0c3449ec2cac7642fd13819470ec7f44d8&amp;token=1024331018&amp;lang=zh_CN#rd" target="_blank" rel="noopener">最近学到的Lambda表达式基础知识</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/nginx支持流媒体/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/25/nginx支持流媒体/" itemprop="url">nginx支持流媒体</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-25T11:16:39+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本章介绍如何搭建一个nginx的流媒体服务器，可以直接通过nginx访问hls的m3u8与rtmp的链接。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装nginx其实没有什么值得说，主要是要下载nginx的nginx-rtmp-module模块,编译时候加下此模块就OK了</p>
<p>下载nginx-rtmp-module：<a href="https://github.com/arut/nginx-rtmp-module" target="_blank" rel="noopener">https://github.com/arut/nginx-rtmp-module</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-pcre=/home/user/pcre/pcre-8.32 --with-zlib=/home/user/zlib/zlib-1.2.8 --with-openssl=/home/user/openssl/openssl-1.0.1i  --add-module=/home/user/nginx-rtmp-module</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li><p>RTMP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;                #RTMP服务</span><br><span class="line">   server &#123;</span><br><span class="line">       listen 1935;  #//服务端口</span><br><span class="line">       chunk_size 4096;   #//数据传输块的大小</span><br><span class="line">       application vod &#123;</span><br><span class="line">         play /opt/video/vod; #//视频文件存放位置。</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include      mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen      80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        #配置nginx的rtmp一览页面</span><br><span class="line">        location /stat &#123;</span><br><span class="line">                rtmp_stat all;</span><br><span class="line">            rtmp_stat_stylesheet stat.xsl;</span><br><span class="line">        &#125;</span><br><span class="line">        location /stat.xsl &#123;</span><br><span class="line">           root /etc/rtmpServer/nginx-rtmp-module/;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root  html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page  500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root  html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HLS</p>
</li>
</ul>
<p>该配置是播放hls的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /hls &#123;  </span><br><span class="line">    types&#123;  </span><br><span class="line">        application/vnd.apple.mpegurl m3u8;  </span><br><span class="line">        video/mp2t ts;  </span><br><span class="line">    &#125;  </span><br><span class="line">    suffix m3u8;</span><br><span class="line">   #配置一个根路径 </span><br><span class="line">   root /data/baiyun/; </span><br><span class="line">   add_header Cache-Control no-cache;</span><br><span class="line">   add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;</span><br><span class="line">   add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该配置是支持远程推流到nginx负责切片成m3u8的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        chunk_size 4000;</span><br><span class="line">        #HLS</span><br><span class="line">        application hls &#123;</span><br><span class="line">            live on;</span><br><span class="line">            hls on;</span><br><span class="line">            #视频流存放地址</span><br><span class="line">            hls_path /usr/local/nginx/html/hls; </span><br><span class="line">            hls_fragment 5s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weiyuefei/article/details/74001589" target="_blank" rel="noopener">视频直播点播nginx-rtmp开发手册中文版</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Jay-Luo" />
            
              <p class="site-author-name" itemprop="name">Jay-Luo</p>
              <p class="site-description motion-element" itemprop="description">小小的天，大大的梦</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yourname" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jay-Luo</span>

  
</div>


  <div class="powered-by">个人专属</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">博客 &mdash; NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
