{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/nginx/select.jpg","path":"images/nginx/select.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/nginx/worker.jpg","path":"images/nginx/worker.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1518490086978},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1518490086978},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1518490086978},{"_id":"themes/next/.gitignore","hash":"b935cc0e5b099ebd343ca1766e02f65138c13dd0","modified":1518490086978},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1518490086978},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1518490086978},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1518490086978},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1518490086978},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1518490086978},{"_id":"themes/next/README.cn.md","hash":"59e323ce21535d561507c9ecc984b7c4dcb61514","modified":1518490086978},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1518490086978},{"_id":"themes/next/README.md","hash":"7423256d6e7622434bbfe20c467819687e8e1b27","modified":1518490086978},{"_id":"themes/next/_config.yml","hash":"ad0b289e34e16f1133a2360852599510e54f9009","modified":1631001652031},{"_id":"themes/next/bower.json","hash":"47471a8f13528dc4052b746db5b4be2375682173","modified":1518490086978},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1518490086978},{"_id":"themes/next/package.json","hash":"39370e2aadf1f9a7c105edff064c6e47682b3932","modified":1518490087010},{"_id":"themes/next/package-lock.json","hash":"cc3e9b232005f824a73555ad6568d566b8aae554","modified":1518490087010},{"_id":"source/_posts/FFmpeg学习与使用.md","hash":"56efb8dd28acdd01494107985cc3c6d7336775fd","modified":1631001652015},{"_id":"source/_posts/Kettle自定义插件开发.md","hash":"cf17a24f5564cbeb6e28f8cb70939def057eaf49","modified":1631014898473},{"_id":"source/_posts/Gateway源码分析(二).md","hash":"01d8426a598f9afe47318c453899f38c064419e5","modified":1631001652016},{"_id":"source/_posts/gateway源码分析(一).md","hash":"8bd21c3178c99b0e344f180727bf7d0c08e4251d","modified":1631001652018},{"_id":"source/_posts/git常用指令记录.md","hash":"46d719b7e0b63a5ea618c5153298b5cfb28539e2","modified":1631001652018},{"_id":"source/_posts/hexo用法.md","hash":"84836d99bd6263e61130cc8e89744215163359a3","modified":1631001652019},{"_id":"source/_posts/kettle-8.2安装手册.md","hash":"3ead0f5bbcf15f9fa971e56545e9d53f3bcf1fe3","modified":1631014863771},{"_id":"source/_posts/kettle在项目中应用.md","hash":"5edfed173db3fdfc2920e8db71e1e68824801e66","modified":1631014882023},{"_id":"source/_posts/nginx原理分析.md","hash":"0bc5f5ccd36b0adde505d33f113d627f07364b14","modified":1631001652021},{"_id":"source/_posts/nginx搭建与部署.md","hash":"0e0238babac92148ef50ab970e1c0d87042566db","modified":1631001652022},{"_id":"source/_posts/nginx支持流媒体.md","hash":"7b6096c6331038e9dd92216db32f8fa6a7daa858","modified":1631001652022},{"_id":"source/_posts/wireshark抓包并使用.md","hash":"0a7962e1a00ffb6c72b04ddb09aaab238155a6b9","modified":1631001652023},{"_id":"source/_posts/书籍记录.md","hash":"5f81d91a096f06ea86cb4d41814945c72d379a5e","modified":1631001652023},{"_id":"source/_posts/使用Sublime3.md","hash":"fd240fc28cdc89eb06a8d36553eec1b23653b35a","modified":1631001652025},{"_id":"source/_posts/大数据总览.md","hash":"b9e886747e1e4f91961a8a5e2e0182e8a3cedfcc","modified":1631014808769},{"_id":"source/_posts/流媒体协议.md","hash":"86032458659524800b0ca077a0c11e5ff2fd3ab9","modified":1631001652025},{"_id":"source/_posts/流媒体基础知识点.md","hash":"b16698dd5896800f13567fd93fbd525dfa1d4e1f","modified":1631001652026},{"_id":"source/_posts/视频性能压测.md","hash":"6e10282952bb24ed703e57b8c0576e41d3eed3b1","modified":1631001652028},{"_id":"source/_posts/流媒体视频项目相关知识.mindmap","hash":"552990990bc9b777ac998a49fa9fd995ce6c636c","modified":1631001652027},{"_id":"source/_posts/视频总览.md","hash":"ce98057255eee9450f0a4b0810185d8fdbc41575","modified":1631001652028},{"_id":"source/_posts/选型视频网关.md","hash":"d3708ae1779c52df620300eae42c35b69e7fc7a3","modified":1631001652029},{"_id":"source/about/index.md","hash":"b002b837fb3662ec84182919fc91f76a0f16eead","modified":1518490086947},{"_id":"source/categories/index.md","hash":"915657e8d9939a311602e89a0e6754e23b32960a","modified":1518490086963},{"_id":"source/tags/index.md","hash":"a560f2b4232e3b50883b1f7074794283d20d8309","modified":1518490086963},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1518490086978},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1518490086978},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1518490086978},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"b1ec000babd42bb7ffd26f5ad8aac9b5bec79ae5","modified":1518490086978},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1518490086994},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1518490086994},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1518490086994},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1518490086994},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1518490086994},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1518490086994},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1518490086994},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1518490086994},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1518490086994},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1518490086994},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1518490086994},{"_id":"themes/next/languages/zh-Hans.yml","hash":"09da1d057c0b748b7932313b0dc280a942c942ec","modified":1518490086994},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1518490086994},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1518490086994},{"_id":"themes/next/layout/_layout.swig","hash":"7d91c9ca571067a3548d0f3c132b480cd3beb823","modified":1518490086994},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1518490087010},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1518490087010},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1518490087010},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1518490087010},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1518490087010},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1518490087010},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1518490087010},{"_id":"themes/next/scripts/merge-configs.js","hash":"5758f8f3f12d17bc80da65bb808a20b3a8aae186","modified":1518490087010},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1518490087010},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1518490087088},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1518490087088},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1518490087088},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518490087041},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1518490086994},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1518490086994},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1518490086994},{"_id":"themes/next/layout/_macro/post.swig","hash":"18365c242e07bd4fd622f9cf8abc8f74c24072b6","modified":1518490086994},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1518490086994},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1518490086994},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b9f9959225876fb56fb3fba96306d19396e704d4","modified":1518490086994},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1518490086994},{"_id":"themes/next/layout/_partials/comments.swig","hash":"de45e77e7d52cf317129b7d21415a3002b95b94e","modified":1518490086994},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c53913621ed89750b23d6e0a96d016fcec04faad","modified":1518490086994},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1518490086994},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1518490086994},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1518490086994},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1518490086994},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1518490086994},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1518490086994},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1518490086994},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1518490086994},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1518490087010},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1518490087010},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1518490087010},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1518490087010},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1518490087010},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1518490087010},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1518490087010},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1518490087010},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1518490087010},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1518490087010},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1518490087010},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1518490087010},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1518490087010},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1518490087010},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1518490087010},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1518490087010},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1518490087041},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1518490087041},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1518490087041},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1518490087041},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1518490087041},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1518490087041},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1518490087041},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1518490087041},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1518490087041},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1518490087041},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1518490087041},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1518490087041},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1518490087041},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1518490087041},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1518490087041},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1518490087041},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1518490087041},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1518490087041},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1518490087041},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518490086994},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518490086994},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518490087025},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518490087025},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518490087025},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518490087041},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518490087041},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1518490086994},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1518490086994},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1518490086994},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1518490086994},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1518490086994},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1518490086994},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1518490086994},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1518490086994},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1518490086994},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1518490086994},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1518490086994},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1518490086994},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1518490087010},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1518490087010},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1518490087010},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1518490087010},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1518490087010},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1518490087010},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1518490087010},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1518490087010},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"1b492d528a7d48216d4548011000fced2f4a538d","modified":1518490087010},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1518490087010},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1518490087010},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1518490087010},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1518490087010},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1518490087010},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1518490087025},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1518490087025},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1518490087025},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1518490087025},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1518490087041},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1518490087041},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1518490087041},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1518490087041},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1518490087041},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1518490087041},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1518490087041},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1518490087041},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1518490087041},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1518490087041},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1518490087041},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1518490087057},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1518490087057},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1518490087057},{"_id":"themes/next/source/js/src/utils.js","hash":"b7ddc240208d57596a67c78a04a11b0f0bdecc97","modified":1518490087057},{"_id":"themes/next/source/images/nginx/select.jpg","hash":"8cf07c22073c84aac08aba3247a4ec88520f17ef","modified":1631001652032},{"_id":"themes/next/source/images/nginx/worker.jpg","hash":"eb8dbbb08327669be5c56b413b020512300adde9","modified":1631001652033},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1518490087057},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1518490087057},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1518490087057},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1518490087072},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1518490087072},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1518490087072},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1518490087072},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1518490087072},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1518490087072},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1518490087072},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1518490087072},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1518490087072},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1518490087072},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1518490087072},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1518490087072},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1518490087072},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1518490087072},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1518490087072},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1518490087072},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1518490087088},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1518490087088},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1518490087088},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1518490087088},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1518490087088},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1518490087088},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1518490087088},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1518490087088},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1518490087088},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1518490087088},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1518490087088},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1518490087088},{"_id":"themes/next/source/images/avatar.jpg","hash":"543fa8fe3559d9c69617eff9b2a4f0a4cc77f4f6","modified":1518490087041},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1518490087072},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1518490087010},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1518490087025},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1518490087025},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1518490087025},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1518490087025},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1518490087025},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1518490087025},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1518490087025},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1518490087025},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1518490087025},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"f23ac53ab901c48859dd29eee6e386b60ff956ba","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"30561ed60fc64f3e4ce85143bdb55faa814743a6","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1518490087041},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1518490087057},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1518490087057},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1518490087057},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1518490087057},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1518490087072},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1518490087072},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1518490087072},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1518490087072},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1518490087072},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1518490087088},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1518490087088},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1518490087057},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1518490087072},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1518490087072},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1518490087088},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1518490087010},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"28a8737c090fbffd188d73a00b42e90b9ee57df2","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1518490087025},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1518490087025},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1518490087041},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1518490087041},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1518490087057},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1518490087057},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1518490087057},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1518490087057},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1518490087057},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1518490087057},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1518490087072},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1518490087072},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1518490087072},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1518490087057},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1518490087088},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1518490087072},{"_id":"public/about/index.html","hash":"0dffb90c2cebbae8dba356719d8d6568efb5364e","modified":1631086229426},{"_id":"public/tags/index.html","hash":"43fff3e99d7b9005b721e017c7d46ce5087cf889","modified":1631086229428},{"_id":"public/categories/index.html","hash":"7571ba26d1a20a9a95dd1895d62bed63fc723dcd","modified":1631086229429},{"_id":"public/2021/07/27/视频总览/index.html","hash":"a94d80da9d2cac8e323befa4a27aafbd3d1c5273","modified":1631086229429},{"_id":"public/archives/2017/index.html","hash":"69864489d8026683246e2c97bb675963ca7d9abc","modified":1631086229429},{"_id":"public/archives/2017/01/index.html","hash":"3469a228d39cbeb22c295e6cd650b5cf4958c005","modified":1631086229429},{"_id":"public/archives/2017/02/index.html","hash":"45de9d30a3eb9730b1b94ddcb21535439e43356b","modified":1631086229429},{"_id":"public/archives/2017/11/index.html","hash":"deaffbe18581b98c7821d5fea02bafb2a2fae06a","modified":1631086229429},{"_id":"public/archives/2017/12/index.html","hash":"3d893aca18f3ad97805d79d3eac3e8b890f50050","modified":1631086229429},{"_id":"public/archives/2018/index.html","hash":"66dfd2895e0e40fb6adf330e21cc2d7555287dd2","modified":1631086229429},{"_id":"public/archives/2018/01/index.html","hash":"072f88a9c80eb8ac79f962942fbca1e77bd7f96c","modified":1631086229429},{"_id":"public/archives/2021/page/2/index.html","hash":"f2912b253a116be2775432ccdfd3252426265c60","modified":1631086229430},{"_id":"public/categories/hexo总结/index.html","hash":"a92b90bb2423c415a44b4474aa1982e01d867207","modified":1631086229430},{"_id":"public/categories/git总结/index.html","hash":"6f71c8fe6b9d3822573c0049efb832cc3bb459d5","modified":1631086229430},{"_id":"public/categories/nginx总结/index.html","hash":"5529b35867fbc2311b40df02cf2dd7fdde12d10b","modified":1631086229430},{"_id":"public/categories/笔记/index.html","hash":"286388fab91d97dbaff754b707e3612b42cea6ab","modified":1631086229430},{"_id":"public/categories/sublime3使用笔记/index.html","hash":"dc808ab2d226eedf260a70d18e4377f09f1611b3","modified":1631086229430},{"_id":"public/categories/笔记/书籍/index.html","hash":"ccfc8c279633584077cbb6fda10c1feaf35d3c33","modified":1631086229430},{"_id":"public/tags/笔记/index.html","hash":"7a7d4cc3e09d89e135595beaec7b4238ee9a6c89","modified":1631086229430},{"_id":"public/tags/总结/index.html","hash":"0c16f3c59fa3f5bebf16fb43f83f099e98d498fe","modified":1631086229430},{"_id":"public/tags/书籍篇/index.html","hash":"f1756161df028a746d8cff2fce3955b776ea8261","modified":1631086229430},{"_id":"public/2021/07/26/流媒体基础知识点/index.html","hash":"f0e50a7876e93c67e66dd577ecacee6d7db487f6","modified":1631086229430},{"_id":"public/2021/07/25/nginx支持流媒体/index.html","hash":"0d0d1ee5145c582f7b187323aa4d5c8ad96f68c4","modified":1631086229431},{"_id":"public/2021/07/25/流媒体协议/index.html","hash":"0ae31e21f115f838774fb577695a1554c9bf7722","modified":1631086229431},{"_id":"public/2021/07/25/gateway源码分析(一)/index.html","hash":"81fd92c231b2f12106c1a244e412e350694d5c43","modified":1631086229431},{"_id":"public/2021/07/25/FFmpeg学习与使用/index.html","hash":"a286c94845856c66dfc5e1e129840a7d0abc4126","modified":1631086229431},{"_id":"public/2021/07/25/Gateway源码分析(二)/index.html","hash":"e37267d70417e2f7bbbd1746776910191425833e","modified":1631086229431},{"_id":"public/2021/07/24/wireshark抓包并使用/index.html","hash":"c0546073526c6fdc5d7a09f5cb49b93c64711f54","modified":1631086229431},{"_id":"public/2021/07/23/选型视频网关/index.html","hash":"0fda3296c9f55e655e1f2aab230ac5f848054d35","modified":1631086229431},{"_id":"public/2021/07/22/视频性能压测/index.html","hash":"00f3eae8d9f66dfde62a93af6008cbb76f667bd1","modified":1631086229431},{"_id":"public/2018/01/25/书籍记录/index.html","hash":"9131d0687d422cfea8e4022474a1b41ce16b7061","modified":1631086229431},{"_id":"public/2017/12/05/nginx原理分析/index.html","hash":"f0577c6d7c56505b301f077fa4d28e668c4ecfa8","modified":1631086229431},{"_id":"public/2017/11/30/nginx搭建与部署/index.html","hash":"72db8cffb9cb44e5c92f5fb0033504638936d8fe","modified":1631086229431},{"_id":"public/2017/02/23/git常用指令记录/index.html","hash":"0874af66cde8128554f153911d375617ca62b9c0","modified":1631086229432},{"_id":"public/2017/02/22/hexo用法/index.html","hash":"45095d5e789abf8ce48f5d0137de888d2236bfa1","modified":1631086229432},{"_id":"public/2017/01/22/使用Sublime3/index.html","hash":"ae8172a21171d98583df8b4172d2e3febe3aa616","modified":1631086229432},{"_id":"public/archives/index.html","hash":"8e7a78b7743eb79b780c7a7e53d78561b359b316","modified":1631086229432},{"_id":"public/archives/page/2/index.html","hash":"16ff4e4e830238db8e4d21f544dfe0257e459d8d","modified":1631086229432},{"_id":"public/archives/2021/index.html","hash":"4ef1a795f1c53dd601121e81a0bdd1da2c405801","modified":1631086229432},{"_id":"public/archives/2021/07/index.html","hash":"037bf9e25bd689d19771b0011ba09d4a21a89afd","modified":1631086229432},{"_id":"public/categories/视频/index.html","hash":"4c50bde9605ecc59fe00d64e1dff26dc64b2093e","modified":1631086229432},{"_id":"public/index.html","hash":"059ac91c84ae8c7b19f25d937503543a803c9f16","modified":1631086229432},{"_id":"public/page/2/index.html","hash":"97a02248554321a62b0d8feda4f165d2bdf86363","modified":1631086229432},{"_id":"public/tags/视频/index.html","hash":"6e274534c6e3ecf034136e09c07602cc2983d773","modified":1631086229433},{"_id":"public/2021/07/27/大数据总览/index.html","hash":"ed058182b374ce88a18e79f5c6d79644a6f889d1","modified":1631086229450},{"_id":"public/archives/2017/08/index.html","hash":"d879d24c46c466e698f7c59f722472b730548734","modified":1631086229450},{"_id":"public/archives/2021/07/page/2/index.html","hash":"96553ef43f13183e71512076efde6a8a6070b97f","modified":1631086229451},{"_id":"public/archives/2021/08/index.html","hash":"22a8ed845b7376a6ce572fa3a1cf2dcff0df7711","modified":1631086229451},{"_id":"public/categories/大数据/index.html","hash":"69bf65d47f941055d48f6a6f7123013a0e295836","modified":1631086229451},{"_id":"public/tags/大数据/index.html","hash":"098e6090dd9e7bfb2b569ac794aa419ef1dcd15c","modified":1631086229452},{"_id":"public/2021/08/20/kettle在项目中应用/index.html","hash":"7ad52a13fed117d6ae6efc30c85f8a513f9d72f2","modified":1631086229452},{"_id":"public/2021/08/19/Kettle自定义插件开发/index.html","hash":"e45d6f2e5777ee997f4bec39e56bd293fcd85af7","modified":1631086229452},{"_id":"public/2017/08/21/kettle-8.2安装手册/index.html","hash":"dc25d4d5e969379ca85d393e7e2ea7b271b4fd35","modified":1631086229452},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1631086229461},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1631086229461},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1631086229461},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1631086229461},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1631086229461},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1631086229462},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1631086229462},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1631086229462},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1631086229462},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1631086229462},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1631086229462},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1631086229462},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1631086229462},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1631086229462},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1631086229462},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1631086229463},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1631086229463},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1631086229463},{"_id":"public/images/nginx/select.jpg","hash":"8cf07c22073c84aac08aba3247a4ec88520f17ef","modified":1631086229463},{"_id":"public/images/nginx/worker.jpg","hash":"eb8dbbb08327669be5c56b413b020512300adde9","modified":1631086229463},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1631086229463},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1631086229463},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1631086229463},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1631086229463},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1631086229464},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1631086229464},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1631086229464},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1631086229464},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1631086229464},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1631086229464},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1631086229464},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1631086229465},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1631086229465},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1631086229465},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1631086229465},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1631086231170},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1631086231183},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1631086231315},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1631086231316},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1631086231316},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1631086231316},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1631086231316},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1631086231316},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1631086231316},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1631086231316},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1631086231317},{"_id":"public/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1631086231317},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1631086231317},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1631086231317},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1631086231317},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1631086231317},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1631086231317},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1631086231317},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1631086231317},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1631086231317},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1631086231318},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1631086231318},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1631086231318},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1631086231318},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1631086231318},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1631086231318},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1631086231318},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1631086231318},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1631086231318},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1631086231318},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1631086231318},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1631086231319},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1631086231319},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1631086231319},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1631086231319},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1631086231319},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1631086231319},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1631086231319},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1631086231319},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1631086231319},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1631086231319},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1631086231320},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1631086231320},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1631086231320},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1631086231320},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1631086231320},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1631086231320},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1631086231320},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1631086231320},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1631086231320},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1631086231320},{"_id":"public/css/main.css","hash":"ccf090c0aa1c6afff72647c706ac8dbc9cbc1116","modified":1631086231321},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1631086231323},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1631086231323},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1631086231323},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1631086231324},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1631086231324},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1631086231324},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1631086231324},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1631086231324},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1631086231325},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1631086231325},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1631086231325},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1631086231325},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1631086231325},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1631086231325},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1631086231326},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1631086231326},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1631086231326},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1631086231326},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1631086231326},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1631086231326},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1631086231327},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1631086231327},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1631086231327},{"_id":"public/images/avatar.jpg","hash":"543fa8fe3559d9c69617eff9b2a4f0a4cc77f4f6","modified":1631086231340},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1631086231386}],"Category":[{"name":"视频","_id":"cktb6mhr50004d0tvaohqu4e9"},{"name":"大数据","_id":"cktb6mhrc000ad0tv59r8iehf"},{"name":"git总结","_id":"cktb6mhrq000od0tvsr5oz6cu"},{"name":"hexo总结","_id":"cktb6mhrv000xd0tv1itc2uea"},{"name":"nginx总结","_id":"cktb6mhrz0016d0tvrmgqswta"},{"name":"笔记","_id":"cktb6mhsa001nd0tv64y9kgex"},{"name":"sublime3使用笔记","_id":"cktb6mhse001ud0tv88bxfus4"},{"name":"书籍","parent":"cktb6mhsa001nd0tv64y9kgex","_id":"cktb6mhsg0020d0tvbn9fthis"}],"Data":[],"Page":[{"title":"","date":"2017-10-22T12:04:46.000Z","_content":"### 罗海杰's 博客\n>从这里开始，建立自己学习的一点一滴\n\n### 个人经历\n#### 1. 实习\n  实习期间，从事JavaWeb研发工作，主要开发公司自主产品-智能客服Saas平台。\n#### 2. 工作\n  就职于一间主要为中国各地的气象部门研发相关气象领域一体化平台。从事JavaWeb研发,\n  \n  主要负责广州fast一体化平台等项目。\n\n### 关于我\n个人主要从事JavaWeb的工作,喜欢交流，喜欢接受新的事物。\n活动兴趣:\n* 看小说\n* 打篮球\n","source":"about/index.md","raw":"---\ntitle: \ndate: 2017-10-22 20:04:46\n---\n### 罗海杰's 博客\n>从这里开始，建立自己学习的一点一滴\n\n### 个人经历\n#### 1. 实习\n  实习期间，从事JavaWeb研发工作，主要开发公司自主产品-智能客服Saas平台。\n#### 2. 工作\n  就职于一间主要为中国各地的气象部门研发相关气象领域一体化平台。从事JavaWeb研发,\n  \n  主要负责广州fast一体化平台等项目。\n\n### 关于我\n个人主要从事JavaWeb的工作,喜欢交流，喜欢接受新的事物。\n活动兴趣:\n* 看小说\n* 打篮球\n","updated":"2018-02-13T02:48:06.947Z","path":"about/index.html","comments":1,"layout":"page","_id":"cktb6mhqz0001d0tvv0n0eua9","content":"<h3 id=\"罗海杰’s-博客\"><a href=\"#罗海杰’s-博客\" class=\"headerlink\" title=\"罗海杰’s 博客\"></a>罗海杰’s 博客</h3><blockquote>\n<p>从这里开始，建立自己学习的一点一滴</p>\n</blockquote>\n<h3 id=\"个人经历\"><a href=\"#个人经历\" class=\"headerlink\" title=\"个人经历\"></a>个人经历</h3><h4 id=\"1-实习\"><a href=\"#1-实习\" class=\"headerlink\" title=\"1. 实习\"></a>1. 实习</h4><p>  实习期间，从事JavaWeb研发工作，主要开发公司自主产品-智能客服Saas平台。</p>\n<h4 id=\"2-工作\"><a href=\"#2-工作\" class=\"headerlink\" title=\"2. 工作\"></a>2. 工作</h4><p>  就职于一间主要为中国各地的气象部门研发相关气象领域一体化平台。从事JavaWeb研发,</p>\n<p>  主要负责广州fast一体化平台等项目。</p>\n<h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h3><p>个人主要从事JavaWeb的工作,喜欢交流，喜欢接受新的事物。<br>活动兴趣:</p>\n<ul>\n<li>看小说</li>\n<li>打篮球</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"罗海杰’s-博客\"><a href=\"#罗海杰’s-博客\" class=\"headerlink\" title=\"罗海杰’s 博客\"></a>罗海杰’s 博客</h3><blockquote>\n<p>从这里开始，建立自己学习的一点一滴</p>\n</blockquote>\n<h3 id=\"个人经历\"><a href=\"#个人经历\" class=\"headerlink\" title=\"个人经历\"></a>个人经历</h3><h4 id=\"1-实习\"><a href=\"#1-实习\" class=\"headerlink\" title=\"1. 实习\"></a>1. 实习</h4><p>  实习期间，从事JavaWeb研发工作，主要开发公司自主产品-智能客服Saas平台。</p>\n<h4 id=\"2-工作\"><a href=\"#2-工作\" class=\"headerlink\" title=\"2. 工作\"></a>2. 工作</h4><p>  就职于一间主要为中国各地的气象部门研发相关气象领域一体化平台。从事JavaWeb研发,</p>\n<p>  主要负责广州fast一体化平台等项目。</p>\n<h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h3><p>个人主要从事JavaWeb的工作,喜欢交流，喜欢接受新的事物。<br>活动兴趣:</p>\n<ul>\n<li>看小说</li>\n<li>打篮球</li>\n</ul>\n"},{"title":"","date":"2017-10-22T08:13:17.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: \ndate: 2017-10-22 16:13:17\ntype: \"tags\"\n---\n","updated":"2018-02-13T02:48:06.963Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cktb6mhr30003d0tvndhi10g1","content":"","site":{"data":{}},"excerpt":"","more":""},{"date":"2017-10-22T03:16:38.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ndate: 2017-10-22 11:16:38\ntype: \"categories\"\n---\n","updated":"2018-02-13T02:48:06.963Z","path":"categories/index.html","title":"","comments":1,"layout":"page","_id":"cktb6mhr90007d0tvf8kgejs9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"FFmpeg学习与使用","date":"2021-07-25T03:16:39.000Z","_content":"\n\n## 目的\n\n本节主要记录下FFmpeg的使用方法以及如何用于视频项目上作一个简单的介绍\n\n## 简介\nFFmpeg是一款多媒体处理工具，内部包含了解码、编码、转码、解密的操作命令。正式由于FFmpeg太强大，目前大部分流媒体服务都会或多或小使用到FFmpeg的功能，所以我们有必要学习下FFmpeg的使用指令。\n\n## 常用命令以及解析\n\n### 主要成分：\n\n1. libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能；\n1. libavcodec：用于各种类型声音/图像编解码；\n1. libavutil：包含一些公共的工具函数；\n1. libswscale：用于视频场景比例缩放、色彩映射转换；\n1. libpostproc：用于后期效果处理；\n1. ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等；\n1. ffsever：一个 HTTP 多媒体即时广播串流服务器；\n1. ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示；\n\n\n### ffprobe\n例子\n```\nffprobe -rtsp_transport tcp -i \"rtsp://10.128.184.34:554/01?Short=1&Token=vEKOlIYbbCFseXHTjO3kbtEKZGZ4eyRExIkPU+yWWPA=&DomainCode=6a7c1a077a004406a344a1f260d86e41&UserId=6&\"\n```\n\n-rtsp_transport tcp/udp：选择以TCP还是UDP方式打开 \n·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。\n-show_format filename：展示格式\n-show_frames filename：显示帧信息\n\n### ffplay\n\n播放文件\n```\nffplay xxx.mp3 -ast 1 -loop 10\n```\n-loop num：循环次数\n\n-[ast|vst] 1：选择播放[音频|视频]\n\n### FFmpeg\n\nFFmpeg参数太多，以下是我举例了项目中实际用到的命令。\n\n```\nffmpeg -re -loglevel quiet {[decoder]}  {[tcp]} -i \"{[rtsp]}\"\n```\n·-re：代表按照帧率发送，尤其在作为推流工具的时候一定要加入该参数，否则ffmpeg会按照最高速率向流媒体服务器不停地发送数据\n\n-loglevel [debug|quiet|error]：日志级别记录\n\n·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。\n\n截图\n```\nffmpeg  -re -loglevel quiet {[tcp]} -i \\\"{[rtsp]}\\\" -an {[size]}  -vframes 1 -y -f image2 {[pattern]}.jpg\n```\n-an：视频静音\n\n·-y：覆盖已有文件。\n\n·-f fmt：指定格式（音频或者视频格式）。\n\n\n推流转码成h264\n```\nffmpeg -re -loglevel debug  -rtsp_transport tcp -i \"rtsp://10.128.184.34:554/01?Short=1&Token=yWSkzfBj71Yja67n9Y65SXDN97TCCOzBveNwOB53Lh8=&DomainCode=6a7c1a077a004406a344a1f260d86e41&UserId=6&\" -an -s 1280x720  -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp\n```\n\n-analyzeduration：设置码流分析时间\n\n-probesize：探测时长，这个设置的时间越长，视频打开得越慢\n\n·-vcodec [codec|smart_h264]：强制使用codec编解码方式（'copy'代表不进行重新编码）,smart_h264实现h264编码\n\n·-s size：指定分辨率（320×240）。\n\n\n```\n{[ffmpeg]} -loglevel error {[decoder]} -i {[rtsp]} {[copy]} {[encoder]} -an -threads 10 -tune zerolatency -crf {[crf]} -g 1 -r {[frameRate]} -preset ultrafast -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp\n```\n\n\ncrf num：\n为恒定质量（无比特率目标）和受限质量（最大比特率目标）模式设置质量/大小折衷。有效范围是0到63，数字越大表示质量越低，输出大小越小。仅在设置时使用；默认情况下，仅使用比特率目标\n\nthreads num：选定的编解码器实现支持多线程，则设置要使用的线程数。\n\ntune [zerolatency|fastdecode|psnr|ssim]：主要配合视频类型和视觉优化的参数。zerolatency零延迟，用在需要非常低的延迟的情况下，比如电视电话会议的编码；fastdecode可以快速解码的参数； psnr为提高psnr做了优化的参数；ssim为提高ssim做了优化的参数； \n\npreset type：预设类型。\n\nr num：帧率\n\ng size：设置GOP的大小\n\n\n## 项目中如何是使用\n\n由于ffmpeg太强大，在视频网关的项目中，我们经常会使用到ffmpeg。主要使用到有两方面，一个是截图，一个是将h265的视频数据格式转码成h264或者更改视频的分辨率功能等。为什么在项目中会使用到FFmpeg呢，其实像海康和大华第三方的厂商都会有对应的sdk,但是像截图之类的功能不能很好支持各种分辨率的截图，所以喔们考虑到使用FFmpeg来结合起来，以下是关于项目的流程图。\n\n![FFmpeg使用流程](/images/video/流程图.jpg)\n\n其实在项目上，我们一般会使用FFmpeg来进行截图，如上述说因为能够定制化配置截图得大小以及色差得调节等，而第三方厂商sdk一般都是默认尺寸，扩展性不高（如海康和大华）。而且，使用FFmpeg得扩展性会比较高。但是FFmpeg并不是万能，对于有一些私有的RTSP等可能也会存在失败的情况，所以在项目中如果FFmpeg截图不成功都会采用对应厂商sdk进行兜底截图，保证图片能够生成并且可用。\n\n## 参考\n\n1. [FFmpeg官网](http://www.ffmpeg.org/documentation.html)","source":"_posts/FFmpeg学习与使用.md","raw":"---\ntitle: FFmpeg学习与使用\ndate: 2021-07-25 11:16:39\ncategories: \n- 视频\ntags:\n- 视频\n---\n\n\n## 目的\n\n本节主要记录下FFmpeg的使用方法以及如何用于视频项目上作一个简单的介绍\n\n## 简介\nFFmpeg是一款多媒体处理工具，内部包含了解码、编码、转码、解密的操作命令。正式由于FFmpeg太强大，目前大部分流媒体服务都会或多或小使用到FFmpeg的功能，所以我们有必要学习下FFmpeg的使用指令。\n\n## 常用命令以及解析\n\n### 主要成分：\n\n1. libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能；\n1. libavcodec：用于各种类型声音/图像编解码；\n1. libavutil：包含一些公共的工具函数；\n1. libswscale：用于视频场景比例缩放、色彩映射转换；\n1. libpostproc：用于后期效果处理；\n1. ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等；\n1. ffsever：一个 HTTP 多媒体即时广播串流服务器；\n1. ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示；\n\n\n### ffprobe\n例子\n```\nffprobe -rtsp_transport tcp -i \"rtsp://10.128.184.34:554/01?Short=1&Token=vEKOlIYbbCFseXHTjO3kbtEKZGZ4eyRExIkPU+yWWPA=&DomainCode=6a7c1a077a004406a344a1f260d86e41&UserId=6&\"\n```\n\n-rtsp_transport tcp/udp：选择以TCP还是UDP方式打开 \n·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。\n-show_format filename：展示格式\n-show_frames filename：显示帧信息\n\n### ffplay\n\n播放文件\n```\nffplay xxx.mp3 -ast 1 -loop 10\n```\n-loop num：循环次数\n\n-[ast|vst] 1：选择播放[音频|视频]\n\n### FFmpeg\n\nFFmpeg参数太多，以下是我举例了项目中实际用到的命令。\n\n```\nffmpeg -re -loglevel quiet {[decoder]}  {[tcp]} -i \"{[rtsp]}\"\n```\n·-re：代表按照帧率发送，尤其在作为推流工具的时候一定要加入该参数，否则ffmpeg会按照最高速率向流媒体服务器不停地发送数据\n\n-loglevel [debug|quiet|error]：日志级别记录\n\n·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。\n\n截图\n```\nffmpeg  -re -loglevel quiet {[tcp]} -i \\\"{[rtsp]}\\\" -an {[size]}  -vframes 1 -y -f image2 {[pattern]}.jpg\n```\n-an：视频静音\n\n·-y：覆盖已有文件。\n\n·-f fmt：指定格式（音频或者视频格式）。\n\n\n推流转码成h264\n```\nffmpeg -re -loglevel debug  -rtsp_transport tcp -i \"rtsp://10.128.184.34:554/01?Short=1&Token=yWSkzfBj71Yja67n9Y65SXDN97TCCOzBveNwOB53Lh8=&DomainCode=6a7c1a077a004406a344a1f260d86e41&UserId=6&\" -an -s 1280x720  -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp\n```\n\n-analyzeduration：设置码流分析时间\n\n-probesize：探测时长，这个设置的时间越长，视频打开得越慢\n\n·-vcodec [codec|smart_h264]：强制使用codec编解码方式（'copy'代表不进行重新编码）,smart_h264实现h264编码\n\n·-s size：指定分辨率（320×240）。\n\n\n```\n{[ffmpeg]} -loglevel error {[decoder]} -i {[rtsp]} {[copy]} {[encoder]} -an -threads 10 -tune zerolatency -crf {[crf]} -g 1 -r {[frameRate]} -preset ultrafast -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp\n```\n\n\ncrf num：\n为恒定质量（无比特率目标）和受限质量（最大比特率目标）模式设置质量/大小折衷。有效范围是0到63，数字越大表示质量越低，输出大小越小。仅在设置时使用；默认情况下，仅使用比特率目标\n\nthreads num：选定的编解码器实现支持多线程，则设置要使用的线程数。\n\ntune [zerolatency|fastdecode|psnr|ssim]：主要配合视频类型和视觉优化的参数。zerolatency零延迟，用在需要非常低的延迟的情况下，比如电视电话会议的编码；fastdecode可以快速解码的参数； psnr为提高psnr做了优化的参数；ssim为提高ssim做了优化的参数； \n\npreset type：预设类型。\n\nr num：帧率\n\ng size：设置GOP的大小\n\n\n## 项目中如何是使用\n\n由于ffmpeg太强大，在视频网关的项目中，我们经常会使用到ffmpeg。主要使用到有两方面，一个是截图，一个是将h265的视频数据格式转码成h264或者更改视频的分辨率功能等。为什么在项目中会使用到FFmpeg呢，其实像海康和大华第三方的厂商都会有对应的sdk,但是像截图之类的功能不能很好支持各种分辨率的截图，所以喔们考虑到使用FFmpeg来结合起来，以下是关于项目的流程图。\n\n![FFmpeg使用流程](/images/video/流程图.jpg)\n\n其实在项目上，我们一般会使用FFmpeg来进行截图，如上述说因为能够定制化配置截图得大小以及色差得调节等，而第三方厂商sdk一般都是默认尺寸，扩展性不高（如海康和大华）。而且，使用FFmpeg得扩展性会比较高。但是FFmpeg并不是万能，对于有一些私有的RTSP等可能也会存在失败的情况，所以在项目中如果FFmpeg截图不成功都会采用对应厂商sdk进行兜底截图，保证图片能够生成并且可用。\n\n## 参考\n\n1. [FFmpeg官网](http://www.ffmpeg.org/documentation.html)","slug":"FFmpeg学习与使用","published":1,"updated":"2021-09-07T08:00:52.015Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhqu0000d0tvv4kg0b7s","content":"<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>本节主要记录下FFmpeg的使用方法以及如何用于视频项目上作一个简单的介绍</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>FFmpeg是一款多媒体处理工具，内部包含了解码、编码、转码、解密的操作命令。正式由于FFmpeg太强大，目前大部分流媒体服务都会或多或小使用到FFmpeg的功能，所以我们有必要学习下FFmpeg的使用指令。</p>\n<h2 id=\"常用命令以及解析\"><a href=\"#常用命令以及解析\" class=\"headerlink\" title=\"常用命令以及解析\"></a>常用命令以及解析</h2><h3 id=\"主要成分：\"><a href=\"#主要成分：\" class=\"headerlink\" title=\"主要成分：\"></a>主要成分：</h3><ol>\n<li>libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能；</li>\n<li>libavcodec：用于各种类型声音/图像编解码；</li>\n<li>libavutil：包含一些公共的工具函数；</li>\n<li>libswscale：用于视频场景比例缩放、色彩映射转换；</li>\n<li>libpostproc：用于后期效果处理；</li>\n<li>ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等；</li>\n<li>ffsever：一个 HTTP 多媒体即时广播串流服务器；</li>\n<li>ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示；</li>\n</ol>\n<h3 id=\"ffprobe\"><a href=\"#ffprobe\" class=\"headerlink\" title=\"ffprobe\"></a>ffprobe</h3><p>例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffprobe -rtsp_transport tcp -i &quot;rtsp://10.128.184.34:554/01?Short=1&amp;Token=vEKOlIYbbCFseXHTjO3kbtEKZGZ4eyRExIkPU+yWWPA=&amp;DomainCode=6a7c1a077a004406a344a1f260d86e41&amp;UserId=6&amp;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>-rtsp_transport tcp/udp：选择以TCP还是UDP方式打开<br>·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。<br>-show_format filename：展示格式<br>-show_frames filename：显示帧信息</p>\n<h3 id=\"ffplay\"><a href=\"#ffplay\" class=\"headerlink\" title=\"ffplay\"></a>ffplay</h3><p>播放文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffplay xxx.mp3 -ast 1 -loop 10</span><br></pre></td></tr></table></figure></p>\n<p>-loop num：循环次数</p>\n<p>-[ast|vst] 1：选择播放[音频|视频]</p>\n<h3 id=\"FFmpeg\"><a href=\"#FFmpeg\" class=\"headerlink\" title=\"FFmpeg\"></a>FFmpeg</h3><p>FFmpeg参数太多，以下是我举例了项目中实际用到的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffmpeg -re -loglevel quiet &#123;[decoder]&#125;  &#123;[tcp]&#125; -i &quot;&#123;[rtsp]&#125;&quot;</span><br></pre></td></tr></table></figure>\n<p>·-re：代表按照帧率发送，尤其在作为推流工具的时候一定要加入该参数，否则ffmpeg会按照最高速率向流媒体服务器不停地发送数据</p>\n<p>-loglevel [debug|quiet|error]：日志级别记录</p>\n<p>·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。</p>\n<p>截图<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffmpeg  -re -loglevel quiet &#123;[tcp]&#125; -i \\&quot;&#123;[rtsp]&#125;\\&quot; -an &#123;[size]&#125;  -vframes 1 -y -f image2 &#123;[pattern]&#125;.jpg</span><br></pre></td></tr></table></figure></p>\n<p>-an：视频静音</p>\n<p>·-y：覆盖已有文件。</p>\n<p>·-f fmt：指定格式（音频或者视频格式）。</p>\n<p>推流转码成h264<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffmpeg -re -loglevel debug  -rtsp_transport tcp -i &quot;rtsp://10.128.184.34:554/01?Short=1&amp;Token=yWSkzfBj71Yja67n9Y65SXDN97TCCOzBveNwOB53Lh8=&amp;DomainCode=6a7c1a077a004406a344a1f260d86e41&amp;UserId=6&amp;&quot; -an -s 1280x720  -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp</span><br></pre></td></tr></table></figure></p>\n<p>-analyzeduration：设置码流分析时间</p>\n<p>-probesize：探测时长，这个设置的时间越长，视频打开得越慢</p>\n<p>·-vcodec [codec|smart_h264]：强制使用codec编解码方式（’copy’代表不进行重新编码）,smart_h264实现h264编码</p>\n<p>·-s size：指定分辨率（320×240）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;[ffmpeg]&#125; -loglevel error &#123;[decoder]&#125; -i &#123;[rtsp]&#125; &#123;[copy]&#125; &#123;[encoder]&#125; -an -threads 10 -tune zerolatency -crf &#123;[crf]&#125; -g 1 -r &#123;[frameRate]&#125; -preset ultrafast -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp</span><br></pre></td></tr></table></figure>\n<p>crf num：<br>为恒定质量（无比特率目标）和受限质量（最大比特率目标）模式设置质量/大小折衷。有效范围是0到63，数字越大表示质量越低，输出大小越小。仅在设置时使用；默认情况下，仅使用比特率目标</p>\n<p>threads num：选定的编解码器实现支持多线程，则设置要使用的线程数。</p>\n<p>tune [zerolatency|fastdecode|psnr|ssim]：主要配合视频类型和视觉优化的参数。zerolatency零延迟，用在需要非常低的延迟的情况下，比如电视电话会议的编码；fastdecode可以快速解码的参数； psnr为提高psnr做了优化的参数；ssim为提高ssim做了优化的参数； </p>\n<p>preset type：预设类型。</p>\n<p>r num：帧率</p>\n<p>g size：设置GOP的大小</p>\n<h2 id=\"项目中如何是使用\"><a href=\"#项目中如何是使用\" class=\"headerlink\" title=\"项目中如何是使用\"></a>项目中如何是使用</h2><p>由于ffmpeg太强大，在视频网关的项目中，我们经常会使用到ffmpeg。主要使用到有两方面，一个是截图，一个是将h265的视频数据格式转码成h264或者更改视频的分辨率功能等。为什么在项目中会使用到FFmpeg呢，其实像海康和大华第三方的厂商都会有对应的sdk,但是像截图之类的功能不能很好支持各种分辨率的截图，所以喔们考虑到使用FFmpeg来结合起来，以下是关于项目的流程图。</p>\n<p><img src=\"/images/video/流程图.jpg\" alt=\"FFmpeg使用流程\"></p>\n<p>其实在项目上，我们一般会使用FFmpeg来进行截图，如上述说因为能够定制化配置截图得大小以及色差得调节等，而第三方厂商sdk一般都是默认尺寸，扩展性不高（如海康和大华）。而且，使用FFmpeg得扩展性会比较高。但是FFmpeg并不是万能，对于有一些私有的RTSP等可能也会存在失败的情况，所以在项目中如果FFmpeg截图不成功都会采用对应厂商sdk进行兜底截图，保证图片能够生成并且可用。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://www.ffmpeg.org/documentation.html\" target=\"_blank\" rel=\"noopener\">FFmpeg官网</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>本节主要记录下FFmpeg的使用方法以及如何用于视频项目上作一个简单的介绍</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>FFmpeg是一款多媒体处理工具，内部包含了解码、编码、转码、解密的操作命令。正式由于FFmpeg太强大，目前大部分流媒体服务都会或多或小使用到FFmpeg的功能，所以我们有必要学习下FFmpeg的使用指令。</p>\n<h2 id=\"常用命令以及解析\"><a href=\"#常用命令以及解析\" class=\"headerlink\" title=\"常用命令以及解析\"></a>常用命令以及解析</h2><h3 id=\"主要成分：\"><a href=\"#主要成分：\" class=\"headerlink\" title=\"主要成分：\"></a>主要成分：</h3><ol>\n<li>libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能；</li>\n<li>libavcodec：用于各种类型声音/图像编解码；</li>\n<li>libavutil：包含一些公共的工具函数；</li>\n<li>libswscale：用于视频场景比例缩放、色彩映射转换；</li>\n<li>libpostproc：用于后期效果处理；</li>\n<li>ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等；</li>\n<li>ffsever：一个 HTTP 多媒体即时广播串流服务器；</li>\n<li>ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示；</li>\n</ol>\n<h3 id=\"ffprobe\"><a href=\"#ffprobe\" class=\"headerlink\" title=\"ffprobe\"></a>ffprobe</h3><p>例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffprobe -rtsp_transport tcp -i &quot;rtsp://10.128.184.34:554/01?Short=1&amp;Token=vEKOlIYbbCFseXHTjO3kbtEKZGZ4eyRExIkPU+yWWPA=&amp;DomainCode=6a7c1a077a004406a344a1f260d86e41&amp;UserId=6&amp;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>-rtsp_transport tcp/udp：选择以TCP还是UDP方式打开<br>·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。<br>-show_format filename：展示格式<br>-show_frames filename：显示帧信息</p>\n<h3 id=\"ffplay\"><a href=\"#ffplay\" class=\"headerlink\" title=\"ffplay\"></a>ffplay</h3><p>播放文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffplay xxx.mp3 -ast 1 -loop 10</span><br></pre></td></tr></table></figure></p>\n<p>-loop num：循环次数</p>\n<p>-[ast|vst] 1：选择播放[音频|视频]</p>\n<h3 id=\"FFmpeg\"><a href=\"#FFmpeg\" class=\"headerlink\" title=\"FFmpeg\"></a>FFmpeg</h3><p>FFmpeg参数太多，以下是我举例了项目中实际用到的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffmpeg -re -loglevel quiet &#123;[decoder]&#125;  &#123;[tcp]&#125; -i &quot;&#123;[rtsp]&#125;&quot;</span><br></pre></td></tr></table></figure>\n<p>·-re：代表按照帧率发送，尤其在作为推流工具的时候一定要加入该参数，否则ffmpeg会按照最高速率向流媒体服务器不停地发送数据</p>\n<p>-loglevel [debug|quiet|error]：日志级别记录</p>\n<p>·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。</p>\n<p>截图<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffmpeg  -re -loglevel quiet &#123;[tcp]&#125; -i \\&quot;&#123;[rtsp]&#125;\\&quot; -an &#123;[size]&#125;  -vframes 1 -y -f image2 &#123;[pattern]&#125;.jpg</span><br></pre></td></tr></table></figure></p>\n<p>-an：视频静音</p>\n<p>·-y：覆盖已有文件。</p>\n<p>·-f fmt：指定格式（音频或者视频格式）。</p>\n<p>推流转码成h264<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ffmpeg -re -loglevel debug  -rtsp_transport tcp -i &quot;rtsp://10.128.184.34:554/01?Short=1&amp;Token=yWSkzfBj71Yja67n9Y65SXDN97TCCOzBveNwOB53Lh8=&amp;DomainCode=6a7c1a077a004406a344a1f260d86e41&amp;UserId=6&amp;&quot; -an -s 1280x720  -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp</span><br></pre></td></tr></table></figure></p>\n<p>-analyzeduration：设置码流分析时间</p>\n<p>-probesize：探测时长，这个设置的时间越长，视频打开得越慢</p>\n<p>·-vcodec [codec|smart_h264]：强制使用codec编解码方式（’copy’代表不进行重新编码）,smart_h264实现h264编码</p>\n<p>·-s size：指定分辨率（320×240）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;[ffmpeg]&#125; -loglevel error &#123;[decoder]&#125; -i &#123;[rtsp]&#125; &#123;[copy]&#125; &#123;[encoder]&#125; -an -threads 10 -tune zerolatency -crf &#123;[crf]&#125; -g 1 -r &#123;[frameRate]&#125; -preset ultrafast -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp</span><br></pre></td></tr></table></figure>\n<p>crf num：<br>为恒定质量（无比特率目标）和受限质量（最大比特率目标）模式设置质量/大小折衷。有效范围是0到63，数字越大表示质量越低，输出大小越小。仅在设置时使用；默认情况下，仅使用比特率目标</p>\n<p>threads num：选定的编解码器实现支持多线程，则设置要使用的线程数。</p>\n<p>tune [zerolatency|fastdecode|psnr|ssim]：主要配合视频类型和视觉优化的参数。zerolatency零延迟，用在需要非常低的延迟的情况下，比如电视电话会议的编码；fastdecode可以快速解码的参数； psnr为提高psnr做了优化的参数；ssim为提高ssim做了优化的参数； </p>\n<p>preset type：预设类型。</p>\n<p>r num：帧率</p>\n<p>g size：设置GOP的大小</p>\n<h2 id=\"项目中如何是使用\"><a href=\"#项目中如何是使用\" class=\"headerlink\" title=\"项目中如何是使用\"></a>项目中如何是使用</h2><p>由于ffmpeg太强大，在视频网关的项目中，我们经常会使用到ffmpeg。主要使用到有两方面，一个是截图，一个是将h265的视频数据格式转码成h264或者更改视频的分辨率功能等。为什么在项目中会使用到FFmpeg呢，其实像海康和大华第三方的厂商都会有对应的sdk,但是像截图之类的功能不能很好支持各种分辨率的截图，所以喔们考虑到使用FFmpeg来结合起来，以下是关于项目的流程图。</p>\n<p><img src=\"/images/video/流程图.jpg\" alt=\"FFmpeg使用流程\"></p>\n<p>其实在项目上，我们一般会使用FFmpeg来进行截图，如上述说因为能够定制化配置截图得大小以及色差得调节等，而第三方厂商sdk一般都是默认尺寸，扩展性不高（如海康和大华）。而且，使用FFmpeg得扩展性会比较高。但是FFmpeg并不是万能，对于有一些私有的RTSP等可能也会存在失败的情况，所以在项目中如果FFmpeg截图不成功都会采用对应厂商sdk进行兜底截图，保证图片能够生成并且可用。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://www.ffmpeg.org/documentation.html\" target=\"_blank\" rel=\"noopener\">FFmpeg官网</a></li>\n</ol>\n"},{"title":"kettle自定义插件开发","date":"2021-08-19T04:00:00.000Z","_content":"\n## 背景\n\n随着业务种类越来越多，kettle内置的插件也逐渐满足不了各种业务需求，因此需要通过kettle自定义插件的方式来满足业务的需求。\n\n## kettle插件\n\n开发kettle的业务插件也有一段时间，整理了一下大概也有十多个，大概如下：\n\n1. ESDB Output组件：Pipeline ESDB Output组件是一个Kettle的扩展插件，用于将数据输出到ESDB（自研发的地球科学数据库）中。\n\n1. ESDB 字段映射组件：要用于将数据字段名称映射成规范的编码。比如我们提供了一份《气象行业字段标准编码》的文件，里面包含了CIMISS字段、IDEA字段与标准编码的映射。那么在采集CIMISS数据，或者IDEA数据时，就可以通过该组件，将字段名转换为标准的编码，最后才通过ESDB Output插件，进行入库。\n每个行业（如气象、水利等），都可以整理一份字段标准编码CSV文件, 然后利用该组件进行自动匹配。规范字段编码的意义，在于对于不同的系统（比如不同省份的相似系统），数据查询的时候，可以通过统一的字段进行查询。比如地表温度，可以通过gst字段进行查询，无论该数据是来源于CIMISS，还是来源IDEA，还是来源于本地客户提供的数据。\n\n1. Pipeline 通用组件：pipeline 通用组件,为用户开发自定义转换的插件提供统一的界面展示和配置操作。\n\n1. Pipeline 通用组件-经纬度转换组件：pipeline 通用组件 经纬度转换组件,为用户提供经纬度转换坐标系（WGS84、GCJ_02、BD_09之间相互转换）的功能。\n\n1. Pipeline 通用组件-站点插值组件：pipeline 通用组件-插值组件,为用户提供站点插值成格点数据的功能。\n\n1. Pipeline 通用组件-idea（intgetdata2d接口）格点解析组件：格点解析组件,为用户提供解析intgetdata2d接口格点数据的功能\n1. Pipeline 列合并组件：为用户提供针对某个字段，多行数据合并成一行数据的功能，合并后的对象是一个List对象。\n1. Pipeline 多值映射组件：为用户提供值映射的功能。\n1. Pipeline 通用组件-idea-byte转格点：dea（qpe、qpf接口）byte转格点解析组件,为用户提供byte转格点数据的功能。由于qpe与qpf接口返回格点数据经过base64加密，因此该插件会先base64解密然后将byte转换成格点数据\n1. Pipeline 通用组件-格点双线性插值：为用户格点插值的功能（双线性插值）。\n1. Pipeline 通用组件-气象文件读取插件（网格文件）：\n1. Pipeline 通用组件-RestClientNew插件：提供读取rest接口的功能，主要是增加超时设置，kettle自带的restClient插值没有读取超时机制，如果接口卡住，连接会一直保持，所以新增本插件支持读取超时设置功能。\n1. Pipeline 通用组件-多行数据转JSON插件：多行数据转JSON插件,提供把一行或多行数据根据分组字段合并成json字符串。\n1. Pipeline 图片压缩插件：用于将图片进一步压缩的组件。\n1. Pipeline 图片生成gif动图插件：能够将多张图片生成多张含有时间信息的图片，并将生成后的图片聚合成一张gif动态图片。\n\n## 开发自定义插件\n\n本章简单记录我认为开发属于自己步骤插件的要点，要想完整搭建参考[自定义步骤插件开发](https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins)。\n\n### 四个接口\n\n开发前提条件首先要了解四个接口\n\n\n接口 | 基础类 | 主要职责\n---|---|---\nStepMetaInterface | BaseStepMeta | 1.存储step设置信息</br>2.验证step设置信息</br>3.序列化step设置信息</br>4.提供获取step类的方法\nStepDialogInterface |  org.pentaho.di.ui.trans.step.BaseStepDialog\t| step属性信息配置窗口\nStepInterface | BaseStep | 执行数据行的功能流程\nStepDataInterface | BaseStepData | 存储处理中的数据状态\n\n以下我结合代码尽量\n\n### 实现StepMetaInterface\n\n该接口主要是对步骤元数据信息进行操作。\n\n接口常用方法介绍：\n\n- setDefault()：每次创建新步骤并将该步骤配置分配或设置为合理的默认值时，都会调用此方法。创建新步骤时，PDI客户端（Spoon）将使用此处设置的值。这是确保将步设置初始化为非空值的好地方。在序列化和对话框填充中，空值的处理可能很麻烦，因此大多数PDI步骤实现对于所有步骤设置都坚持非空值。\n- clone()：在PDI客户端中复制步骤时，将调用此方法。它返回步骤元对象的深层副本。如果步骤配置存储在可修改的对象（例如列表或自定义帮助对象）中，则实现类必须创建正确的深层副本，这一点至关重要。\n\n- getXML()：每当步骤将其设置序列化为XML时，PDI都会调用此方法。在PDI客户端中保存转换时会调用它。该方法返回一个XML字符串，其中包含序列化的步骤设置。该字符串包含一系列XML标记，每个设置一个标记。辅助类org.pentaho.di.core.xml.XMLHandler构造XML字符串。\n- loadXML()：每当步骤从XML读取其设置时，PDI都会调用此方法。包含步骤设置的XML节点作为参数传入。再次，帮助程序类 org.pentaho.di.core.xml.XMLHandler从XML节点读取步骤设置。\n- saveRep()：每当步骤将其设置保存到PDI存储库时，PDI都会调用此方法。作为第一个参数传入的存储库对象提供了一组用于序列化步骤设置的方法。调用存储库序列化方法时，该步骤将传入的转换ID和步骤ID用作标识符。\n- readRep()：每当步骤从PDI存储库中读取其配置时，PDI都会调用此方法。使用存储库序列化方法时，参数中给出的步骤ID用作标识符。\n\n获取其他实例\n- public StepDialogInterface getDialog()\n- public StepInterface getStep()\n- public StepDataInterface getStepData()\n\n\nStepMetaInterface必须使用Step Java注释对实现的类进行注释。提供以下注释属性：\n属性|描述\n---|---\nid | 该步骤的全局唯一ID\nimage | 步骤的png图标图像的资源位置\nname | 该步骤的简短标签\ndescription\t| 该步骤的详细说明\ncategoryDescription |\t步骤的类别应显示在PDI步骤树中。例如输入，输出，变换等。\ni18nPackageName |如果i18nPackageName在批注属性中提供了该属性，则将name，description和categoryDe​​scription的值解释为 i18n相对于给定包中包含的消息束的键。</br>可以以扩展形式的i18n:<packagename>键来提供键，以指定与i18nPackageName属性中给定的包不同的包。\n\n### 实现StepDialogInterface\n\n该接口主要用于实现窗口的功能，以及设置属性信息的入口。打开步骤设置时候都会实例化dialog传入到StepMetaInterface接口对象并调用open()方法。\n\n接口常用方法介绍：\n\n- open()：仅在确认或取消对话框后，此方法才返回。\n\n### 实现StepInterface\n\nStepInterface当转换运行时，类实现负责实际的行处理。\n\n![StepInterface](/images/bdata/kettle流程.png)\n\n接口常用方法介绍：\n\n- init()：当转换准备开始执行时，将调用该方法初始化资源。\n\n- processRow()：转换开始执行该方法，读取上一步骤传递下来的行数据，直到没有行就调用setOutputDone()返回false。\n\n- dispose()：转换完成后，PDI将调用该方法取消init()分配的资源。\n\n### 实现StepDataInterface\n\n类实现StepInterface不会在其任何字段中存储处理状态。取而代之的StepDataInterface是，使用一个附加的类实现来存储处理状态，包括状态标志，索引，缓存表，数据库连接，文件句柄等\n\n## 部署步骤插件\n\n1. 创建一个包含您的插件类和资源的JAR文件\n1. 创建一个新文件夹，为其命名，然后将您的JAR文件放在该文件夹中\n1. 将刚创建的插件文件夹放置在特定位置，以供PDI查找。根据您使用PDI的方式，您需要按如下方式将插件文件夹复制到一个或多个位置。\n    - 部署到PDI客户端（Spoon）或Carte：\n    - 将plugin文件夹复制到以下位置： design-tools / data-integration / plugins / steps。\n    - 重新启动PDI客户端。重新启动PDI客户端后，可以使用新的作业条目。\n\n## 参考\n\n[Kettle开发中心](https://help.pentaho.com/Documentation/8.3/Developer_center/Embed_and_extend_PDI_functionality)\n\n[扩展Pentaho数据集成](https://help.pentaho.com/Documentation/8.3/Developer_center/Extend_Pentaho_Data_Integration)\n\n[自定义步骤插件开发](https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins)","source":"_posts/Kettle自定义插件开发.md","raw":"---\ntitle: kettle自定义插件开发\ndate: 2021-08-19 12:00:00\ncategories: \n- 大数据\ntags:\n- 大数据\n---\n\n## 背景\n\n随着业务种类越来越多，kettle内置的插件也逐渐满足不了各种业务需求，因此需要通过kettle自定义插件的方式来满足业务的需求。\n\n## kettle插件\n\n开发kettle的业务插件也有一段时间，整理了一下大概也有十多个，大概如下：\n\n1. ESDB Output组件：Pipeline ESDB Output组件是一个Kettle的扩展插件，用于将数据输出到ESDB（自研发的地球科学数据库）中。\n\n1. ESDB 字段映射组件：要用于将数据字段名称映射成规范的编码。比如我们提供了一份《气象行业字段标准编码》的文件，里面包含了CIMISS字段、IDEA字段与标准编码的映射。那么在采集CIMISS数据，或者IDEA数据时，就可以通过该组件，将字段名转换为标准的编码，最后才通过ESDB Output插件，进行入库。\n每个行业（如气象、水利等），都可以整理一份字段标准编码CSV文件, 然后利用该组件进行自动匹配。规范字段编码的意义，在于对于不同的系统（比如不同省份的相似系统），数据查询的时候，可以通过统一的字段进行查询。比如地表温度，可以通过gst字段进行查询，无论该数据是来源于CIMISS，还是来源IDEA，还是来源于本地客户提供的数据。\n\n1. Pipeline 通用组件：pipeline 通用组件,为用户开发自定义转换的插件提供统一的界面展示和配置操作。\n\n1. Pipeline 通用组件-经纬度转换组件：pipeline 通用组件 经纬度转换组件,为用户提供经纬度转换坐标系（WGS84、GCJ_02、BD_09之间相互转换）的功能。\n\n1. Pipeline 通用组件-站点插值组件：pipeline 通用组件-插值组件,为用户提供站点插值成格点数据的功能。\n\n1. Pipeline 通用组件-idea（intgetdata2d接口）格点解析组件：格点解析组件,为用户提供解析intgetdata2d接口格点数据的功能\n1. Pipeline 列合并组件：为用户提供针对某个字段，多行数据合并成一行数据的功能，合并后的对象是一个List对象。\n1. Pipeline 多值映射组件：为用户提供值映射的功能。\n1. Pipeline 通用组件-idea-byte转格点：dea（qpe、qpf接口）byte转格点解析组件,为用户提供byte转格点数据的功能。由于qpe与qpf接口返回格点数据经过base64加密，因此该插件会先base64解密然后将byte转换成格点数据\n1. Pipeline 通用组件-格点双线性插值：为用户格点插值的功能（双线性插值）。\n1. Pipeline 通用组件-气象文件读取插件（网格文件）：\n1. Pipeline 通用组件-RestClientNew插件：提供读取rest接口的功能，主要是增加超时设置，kettle自带的restClient插值没有读取超时机制，如果接口卡住，连接会一直保持，所以新增本插件支持读取超时设置功能。\n1. Pipeline 通用组件-多行数据转JSON插件：多行数据转JSON插件,提供把一行或多行数据根据分组字段合并成json字符串。\n1. Pipeline 图片压缩插件：用于将图片进一步压缩的组件。\n1. Pipeline 图片生成gif动图插件：能够将多张图片生成多张含有时间信息的图片，并将生成后的图片聚合成一张gif动态图片。\n\n## 开发自定义插件\n\n本章简单记录我认为开发属于自己步骤插件的要点，要想完整搭建参考[自定义步骤插件开发](https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins)。\n\n### 四个接口\n\n开发前提条件首先要了解四个接口\n\n\n接口 | 基础类 | 主要职责\n---|---|---\nStepMetaInterface | BaseStepMeta | 1.存储step设置信息</br>2.验证step设置信息</br>3.序列化step设置信息</br>4.提供获取step类的方法\nStepDialogInterface |  org.pentaho.di.ui.trans.step.BaseStepDialog\t| step属性信息配置窗口\nStepInterface | BaseStep | 执行数据行的功能流程\nStepDataInterface | BaseStepData | 存储处理中的数据状态\n\n以下我结合代码尽量\n\n### 实现StepMetaInterface\n\n该接口主要是对步骤元数据信息进行操作。\n\n接口常用方法介绍：\n\n- setDefault()：每次创建新步骤并将该步骤配置分配或设置为合理的默认值时，都会调用此方法。创建新步骤时，PDI客户端（Spoon）将使用此处设置的值。这是确保将步设置初始化为非空值的好地方。在序列化和对话框填充中，空值的处理可能很麻烦，因此大多数PDI步骤实现对于所有步骤设置都坚持非空值。\n- clone()：在PDI客户端中复制步骤时，将调用此方法。它返回步骤元对象的深层副本。如果步骤配置存储在可修改的对象（例如列表或自定义帮助对象）中，则实现类必须创建正确的深层副本，这一点至关重要。\n\n- getXML()：每当步骤将其设置序列化为XML时，PDI都会调用此方法。在PDI客户端中保存转换时会调用它。该方法返回一个XML字符串，其中包含序列化的步骤设置。该字符串包含一系列XML标记，每个设置一个标记。辅助类org.pentaho.di.core.xml.XMLHandler构造XML字符串。\n- loadXML()：每当步骤从XML读取其设置时，PDI都会调用此方法。包含步骤设置的XML节点作为参数传入。再次，帮助程序类 org.pentaho.di.core.xml.XMLHandler从XML节点读取步骤设置。\n- saveRep()：每当步骤将其设置保存到PDI存储库时，PDI都会调用此方法。作为第一个参数传入的存储库对象提供了一组用于序列化步骤设置的方法。调用存储库序列化方法时，该步骤将传入的转换ID和步骤ID用作标识符。\n- readRep()：每当步骤从PDI存储库中读取其配置时，PDI都会调用此方法。使用存储库序列化方法时，参数中给出的步骤ID用作标识符。\n\n获取其他实例\n- public StepDialogInterface getDialog()\n- public StepInterface getStep()\n- public StepDataInterface getStepData()\n\n\nStepMetaInterface必须使用Step Java注释对实现的类进行注释。提供以下注释属性：\n属性|描述\n---|---\nid | 该步骤的全局唯一ID\nimage | 步骤的png图标图像的资源位置\nname | 该步骤的简短标签\ndescription\t| 该步骤的详细说明\ncategoryDescription |\t步骤的类别应显示在PDI步骤树中。例如输入，输出，变换等。\ni18nPackageName |如果i18nPackageName在批注属性中提供了该属性，则将name，description和categoryDe​​scription的值解释为 i18n相对于给定包中包含的消息束的键。</br>可以以扩展形式的i18n:<packagename>键来提供键，以指定与i18nPackageName属性中给定的包不同的包。\n\n### 实现StepDialogInterface\n\n该接口主要用于实现窗口的功能，以及设置属性信息的入口。打开步骤设置时候都会实例化dialog传入到StepMetaInterface接口对象并调用open()方法。\n\n接口常用方法介绍：\n\n- open()：仅在确认或取消对话框后，此方法才返回。\n\n### 实现StepInterface\n\nStepInterface当转换运行时，类实现负责实际的行处理。\n\n![StepInterface](/images/bdata/kettle流程.png)\n\n接口常用方法介绍：\n\n- init()：当转换准备开始执行时，将调用该方法初始化资源。\n\n- processRow()：转换开始执行该方法，读取上一步骤传递下来的行数据，直到没有行就调用setOutputDone()返回false。\n\n- dispose()：转换完成后，PDI将调用该方法取消init()分配的资源。\n\n### 实现StepDataInterface\n\n类实现StepInterface不会在其任何字段中存储处理状态。取而代之的StepDataInterface是，使用一个附加的类实现来存储处理状态，包括状态标志，索引，缓存表，数据库连接，文件句柄等\n\n## 部署步骤插件\n\n1. 创建一个包含您的插件类和资源的JAR文件\n1. 创建一个新文件夹，为其命名，然后将您的JAR文件放在该文件夹中\n1. 将刚创建的插件文件夹放置在特定位置，以供PDI查找。根据您使用PDI的方式，您需要按如下方式将插件文件夹复制到一个或多个位置。\n    - 部署到PDI客户端（Spoon）或Carte：\n    - 将plugin文件夹复制到以下位置： design-tools / data-integration / plugins / steps。\n    - 重新启动PDI客户端。重新启动PDI客户端后，可以使用新的作业条目。\n\n## 参考\n\n[Kettle开发中心](https://help.pentaho.com/Documentation/8.3/Developer_center/Embed_and_extend_PDI_functionality)\n\n[扩展Pentaho数据集成](https://help.pentaho.com/Documentation/8.3/Developer_center/Extend_Pentaho_Data_Integration)\n\n[自定义步骤插件开发](https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins)","slug":"Kettle自定义插件开发","published":1,"updated":"2021-09-07T11:41:38.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhr10002d0tvjt7ixrtj","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着业务种类越来越多，kettle内置的插件也逐渐满足不了各种业务需求，因此需要通过kettle自定义插件的方式来满足业务的需求。</p>\n<h2 id=\"kettle插件\"><a href=\"#kettle插件\" class=\"headerlink\" title=\"kettle插件\"></a>kettle插件</h2><p>开发kettle的业务插件也有一段时间，整理了一下大概也有十多个，大概如下：</p>\n<ol>\n<li><p>ESDB Output组件：Pipeline ESDB Output组件是一个Kettle的扩展插件，用于将数据输出到ESDB（自研发的地球科学数据库）中。</p>\n</li>\n<li><p>ESDB 字段映射组件：要用于将数据字段名称映射成规范的编码。比如我们提供了一份《气象行业字段标准编码》的文件，里面包含了CIMISS字段、IDEA字段与标准编码的映射。那么在采集CIMISS数据，或者IDEA数据时，就可以通过该组件，将字段名转换为标准的编码，最后才通过ESDB Output插件，进行入库。<br>每个行业（如气象、水利等），都可以整理一份字段标准编码CSV文件, 然后利用该组件进行自动匹配。规范字段编码的意义，在于对于不同的系统（比如不同省份的相似系统），数据查询的时候，可以通过统一的字段进行查询。比如地表温度，可以通过gst字段进行查询，无论该数据是来源于CIMISS，还是来源IDEA，还是来源于本地客户提供的数据。</p>\n</li>\n<li><p>Pipeline 通用组件：pipeline 通用组件,为用户开发自定义转换的插件提供统一的界面展示和配置操作。</p>\n</li>\n<li><p>Pipeline 通用组件-经纬度转换组件：pipeline 通用组件 经纬度转换组件,为用户提供经纬度转换坐标系（WGS84、GCJ_02、BD_09之间相互转换）的功能。</p>\n</li>\n<li><p>Pipeline 通用组件-站点插值组件：pipeline 通用组件-插值组件,为用户提供站点插值成格点数据的功能。</p>\n</li>\n<li><p>Pipeline 通用组件-idea（intgetdata2d接口）格点解析组件：格点解析组件,为用户提供解析intgetdata2d接口格点数据的功能</p>\n</li>\n<li>Pipeline 列合并组件：为用户提供针对某个字段，多行数据合并成一行数据的功能，合并后的对象是一个List对象。</li>\n<li>Pipeline 多值映射组件：为用户提供值映射的功能。</li>\n<li>Pipeline 通用组件-idea-byte转格点：dea（qpe、qpf接口）byte转格点解析组件,为用户提供byte转格点数据的功能。由于qpe与qpf接口返回格点数据经过base64加密，因此该插件会先base64解密然后将byte转换成格点数据</li>\n<li>Pipeline 通用组件-格点双线性插值：为用户格点插值的功能（双线性插值）。</li>\n<li>Pipeline 通用组件-气象文件读取插件（网格文件）：</li>\n<li>Pipeline 通用组件-RestClientNew插件：提供读取rest接口的功能，主要是增加超时设置，kettle自带的restClient插值没有读取超时机制，如果接口卡住，连接会一直保持，所以新增本插件支持读取超时设置功能。</li>\n<li>Pipeline 通用组件-多行数据转JSON插件：多行数据转JSON插件,提供把一行或多行数据根据分组字段合并成json字符串。</li>\n<li>Pipeline 图片压缩插件：用于将图片进一步压缩的组件。</li>\n<li>Pipeline 图片生成gif动图插件：能够将多张图片生成多张含有时间信息的图片，并将生成后的图片聚合成一张gif动态图片。</li>\n</ol>\n<h2 id=\"开发自定义插件\"><a href=\"#开发自定义插件\" class=\"headerlink\" title=\"开发自定义插件\"></a>开发自定义插件</h2><p>本章简单记录我认为开发属于自己步骤插件的要点，要想完整搭建参考<a href=\"https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins\" target=\"_blank\" rel=\"noopener\">自定义步骤插件开发</a>。</p>\n<h3 id=\"四个接口\"><a href=\"#四个接口\" class=\"headerlink\" title=\"四个接口\"></a>四个接口</h3><p>开发前提条件首先要了解四个接口</p>\n<table>\n<thead>\n<tr>\n<th>接口</th>\n<th>基础类</th>\n<th>主要职责</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>StepMetaInterface</td>\n<td>BaseStepMeta</td>\n<td>1.存储step设置信息<br>2.验证step设置信息<br>3.序列化step设置信息<br>4.提供获取step类的方法</td>\n</tr>\n<tr>\n<td>StepDialogInterface</td>\n<td>org.pentaho.di.ui.trans.step.BaseStepDialog</td>\n<td>step属性信息配置窗口</td>\n</tr>\n<tr>\n<td>StepInterface</td>\n<td>BaseStep</td>\n<td>执行数据行的功能流程</td>\n</tr>\n<tr>\n<td>StepDataInterface</td>\n<td>BaseStepData</td>\n<td>存储处理中的数据状态</td>\n</tr>\n</tbody>\n</table>\n<p>以下我结合代码尽量</p>\n<h3 id=\"实现StepMetaInterface\"><a href=\"#实现StepMetaInterface\" class=\"headerlink\" title=\"实现StepMetaInterface\"></a>实现StepMetaInterface</h3><p>该接口主要是对步骤元数据信息进行操作。</p>\n<p>接口常用方法介绍：</p>\n<ul>\n<li>setDefault()：每次创建新步骤并将该步骤配置分配或设置为合理的默认值时，都会调用此方法。创建新步骤时，PDI客户端（Spoon）将使用此处设置的值。这是确保将步设置初始化为非空值的好地方。在序列化和对话框填充中，空值的处理可能很麻烦，因此大多数PDI步骤实现对于所有步骤设置都坚持非空值。</li>\n<li><p>clone()：在PDI客户端中复制步骤时，将调用此方法。它返回步骤元对象的深层副本。如果步骤配置存储在可修改的对象（例如列表或自定义帮助对象）中，则实现类必须创建正确的深层副本，这一点至关重要。</p>\n</li>\n<li><p>getXML()：每当步骤将其设置序列化为XML时，PDI都会调用此方法。在PDI客户端中保存转换时会调用它。该方法返回一个XML字符串，其中包含序列化的步骤设置。该字符串包含一系列XML标记，每个设置一个标记。辅助类org.pentaho.di.core.xml.XMLHandler构造XML字符串。</p>\n</li>\n<li>loadXML()：每当步骤从XML读取其设置时，PDI都会调用此方法。包含步骤设置的XML节点作为参数传入。再次，帮助程序类 org.pentaho.di.core.xml.XMLHandler从XML节点读取步骤设置。</li>\n<li>saveRep()：每当步骤将其设置保存到PDI存储库时，PDI都会调用此方法。作为第一个参数传入的存储库对象提供了一组用于序列化步骤设置的方法。调用存储库序列化方法时，该步骤将传入的转换ID和步骤ID用作标识符。</li>\n<li>readRep()：每当步骤从PDI存储库中读取其配置时，PDI都会调用此方法。使用存储库序列化方法时，参数中给出的步骤ID用作标识符。</li>\n</ul>\n<p>获取其他实例</p>\n<ul>\n<li>public StepDialogInterface getDialog()</li>\n<li>public StepInterface getStep()</li>\n<li>public StepDataInterface getStepData()</li>\n</ul>\n<p>StepMetaInterface必须使用Step Java注释对实现的类进行注释。提供以下注释属性：<br>属性|描述<br>—|—<br>id | 该步骤的全局唯一ID<br>image | 步骤的png图标图像的资源位置<br>name | 该步骤的简短标签<br>description    | 该步骤的详细说明<br>categoryDescription |    步骤的类别应显示在PDI步骤树中。例如输入，输出，变换等。<br>i18nPackageName |如果i18nPackageName在批注属性中提供了该属性，则将name，description和categoryDe​​scription的值解释为 i18n相对于给定包中包含的消息束的键。<br>可以以扩展形式的i18n:<packagename>键来提供键，以指定与i18nPackageName属性中给定的包不同的包。</packagename></p>\n<h3 id=\"实现StepDialogInterface\"><a href=\"#实现StepDialogInterface\" class=\"headerlink\" title=\"实现StepDialogInterface\"></a>实现StepDialogInterface</h3><p>该接口主要用于实现窗口的功能，以及设置属性信息的入口。打开步骤设置时候都会实例化dialog传入到StepMetaInterface接口对象并调用open()方法。</p>\n<p>接口常用方法介绍：</p>\n<ul>\n<li>open()：仅在确认或取消对话框后，此方法才返回。</li>\n</ul>\n<h3 id=\"实现StepInterface\"><a href=\"#实现StepInterface\" class=\"headerlink\" title=\"实现StepInterface\"></a>实现StepInterface</h3><p>StepInterface当转换运行时，类实现负责实际的行处理。</p>\n<p><img src=\"/images/bdata/kettle流程.png\" alt=\"StepInterface\"></p>\n<p>接口常用方法介绍：</p>\n<ul>\n<li><p>init()：当转换准备开始执行时，将调用该方法初始化资源。</p>\n</li>\n<li><p>processRow()：转换开始执行该方法，读取上一步骤传递下来的行数据，直到没有行就调用setOutputDone()返回false。</p>\n</li>\n<li><p>dispose()：转换完成后，PDI将调用该方法取消init()分配的资源。</p>\n</li>\n</ul>\n<h3 id=\"实现StepDataInterface\"><a href=\"#实现StepDataInterface\" class=\"headerlink\" title=\"实现StepDataInterface\"></a>实现StepDataInterface</h3><p>类实现StepInterface不会在其任何字段中存储处理状态。取而代之的StepDataInterface是，使用一个附加的类实现来存储处理状态，包括状态标志，索引，缓存表，数据库连接，文件句柄等</p>\n<h2 id=\"部署步骤插件\"><a href=\"#部署步骤插件\" class=\"headerlink\" title=\"部署步骤插件\"></a>部署步骤插件</h2><ol>\n<li>创建一个包含您的插件类和资源的JAR文件</li>\n<li>创建一个新文件夹，为其命名，然后将您的JAR文件放在该文件夹中</li>\n<li>将刚创建的插件文件夹放置在特定位置，以供PDI查找。根据您使用PDI的方式，您需要按如下方式将插件文件夹复制到一个或多个位置。<ul>\n<li>部署到PDI客户端（Spoon）或Carte：</li>\n<li>将plugin文件夹复制到以下位置： design-tools / data-integration / plugins / steps。</li>\n<li>重新启动PDI客户端。重新启动PDI客户端后，可以使用新的作业条目。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://help.pentaho.com/Documentation/8.3/Developer_center/Embed_and_extend_PDI_functionality\" target=\"_blank\" rel=\"noopener\">Kettle开发中心</a></p>\n<p><a href=\"https://help.pentaho.com/Documentation/8.3/Developer_center/Extend_Pentaho_Data_Integration\" target=\"_blank\" rel=\"noopener\">扩展Pentaho数据集成</a></p>\n<p><a href=\"https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins\" target=\"_blank\" rel=\"noopener\">自定义步骤插件开发</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着业务种类越来越多，kettle内置的插件也逐渐满足不了各种业务需求，因此需要通过kettle自定义插件的方式来满足业务的需求。</p>\n<h2 id=\"kettle插件\"><a href=\"#kettle插件\" class=\"headerlink\" title=\"kettle插件\"></a>kettle插件</h2><p>开发kettle的业务插件也有一段时间，整理了一下大概也有十多个，大概如下：</p>\n<ol>\n<li><p>ESDB Output组件：Pipeline ESDB Output组件是一个Kettle的扩展插件，用于将数据输出到ESDB（自研发的地球科学数据库）中。</p>\n</li>\n<li><p>ESDB 字段映射组件：要用于将数据字段名称映射成规范的编码。比如我们提供了一份《气象行业字段标准编码》的文件，里面包含了CIMISS字段、IDEA字段与标准编码的映射。那么在采集CIMISS数据，或者IDEA数据时，就可以通过该组件，将字段名转换为标准的编码，最后才通过ESDB Output插件，进行入库。<br>每个行业（如气象、水利等），都可以整理一份字段标准编码CSV文件, 然后利用该组件进行自动匹配。规范字段编码的意义，在于对于不同的系统（比如不同省份的相似系统），数据查询的时候，可以通过统一的字段进行查询。比如地表温度，可以通过gst字段进行查询，无论该数据是来源于CIMISS，还是来源IDEA，还是来源于本地客户提供的数据。</p>\n</li>\n<li><p>Pipeline 通用组件：pipeline 通用组件,为用户开发自定义转换的插件提供统一的界面展示和配置操作。</p>\n</li>\n<li><p>Pipeline 通用组件-经纬度转换组件：pipeline 通用组件 经纬度转换组件,为用户提供经纬度转换坐标系（WGS84、GCJ_02、BD_09之间相互转换）的功能。</p>\n</li>\n<li><p>Pipeline 通用组件-站点插值组件：pipeline 通用组件-插值组件,为用户提供站点插值成格点数据的功能。</p>\n</li>\n<li><p>Pipeline 通用组件-idea（intgetdata2d接口）格点解析组件：格点解析组件,为用户提供解析intgetdata2d接口格点数据的功能</p>\n</li>\n<li>Pipeline 列合并组件：为用户提供针对某个字段，多行数据合并成一行数据的功能，合并后的对象是一个List对象。</li>\n<li>Pipeline 多值映射组件：为用户提供值映射的功能。</li>\n<li>Pipeline 通用组件-idea-byte转格点：dea（qpe、qpf接口）byte转格点解析组件,为用户提供byte转格点数据的功能。由于qpe与qpf接口返回格点数据经过base64加密，因此该插件会先base64解密然后将byte转换成格点数据</li>\n<li>Pipeline 通用组件-格点双线性插值：为用户格点插值的功能（双线性插值）。</li>\n<li>Pipeline 通用组件-气象文件读取插件（网格文件）：</li>\n<li>Pipeline 通用组件-RestClientNew插件：提供读取rest接口的功能，主要是增加超时设置，kettle自带的restClient插值没有读取超时机制，如果接口卡住，连接会一直保持，所以新增本插件支持读取超时设置功能。</li>\n<li>Pipeline 通用组件-多行数据转JSON插件：多行数据转JSON插件,提供把一行或多行数据根据分组字段合并成json字符串。</li>\n<li>Pipeline 图片压缩插件：用于将图片进一步压缩的组件。</li>\n<li>Pipeline 图片生成gif动图插件：能够将多张图片生成多张含有时间信息的图片，并将生成后的图片聚合成一张gif动态图片。</li>\n</ol>\n<h2 id=\"开发自定义插件\"><a href=\"#开发自定义插件\" class=\"headerlink\" title=\"开发自定义插件\"></a>开发自定义插件</h2><p>本章简单记录我认为开发属于自己步骤插件的要点，要想完整搭建参考<a href=\"https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins\" target=\"_blank\" rel=\"noopener\">自定义步骤插件开发</a>。</p>\n<h3 id=\"四个接口\"><a href=\"#四个接口\" class=\"headerlink\" title=\"四个接口\"></a>四个接口</h3><p>开发前提条件首先要了解四个接口</p>\n<table>\n<thead>\n<tr>\n<th>接口</th>\n<th>基础类</th>\n<th>主要职责</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>StepMetaInterface</td>\n<td>BaseStepMeta</td>\n<td>1.存储step设置信息<br>2.验证step设置信息<br>3.序列化step设置信息<br>4.提供获取step类的方法</td>\n</tr>\n<tr>\n<td>StepDialogInterface</td>\n<td>org.pentaho.di.ui.trans.step.BaseStepDialog</td>\n<td>step属性信息配置窗口</td>\n</tr>\n<tr>\n<td>StepInterface</td>\n<td>BaseStep</td>\n<td>执行数据行的功能流程</td>\n</tr>\n<tr>\n<td>StepDataInterface</td>\n<td>BaseStepData</td>\n<td>存储处理中的数据状态</td>\n</tr>\n</tbody>\n</table>\n<p>以下我结合代码尽量</p>\n<h3 id=\"实现StepMetaInterface\"><a href=\"#实现StepMetaInterface\" class=\"headerlink\" title=\"实现StepMetaInterface\"></a>实现StepMetaInterface</h3><p>该接口主要是对步骤元数据信息进行操作。</p>\n<p>接口常用方法介绍：</p>\n<ul>\n<li>setDefault()：每次创建新步骤并将该步骤配置分配或设置为合理的默认值时，都会调用此方法。创建新步骤时，PDI客户端（Spoon）将使用此处设置的值。这是确保将步设置初始化为非空值的好地方。在序列化和对话框填充中，空值的处理可能很麻烦，因此大多数PDI步骤实现对于所有步骤设置都坚持非空值。</li>\n<li><p>clone()：在PDI客户端中复制步骤时，将调用此方法。它返回步骤元对象的深层副本。如果步骤配置存储在可修改的对象（例如列表或自定义帮助对象）中，则实现类必须创建正确的深层副本，这一点至关重要。</p>\n</li>\n<li><p>getXML()：每当步骤将其设置序列化为XML时，PDI都会调用此方法。在PDI客户端中保存转换时会调用它。该方法返回一个XML字符串，其中包含序列化的步骤设置。该字符串包含一系列XML标记，每个设置一个标记。辅助类org.pentaho.di.core.xml.XMLHandler构造XML字符串。</p>\n</li>\n<li>loadXML()：每当步骤从XML读取其设置时，PDI都会调用此方法。包含步骤设置的XML节点作为参数传入。再次，帮助程序类 org.pentaho.di.core.xml.XMLHandler从XML节点读取步骤设置。</li>\n<li>saveRep()：每当步骤将其设置保存到PDI存储库时，PDI都会调用此方法。作为第一个参数传入的存储库对象提供了一组用于序列化步骤设置的方法。调用存储库序列化方法时，该步骤将传入的转换ID和步骤ID用作标识符。</li>\n<li>readRep()：每当步骤从PDI存储库中读取其配置时，PDI都会调用此方法。使用存储库序列化方法时，参数中给出的步骤ID用作标识符。</li>\n</ul>\n<p>获取其他实例</p>\n<ul>\n<li>public StepDialogInterface getDialog()</li>\n<li>public StepInterface getStep()</li>\n<li>public StepDataInterface getStepData()</li>\n</ul>\n<p>StepMetaInterface必须使用Step Java注释对实现的类进行注释。提供以下注释属性：<br>属性|描述<br>—|—<br>id | 该步骤的全局唯一ID<br>image | 步骤的png图标图像的资源位置<br>name | 该步骤的简短标签<br>description    | 该步骤的详细说明<br>categoryDescription |    步骤的类别应显示在PDI步骤树中。例如输入，输出，变换等。<br>i18nPackageName |如果i18nPackageName在批注属性中提供了该属性，则将name，description和categoryDe​​scription的值解释为 i18n相对于给定包中包含的消息束的键。<br>可以以扩展形式的i18n:<packagename>键来提供键，以指定与i18nPackageName属性中给定的包不同的包。</packagename></p>\n<h3 id=\"实现StepDialogInterface\"><a href=\"#实现StepDialogInterface\" class=\"headerlink\" title=\"实现StepDialogInterface\"></a>实现StepDialogInterface</h3><p>该接口主要用于实现窗口的功能，以及设置属性信息的入口。打开步骤设置时候都会实例化dialog传入到StepMetaInterface接口对象并调用open()方法。</p>\n<p>接口常用方法介绍：</p>\n<ul>\n<li>open()：仅在确认或取消对话框后，此方法才返回。</li>\n</ul>\n<h3 id=\"实现StepInterface\"><a href=\"#实现StepInterface\" class=\"headerlink\" title=\"实现StepInterface\"></a>实现StepInterface</h3><p>StepInterface当转换运行时，类实现负责实际的行处理。</p>\n<p><img src=\"/images/bdata/kettle流程.png\" alt=\"StepInterface\"></p>\n<p>接口常用方法介绍：</p>\n<ul>\n<li><p>init()：当转换准备开始执行时，将调用该方法初始化资源。</p>\n</li>\n<li><p>processRow()：转换开始执行该方法，读取上一步骤传递下来的行数据，直到没有行就调用setOutputDone()返回false。</p>\n</li>\n<li><p>dispose()：转换完成后，PDI将调用该方法取消init()分配的资源。</p>\n</li>\n</ul>\n<h3 id=\"实现StepDataInterface\"><a href=\"#实现StepDataInterface\" class=\"headerlink\" title=\"实现StepDataInterface\"></a>实现StepDataInterface</h3><p>类实现StepInterface不会在其任何字段中存储处理状态。取而代之的StepDataInterface是，使用一个附加的类实现来存储处理状态，包括状态标志，索引，缓存表，数据库连接，文件句柄等</p>\n<h2 id=\"部署步骤插件\"><a href=\"#部署步骤插件\" class=\"headerlink\" title=\"部署步骤插件\"></a>部署步骤插件</h2><ol>\n<li>创建一个包含您的插件类和资源的JAR文件</li>\n<li>创建一个新文件夹，为其命名，然后将您的JAR文件放在该文件夹中</li>\n<li>将刚创建的插件文件夹放置在特定位置，以供PDI查找。根据您使用PDI的方式，您需要按如下方式将插件文件夹复制到一个或多个位置。<ul>\n<li>部署到PDI客户端（Spoon）或Carte：</li>\n<li>将plugin文件夹复制到以下位置： design-tools / data-integration / plugins / steps。</li>\n<li>重新启动PDI客户端。重新启动PDI客户端后，可以使用新的作业条目。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://help.pentaho.com/Documentation/8.3/Developer_center/Embed_and_extend_PDI_functionality\" target=\"_blank\" rel=\"noopener\">Kettle开发中心</a></p>\n<p><a href=\"https://help.pentaho.com/Documentation/8.3/Developer_center/Extend_Pentaho_Data_Integration\" target=\"_blank\" rel=\"noopener\">扩展Pentaho数据集成</a></p>\n<p><a href=\"https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins\" target=\"_blank\" rel=\"noopener\">自定义步骤插件开发</a></p>\n"},{"title":"Gateway源码分析（二）","date":"2021-07-25T03:16:39.000Z","_content":"\n# 背景\n\n这一章开始记录我开始Gateway阅读之路，看下究竟是如何实现网关。\n\n# 个人疑问\n\n1. Gateway的网关框架是如何接收请求并转发\n\n2. 如何执行Filter\n\n3. 如何加载路由、过滤器、断言等信息\n\n\n\n# 源码分析\n\n## 版本\n\n```\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-gateway</artifactI>\n\t<version>2.1.0.RELEASE</version>\n</dependency>\n```\n\n## 架构图\n\n还是一样的图\n![Gateway框架](/images/video/gateway网关图.png)\n\n## 组成\n\ngateway-core.jar是gateway的核心包，主要的实现都在里面。阅读代码前最好先知道个个包的主要功能.\n\n![包组成](/images/video/gateway的jar包架构图.png)\n\n- actuate\n\n该包主要是gateway自带的一个控制器GatewayControllerEndpoint，该endpiont提供了关于filter及routes的信息查询以及指定route信息更新的rest api，这给web界面提供管理配置功能提供了极大的便利\n\n- config\n\n该包主要是Gateway的配置实体类，譬如yml上面的配置GatewayProperties、全局的跨域配置GlobalCorsProperties等等。\n\n- discovery\n\n该包主要是实现服务发现的功能。从服务注册中心获取服务注册信息，然后配置相应的路由\n\n- event\n\n该包是一些发布事件的定义。\n\n- filter\n\n该包包含了gateway所有内置的过滤器。\n\n- handler\n\n该包主要包括了所有内置的Predicates断言，RoutePredicateHandlerMapping类是一个实现了将接收请求到转发到filter里面的功能，FilteringWebHandler主要是构造过滤器链。\n\n- route\n\n该包主要是定义路由信息，构造路由等。\n\n- support\n\n该包主要是一些工具方法。用于全局。\n\n\n\n## 源码分析\n\n### 问题一：如何转发请求\n\n#### DispatchHandler类\n\nWebFlux请求转发核心类：DispatchHandler\n\nDispatchHandler内部主要的私有字段：\n\n```java\n@Nullable\nprivate List<HandlerMapping> handlerMappings;\n\n@Nullable\nprivate List<HandlerAdapter> handlerAdapters;\n\n@Nullable\nprivate List<HandlerResultHandler> resultHandlers;\n```\n\n类型 | 解释\n---|---\nHandlerMapping | 映射请求到一个处理器。该映射是基于一定的标准、细节因不同HandlerMapping而不同。</br>例如有注解控制器, 简单URL匹配映射等等。</br>主要的HandlerMapping实现：</br>1.有RequestMappingHandlerMapping对于注解的@RequestMapping。</br>2.RouterFunctionMapping 对应于函数式端点路由。</br>3.SimpleUrlHandlerMappingURI路径模式的显式注册。</br>4.WebHandler的实例\nHandlerAdapter | 帮助DispatcherHandler调用映射的请求的处理器，而不管该处理程序实际上是如何调用的。</br>例如执行一个注解控制器需要解释注解。其主要目的是帮助DispatcherHandler隐藏实现的细节。\nHandlerResultHandler | 处理程序调用的结果并最后确定响应。</br>1.ResponseEntityResultHandler：ResponseEntity，处理@Controller实例。</br>2.ServerResponseResultHandler：ServerResponse，处理函数式端点。</br>3.ResponseBodyResultHandler：处理从@ResponseBody方法和@RestController类的返回值。</br>4.ViewResolutionResultHandler：处理成CharSequence,View, Model, Map, Rendering等其他的模型属性。\n\n\n```java\n@Override\npublic Mono<Void> handle(ServerWebExchange exchange) {\n\tif (this.handlerMappings == null) {\n\t\treturn Mono.error(HANDLER_NOT_FOUND_EXCEPTION);\n\t}\n\treturn Flux.fromIterable(this.handlerMappings)\n\t\t\t.concatMap(mapping -> mapping.getHandler(exchange))\n\t\t\t.next()\n\t\t\t.switchIfEmpty(Mono.error(HANDLER_NOT_FOUND_EXCEPTION))\n\t\t\t.flatMap(handler -> invokeHandler(exchange, handler))\n\t\t\t.flatMap(result -> handleResult(exchange, result));\n}\n```\n\n核心方法主要做了三个步骤：\n\n1. 匹配每一个不同HandlerMapping，使用首先匹配的那个。\n2. 执行器被找到就会找到对应的HandlerAdapter,然后就会将返回结果返回到HandlerResult里。\n3. HandlerResult会给出一个合适的处理器去完成直接写到响应里面或者使用View来渲染的处理。\n\n#### RoutePredicateHandlerMapping类\n\n刚说完DispatchHandler的类，就到HandlerMapping了，类RoutePredicateHandlerMapping实现了HandlerMapping。\n\n其核心私有字段分别有：\n```java\nprivate final FilteringWebHandler webHandler;\n\nprivate final RouteLocator routeLocator;\n\nprivate final Integer managmentPort;\n```\n\nBean类型 | 解释\n---|---\nwebHandler | 构建过滤器的责任链\nrouteLocator | 路由的定义信息\nmanagmentPort | gateway管理端口\n\n\n其核心方法：\n\n```java\n@Override\nprotected Mono<?> getHandlerInternal(ServerWebExchange exchange) {\n\t// don't handle requests on the management port if set\n\tif (managmentPort != null && exchange.getRequest().getURI().getPort() == managmentPort.intValue()) {\n\t\treturn Mono.empty();\n\t}\n\texchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());\n\n\treturn lookupRoute(exchange)\n\t\t\t// .log(\"route-predicate-handler-mapping\", Level.FINER) //name this\n\t\t\t.flatMap((Function<Route, Mono<?>>) r -> {\n\t\t\t\texchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Mapping [\" + getExchangeDesc(exchange) + \"] to \" + r);\n\t\t\t\t}\n\n\t\t\t\texchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);\n\t\t\t\treturn Mono.just(webHandler);\n\t\t\t}).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -> {\n\t\t\t\texchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No RouteDefinition found for [\" + getExchangeDesc(exchange) + \"]\");\n\t\t\t\t}\n\t\t\t})));\n}\n```\n\n该核心方法做了几件事：\n\n1. 找到合适的路由lookupRoute方法。\n2. 将路由信息放到ServerWebExchange请求线程的属性里，以便整个运行随时可用。\n3. 执行webHandler中的过滤器链。==（后面会介绍如何执行）==\n\n\nlookupRoute执行过程：\n1. 通过routeLocator的获取所有配置好的路由信息。 ==（后面会介绍如何加载路由信息、过滤器、断言）==\n2. 匹配每一个路由的断言，是否符合，若符合则返回对应的路由信息。若不符合则next()下一个路由的断言匹配。\n\n```java\nprotected Mono<Route> lookupRoute(ServerWebExchange exchange) {\n\treturn this.routeLocator\n\t\t\t.getRoutes()\n\t\t\t//individually filter routes so that filterWhen error delaying is not a problem\n\t\t\t.concatMap(route -> Mono\n\t\t\t\t\t.just(route)\n\t\t\t\t\t.filterWhen(r -> {\n\t\t\t\t\t\t// add the current route we are testing\n\t\t\t\t\t\texchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());\n\t\t\t\t\t\treturn r.getPredicate().apply(exchange);\n\t\t\t\t\t})\n\t\t\t\t\t//instead of immediately stopping main flux due to error, log and swallow it\n\t\t\t\t\t.doOnError(e -> logger.error(\"Error applying predicate for route: \"+route.getId(), e))\n\t\t\t\t\t.onErrorResume(e -> Mono.empty())\n\t\t\t)\n\t\t\t// .defaultIfEmpty() put a static Route not found\n\t\t\t// or .switchIfEmpty()\n\t\t\t// .switchIfEmpty(Mono.<Route>empty().log(\"noroute\"))\n\t\t\t.next()\n\t\t\t//TODO: error handling\n\t\t\t.map(route -> {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Route matched: \" + route.getId());\n\t\t\t\t}\n\t\t\t\tvalidateRoute(route, exchange);\n\t\t\t\treturn route;\n\t\t\t});\n}\n```\n\n### 问题二：如何执行Filter\n\n\n#### 如何执行Filter(FilteringWebHandler类)\n\n\n执行流程：\n\n1. 初始化时候构造好全局的过滤器集合。\n2. 合并路由上配置的过滤器与全局过滤器\n3. 排序好所有过滤器传入DefaultGatewayFilterChain的责任链里执行。\n\n```\n@Override\npublic Mono<Void> handle(ServerWebExchange exchange) {\n\tRoute route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);\n\tList<GatewayFilter> gatewayFilters = route.getFilters();\n\n\tList<GatewayFilter> combined = new ArrayList<>(this.globalFilters);\n\tcombined.addAll(gatewayFilters);\n\t//TODO: needed or cached?\n\tAnnotationAwareOrderComparator.sort(combined);\n\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Sorted gatewayFilterFactories: \"+ combined);\n\t}\n\n\treturn new DefaultGatewayFilterChain(combined).filter(exchange);\n}\n```\n\n责任链是一个常用的编程设计模式，它能够将请求与处理步骤解耦，请求操作对链内部的执行透明，而且每个链子都有自己具体实现，能够自由组装复用，不相互影响，使得代码更加简洁。不过责任联在调试方面相对来说比较麻烦，不便于观察等缺点。\n\n看下如何构造一个责任联，内部类DefaultGatewayFilterChain\n的filter方法\n```java\nprivate static class DefaultGatewayFilterChain implements GatewayFilterChain {\n\n\t\tprivate final int index;\n\t\tprivate final List<GatewayFilter> filters;\n\n\t\tpublic DefaultGatewayFilterChain(List<GatewayFilter> filters) {\n\t\t\tthis.filters = filters;\n\t\t\tthis.index = 0;\n\t\t}\n\n\t\tprivate DefaultGatewayFilterChain(DefaultGatewayFilterChain parent, int index) {\n\t\t\tthis.filters = parent.getFilters();\n\t\t\tthis.index = index;\n\t\t}\n\n\t\tpublic List<GatewayFilter> getFilters() {\n\t\t\treturn filters;\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<Void> filter(ServerWebExchange exchange) {\n\t\t\treturn Mono.defer(() -> {\n\t\t\t\tif (this.index < filters.size()) {\n\t\t\t\t\tGatewayFilter filter = filters.get(this.index);\n\t\t\t\t\tDefaultGatewayFilterChain chain = new DefaultGatewayFilterChain(this, this.index + 1);\n\t\t\t\t\treturn filter.filter(exchange, chain);\n\t\t\t\t} else {\n\t\t\t\t\treturn Mono.empty(); // complete\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n```\n\n\n### 问题三：如何加载路由、过滤器、断言等信息\n\n\n#### RouteDefinitionRouteLocator类\n\n- 获取路由信息\n\n```\n@Override\npublic Flux<Route> getRoutes() {\n\treturn this.routeDefinitionLocator.getRouteDefinitions()\n\t\t\t.map(this::convertToRoute)\n\t\t\t//TODO: error handling\n\t\t\t.map(route -> {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"RouteDefinition matched: \" + route.getId());\n\t\t\t\t}\n\t\t\t\treturn route;\n\t\t\t});\n\n\n\t/* TODO: trace logging\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"RouteDefinition did not match: \" + routeDefinition.getId());\n\t\t}*/\n}\n```\n\n==this.routeDefinitionLocator.getRouteDefinitions()== 初始化首次加载获取配置文件中定义的路由信息并存于缓存中以便下次使用\n```\npublic CachingRouteDefinitionLocator(RouteDefinitionLocator delegate) {\n\t\tthis.delegate = delegate;\n\t\trouteDefinitions = CacheFlux.lookup(cache, \"routeDefs\", RouteDefinition.class)\n\t\t\t\t.onCacheMissResume(this.delegate::getRouteDefinitions);\n}\n```\n\n==convertToRoute==则是将配置信息定义的路由信息转变为真正内部使用的路由实体，具体实现如下：\n\n1. 组装断言链表\n2. 获取配置信息定义过滤器\n3. 组装成真正路由对象Route\n```\nprivate Route convertToRoute(RouteDefinition routeDefinition) {\n\t\tAsyncPredicate<ServerWebExchange> predicate = combinePredicates(routeDefinition);\n\t\tList<GatewayFilter> gatewayFilters = getFilters(routeDefinition);\n\n\t\treturn Route.async(routeDefinition)\n\t\t\t\t.asyncPredicate(predicate)\n\t\t\t\t.replaceFilters(gatewayFilters)\n\t\t\t\t.build();\n\t}\n```\n\n其实这段代码使用了一个设计模式就是建造者模式。该模式能将构建和实现分离开来，建造者能逐步细化而不影响其它模块功能。不过建造者对产品会依赖，当产品发生变化，建造者相应也需要改变。所以这种模式建议用在比较简化的建造者依赖类上。\n\n```\nreturn Route.async(routeDefinition)\n\t\t\t\t.asyncPredicate(predicate)\n\t\t\t\t.replaceFilters(gatewayFilters)\n\t\t\t\t.build();\n```\n![建造者模式](/images/video/Router的结构图.png)\n\n\n\n“断言”的功能在我看来实现得是非常巧妙的，所有断言正如过滤器一样都有一个共同的父类AbstractRoutePredicateFactory，实现apply的方法。看个例子：\n\nPathRoutePredicateFactory断言类：作用是匹配请求uri资源。可以看出返回的是一个Predicate的实例，这样的好处就是在下次执行只会执行return返回的这一部分代码功能，不再需要执行配置行的代码。\n\n```\n@Override\npublic Predicate<ServerWebExchange> apply(Config config) {\n\tfinal ArrayList<PathPattern> pathPatterns = new ArrayList<>();\n\tsynchronized (this.pathPatternParser) {\n\t\tpathPatternParser.setMatchOptionalTrailingSeparator(config.isMatchOptionalTrailingSeparator());\n\t\tconfig.getPatterns().forEach(pattern -> {\n\t\t\tPathPattern pathPattern = this.pathPatternParser.parse(pattern);\n\t\t\tpathPatterns.add(pathPattern);\n\t\t});\n\t}\n\treturn exchange -> {\n\t\tPathContainer path = parsePath(exchange.getRequest().getURI().getPath());\n\n\t\tOptional<PathPattern> optionalPathPattern = pathPatterns.stream()\n\t\t\t\t.filter(pattern -> pattern.matches(path))\n\t\t\t\t.findFirst();\n\n\t\tif (optionalPathPattern.isPresent()) {\n\t\t\tPathPattern pathPattern = optionalPathPattern.get();\n\t\t\ttraceMatch(\"Pattern\", pathPattern.getPatternString(), path, true);\n\t\t\tPathMatchInfo pathMatchInfo = pathPattern.matchAndExtract(path);\n\t\t\tputUriTemplateVariables(exchange, pathMatchInfo.getUriVariables());\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttraceMatch(\"Pattern\", config.getPatterns(), path, false);\n\t\t\treturn false;\n\t\t}\n\t};\n}\n```\n\n然后通过Flux.zip方法连成一条断言链子\n```\nprivate AsyncPredicate<ServerWebExchange> combinePredicates(RouteDefinition routeDefinition) {\n\tList<PredicateDefinition> predicates = routeDefinition.getPredicates();\n\tAsyncPredicate<ServerWebExchange> predicate = lookup(routeDefinition, predicates.get(0));\n\n\tfor (PredicateDefinition andPredicate : predicates.subList(1, predicates.size())) {\n\t\tAsyncPredicate<ServerWebExchange> found = lookup(routeDefinition, andPredicate);\n\t\tpredicate = predicate.and(found);\n\t}\n\n\treturn predicate;\n}\n\n---------------------------------------------------\n\ndefault AsyncPredicate<T> and(AsyncPredicate<? super T> other) {\n\tObjects.requireNonNull(other, \"other must not be null\");\n\n\treturn t -> Flux.zip(apply(t), other.apply(t))\n\t\t\t.map(tuple -> tuple.getT1() && tuple.getT2());\n}\n```\n\n# 总结\n其实到这里这一章就差不多了，基本上Gateway的主要总体框架功能就这些。这一次的阅读源码能够使我对lambda表达式的用处更深刻，而且，对这种响应式流的理解更进一步了，后续还会持续学习关于netty reactor的用法。","source":"_posts/Gateway源码分析(二).md","raw":"---\ntitle: Gateway源码分析（二）\ndate: 2021-07-25 11:16:39\ncategories: \n- 视频\ntags:\n- 视频\n---\n\n# 背景\n\n这一章开始记录我开始Gateway阅读之路，看下究竟是如何实现网关。\n\n# 个人疑问\n\n1. Gateway的网关框架是如何接收请求并转发\n\n2. 如何执行Filter\n\n3. 如何加载路由、过滤器、断言等信息\n\n\n\n# 源码分析\n\n## 版本\n\n```\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-gateway</artifactI>\n\t<version>2.1.0.RELEASE</version>\n</dependency>\n```\n\n## 架构图\n\n还是一样的图\n![Gateway框架](/images/video/gateway网关图.png)\n\n## 组成\n\ngateway-core.jar是gateway的核心包，主要的实现都在里面。阅读代码前最好先知道个个包的主要功能.\n\n![包组成](/images/video/gateway的jar包架构图.png)\n\n- actuate\n\n该包主要是gateway自带的一个控制器GatewayControllerEndpoint，该endpiont提供了关于filter及routes的信息查询以及指定route信息更新的rest api，这给web界面提供管理配置功能提供了极大的便利\n\n- config\n\n该包主要是Gateway的配置实体类，譬如yml上面的配置GatewayProperties、全局的跨域配置GlobalCorsProperties等等。\n\n- discovery\n\n该包主要是实现服务发现的功能。从服务注册中心获取服务注册信息，然后配置相应的路由\n\n- event\n\n该包是一些发布事件的定义。\n\n- filter\n\n该包包含了gateway所有内置的过滤器。\n\n- handler\n\n该包主要包括了所有内置的Predicates断言，RoutePredicateHandlerMapping类是一个实现了将接收请求到转发到filter里面的功能，FilteringWebHandler主要是构造过滤器链。\n\n- route\n\n该包主要是定义路由信息，构造路由等。\n\n- support\n\n该包主要是一些工具方法。用于全局。\n\n\n\n## 源码分析\n\n### 问题一：如何转发请求\n\n#### DispatchHandler类\n\nWebFlux请求转发核心类：DispatchHandler\n\nDispatchHandler内部主要的私有字段：\n\n```java\n@Nullable\nprivate List<HandlerMapping> handlerMappings;\n\n@Nullable\nprivate List<HandlerAdapter> handlerAdapters;\n\n@Nullable\nprivate List<HandlerResultHandler> resultHandlers;\n```\n\n类型 | 解释\n---|---\nHandlerMapping | 映射请求到一个处理器。该映射是基于一定的标准、细节因不同HandlerMapping而不同。</br>例如有注解控制器, 简单URL匹配映射等等。</br>主要的HandlerMapping实现：</br>1.有RequestMappingHandlerMapping对于注解的@RequestMapping。</br>2.RouterFunctionMapping 对应于函数式端点路由。</br>3.SimpleUrlHandlerMappingURI路径模式的显式注册。</br>4.WebHandler的实例\nHandlerAdapter | 帮助DispatcherHandler调用映射的请求的处理器，而不管该处理程序实际上是如何调用的。</br>例如执行一个注解控制器需要解释注解。其主要目的是帮助DispatcherHandler隐藏实现的细节。\nHandlerResultHandler | 处理程序调用的结果并最后确定响应。</br>1.ResponseEntityResultHandler：ResponseEntity，处理@Controller实例。</br>2.ServerResponseResultHandler：ServerResponse，处理函数式端点。</br>3.ResponseBodyResultHandler：处理从@ResponseBody方法和@RestController类的返回值。</br>4.ViewResolutionResultHandler：处理成CharSequence,View, Model, Map, Rendering等其他的模型属性。\n\n\n```java\n@Override\npublic Mono<Void> handle(ServerWebExchange exchange) {\n\tif (this.handlerMappings == null) {\n\t\treturn Mono.error(HANDLER_NOT_FOUND_EXCEPTION);\n\t}\n\treturn Flux.fromIterable(this.handlerMappings)\n\t\t\t.concatMap(mapping -> mapping.getHandler(exchange))\n\t\t\t.next()\n\t\t\t.switchIfEmpty(Mono.error(HANDLER_NOT_FOUND_EXCEPTION))\n\t\t\t.flatMap(handler -> invokeHandler(exchange, handler))\n\t\t\t.flatMap(result -> handleResult(exchange, result));\n}\n```\n\n核心方法主要做了三个步骤：\n\n1. 匹配每一个不同HandlerMapping，使用首先匹配的那个。\n2. 执行器被找到就会找到对应的HandlerAdapter,然后就会将返回结果返回到HandlerResult里。\n3. HandlerResult会给出一个合适的处理器去完成直接写到响应里面或者使用View来渲染的处理。\n\n#### RoutePredicateHandlerMapping类\n\n刚说完DispatchHandler的类，就到HandlerMapping了，类RoutePredicateHandlerMapping实现了HandlerMapping。\n\n其核心私有字段分别有：\n```java\nprivate final FilteringWebHandler webHandler;\n\nprivate final RouteLocator routeLocator;\n\nprivate final Integer managmentPort;\n```\n\nBean类型 | 解释\n---|---\nwebHandler | 构建过滤器的责任链\nrouteLocator | 路由的定义信息\nmanagmentPort | gateway管理端口\n\n\n其核心方法：\n\n```java\n@Override\nprotected Mono<?> getHandlerInternal(ServerWebExchange exchange) {\n\t// don't handle requests on the management port if set\n\tif (managmentPort != null && exchange.getRequest().getURI().getPort() == managmentPort.intValue()) {\n\t\treturn Mono.empty();\n\t}\n\texchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());\n\n\treturn lookupRoute(exchange)\n\t\t\t// .log(\"route-predicate-handler-mapping\", Level.FINER) //name this\n\t\t\t.flatMap((Function<Route, Mono<?>>) r -> {\n\t\t\t\texchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Mapping [\" + getExchangeDesc(exchange) + \"] to \" + r);\n\t\t\t\t}\n\n\t\t\t\texchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);\n\t\t\t\treturn Mono.just(webHandler);\n\t\t\t}).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -> {\n\t\t\t\texchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No RouteDefinition found for [\" + getExchangeDesc(exchange) + \"]\");\n\t\t\t\t}\n\t\t\t})));\n}\n```\n\n该核心方法做了几件事：\n\n1. 找到合适的路由lookupRoute方法。\n2. 将路由信息放到ServerWebExchange请求线程的属性里，以便整个运行随时可用。\n3. 执行webHandler中的过滤器链。==（后面会介绍如何执行）==\n\n\nlookupRoute执行过程：\n1. 通过routeLocator的获取所有配置好的路由信息。 ==（后面会介绍如何加载路由信息、过滤器、断言）==\n2. 匹配每一个路由的断言，是否符合，若符合则返回对应的路由信息。若不符合则next()下一个路由的断言匹配。\n\n```java\nprotected Mono<Route> lookupRoute(ServerWebExchange exchange) {\n\treturn this.routeLocator\n\t\t\t.getRoutes()\n\t\t\t//individually filter routes so that filterWhen error delaying is not a problem\n\t\t\t.concatMap(route -> Mono\n\t\t\t\t\t.just(route)\n\t\t\t\t\t.filterWhen(r -> {\n\t\t\t\t\t\t// add the current route we are testing\n\t\t\t\t\t\texchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());\n\t\t\t\t\t\treturn r.getPredicate().apply(exchange);\n\t\t\t\t\t})\n\t\t\t\t\t//instead of immediately stopping main flux due to error, log and swallow it\n\t\t\t\t\t.doOnError(e -> logger.error(\"Error applying predicate for route: \"+route.getId(), e))\n\t\t\t\t\t.onErrorResume(e -> Mono.empty())\n\t\t\t)\n\t\t\t// .defaultIfEmpty() put a static Route not found\n\t\t\t// or .switchIfEmpty()\n\t\t\t// .switchIfEmpty(Mono.<Route>empty().log(\"noroute\"))\n\t\t\t.next()\n\t\t\t//TODO: error handling\n\t\t\t.map(route -> {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Route matched: \" + route.getId());\n\t\t\t\t}\n\t\t\t\tvalidateRoute(route, exchange);\n\t\t\t\treturn route;\n\t\t\t});\n}\n```\n\n### 问题二：如何执行Filter\n\n\n#### 如何执行Filter(FilteringWebHandler类)\n\n\n执行流程：\n\n1. 初始化时候构造好全局的过滤器集合。\n2. 合并路由上配置的过滤器与全局过滤器\n3. 排序好所有过滤器传入DefaultGatewayFilterChain的责任链里执行。\n\n```\n@Override\npublic Mono<Void> handle(ServerWebExchange exchange) {\n\tRoute route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);\n\tList<GatewayFilter> gatewayFilters = route.getFilters();\n\n\tList<GatewayFilter> combined = new ArrayList<>(this.globalFilters);\n\tcombined.addAll(gatewayFilters);\n\t//TODO: needed or cached?\n\tAnnotationAwareOrderComparator.sort(combined);\n\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Sorted gatewayFilterFactories: \"+ combined);\n\t}\n\n\treturn new DefaultGatewayFilterChain(combined).filter(exchange);\n}\n```\n\n责任链是一个常用的编程设计模式，它能够将请求与处理步骤解耦，请求操作对链内部的执行透明，而且每个链子都有自己具体实现，能够自由组装复用，不相互影响，使得代码更加简洁。不过责任联在调试方面相对来说比较麻烦，不便于观察等缺点。\n\n看下如何构造一个责任联，内部类DefaultGatewayFilterChain\n的filter方法\n```java\nprivate static class DefaultGatewayFilterChain implements GatewayFilterChain {\n\n\t\tprivate final int index;\n\t\tprivate final List<GatewayFilter> filters;\n\n\t\tpublic DefaultGatewayFilterChain(List<GatewayFilter> filters) {\n\t\t\tthis.filters = filters;\n\t\t\tthis.index = 0;\n\t\t}\n\n\t\tprivate DefaultGatewayFilterChain(DefaultGatewayFilterChain parent, int index) {\n\t\t\tthis.filters = parent.getFilters();\n\t\t\tthis.index = index;\n\t\t}\n\n\t\tpublic List<GatewayFilter> getFilters() {\n\t\t\treturn filters;\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<Void> filter(ServerWebExchange exchange) {\n\t\t\treturn Mono.defer(() -> {\n\t\t\t\tif (this.index < filters.size()) {\n\t\t\t\t\tGatewayFilter filter = filters.get(this.index);\n\t\t\t\t\tDefaultGatewayFilterChain chain = new DefaultGatewayFilterChain(this, this.index + 1);\n\t\t\t\t\treturn filter.filter(exchange, chain);\n\t\t\t\t} else {\n\t\t\t\t\treturn Mono.empty(); // complete\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n```\n\n\n### 问题三：如何加载路由、过滤器、断言等信息\n\n\n#### RouteDefinitionRouteLocator类\n\n- 获取路由信息\n\n```\n@Override\npublic Flux<Route> getRoutes() {\n\treturn this.routeDefinitionLocator.getRouteDefinitions()\n\t\t\t.map(this::convertToRoute)\n\t\t\t//TODO: error handling\n\t\t\t.map(route -> {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"RouteDefinition matched: \" + route.getId());\n\t\t\t\t}\n\t\t\t\treturn route;\n\t\t\t});\n\n\n\t/* TODO: trace logging\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"RouteDefinition did not match: \" + routeDefinition.getId());\n\t\t}*/\n}\n```\n\n==this.routeDefinitionLocator.getRouteDefinitions()== 初始化首次加载获取配置文件中定义的路由信息并存于缓存中以便下次使用\n```\npublic CachingRouteDefinitionLocator(RouteDefinitionLocator delegate) {\n\t\tthis.delegate = delegate;\n\t\trouteDefinitions = CacheFlux.lookup(cache, \"routeDefs\", RouteDefinition.class)\n\t\t\t\t.onCacheMissResume(this.delegate::getRouteDefinitions);\n}\n```\n\n==convertToRoute==则是将配置信息定义的路由信息转变为真正内部使用的路由实体，具体实现如下：\n\n1. 组装断言链表\n2. 获取配置信息定义过滤器\n3. 组装成真正路由对象Route\n```\nprivate Route convertToRoute(RouteDefinition routeDefinition) {\n\t\tAsyncPredicate<ServerWebExchange> predicate = combinePredicates(routeDefinition);\n\t\tList<GatewayFilter> gatewayFilters = getFilters(routeDefinition);\n\n\t\treturn Route.async(routeDefinition)\n\t\t\t\t.asyncPredicate(predicate)\n\t\t\t\t.replaceFilters(gatewayFilters)\n\t\t\t\t.build();\n\t}\n```\n\n其实这段代码使用了一个设计模式就是建造者模式。该模式能将构建和实现分离开来，建造者能逐步细化而不影响其它模块功能。不过建造者对产品会依赖，当产品发生变化，建造者相应也需要改变。所以这种模式建议用在比较简化的建造者依赖类上。\n\n```\nreturn Route.async(routeDefinition)\n\t\t\t\t.asyncPredicate(predicate)\n\t\t\t\t.replaceFilters(gatewayFilters)\n\t\t\t\t.build();\n```\n![建造者模式](/images/video/Router的结构图.png)\n\n\n\n“断言”的功能在我看来实现得是非常巧妙的，所有断言正如过滤器一样都有一个共同的父类AbstractRoutePredicateFactory，实现apply的方法。看个例子：\n\nPathRoutePredicateFactory断言类：作用是匹配请求uri资源。可以看出返回的是一个Predicate的实例，这样的好处就是在下次执行只会执行return返回的这一部分代码功能，不再需要执行配置行的代码。\n\n```\n@Override\npublic Predicate<ServerWebExchange> apply(Config config) {\n\tfinal ArrayList<PathPattern> pathPatterns = new ArrayList<>();\n\tsynchronized (this.pathPatternParser) {\n\t\tpathPatternParser.setMatchOptionalTrailingSeparator(config.isMatchOptionalTrailingSeparator());\n\t\tconfig.getPatterns().forEach(pattern -> {\n\t\t\tPathPattern pathPattern = this.pathPatternParser.parse(pattern);\n\t\t\tpathPatterns.add(pathPattern);\n\t\t});\n\t}\n\treturn exchange -> {\n\t\tPathContainer path = parsePath(exchange.getRequest().getURI().getPath());\n\n\t\tOptional<PathPattern> optionalPathPattern = pathPatterns.stream()\n\t\t\t\t.filter(pattern -> pattern.matches(path))\n\t\t\t\t.findFirst();\n\n\t\tif (optionalPathPattern.isPresent()) {\n\t\t\tPathPattern pathPattern = optionalPathPattern.get();\n\t\t\ttraceMatch(\"Pattern\", pathPattern.getPatternString(), path, true);\n\t\t\tPathMatchInfo pathMatchInfo = pathPattern.matchAndExtract(path);\n\t\t\tputUriTemplateVariables(exchange, pathMatchInfo.getUriVariables());\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttraceMatch(\"Pattern\", config.getPatterns(), path, false);\n\t\t\treturn false;\n\t\t}\n\t};\n}\n```\n\n然后通过Flux.zip方法连成一条断言链子\n```\nprivate AsyncPredicate<ServerWebExchange> combinePredicates(RouteDefinition routeDefinition) {\n\tList<PredicateDefinition> predicates = routeDefinition.getPredicates();\n\tAsyncPredicate<ServerWebExchange> predicate = lookup(routeDefinition, predicates.get(0));\n\n\tfor (PredicateDefinition andPredicate : predicates.subList(1, predicates.size())) {\n\t\tAsyncPredicate<ServerWebExchange> found = lookup(routeDefinition, andPredicate);\n\t\tpredicate = predicate.and(found);\n\t}\n\n\treturn predicate;\n}\n\n---------------------------------------------------\n\ndefault AsyncPredicate<T> and(AsyncPredicate<? super T> other) {\n\tObjects.requireNonNull(other, \"other must not be null\");\n\n\treturn t -> Flux.zip(apply(t), other.apply(t))\n\t\t\t.map(tuple -> tuple.getT1() && tuple.getT2());\n}\n```\n\n# 总结\n其实到这里这一章就差不多了，基本上Gateway的主要总体框架功能就这些。这一次的阅读源码能够使我对lambda表达式的用处更深刻，而且，对这种响应式流的理解更进一步了，后续还会持续学习关于netty reactor的用法。","slug":"Gateway源码分析(二)","published":1,"updated":"2021-09-07T08:00:52.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhr80006d0tvuil4okos","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>这一章开始记录我开始Gateway阅读之路，看下究竟是如何实现网关。</p>\n<h1 id=\"个人疑问\"><a href=\"#个人疑问\" class=\"headerlink\" title=\"个人疑问\"></a>个人疑问</h1><ol>\n<li><p>Gateway的网关框架是如何接收请求并转发</p>\n</li>\n<li><p>如何执行Filter</p>\n</li>\n<li><p>如何加载路由、过滤器、断言等信息</p>\n</li>\n</ol>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactI&gt;</span><br><span class=\"line\">\t&lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"架构图\"><a href=\"#架构图\" class=\"headerlink\" title=\"架构图\"></a>架构图</h2><p>还是一样的图<br><img src=\"/images/video/gateway网关图.png\" alt=\"Gateway框架\"></p>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h2><p>gateway-core.jar是gateway的核心包，主要的实现都在里面。阅读代码前最好先知道个个包的主要功能.</p>\n<p><img src=\"/images/video/gateway的jar包架构图.png\" alt=\"包组成\"></p>\n<ul>\n<li>actuate</li>\n</ul>\n<p>该包主要是gateway自带的一个控制器GatewayControllerEndpoint，该endpiont提供了关于filter及routes的信息查询以及指定route信息更新的rest api，这给web界面提供管理配置功能提供了极大的便利</p>\n<ul>\n<li>config</li>\n</ul>\n<p>该包主要是Gateway的配置实体类，譬如yml上面的配置GatewayProperties、全局的跨域配置GlobalCorsProperties等等。</p>\n<ul>\n<li>discovery</li>\n</ul>\n<p>该包主要是实现服务发现的功能。从服务注册中心获取服务注册信息，然后配置相应的路由</p>\n<ul>\n<li>event</li>\n</ul>\n<p>该包是一些发布事件的定义。</p>\n<ul>\n<li>filter</li>\n</ul>\n<p>该包包含了gateway所有内置的过滤器。</p>\n<ul>\n<li>handler</li>\n</ul>\n<p>该包主要包括了所有内置的Predicates断言，RoutePredicateHandlerMapping类是一个实现了将接收请求到转发到filter里面的功能，FilteringWebHandler主要是构造过滤器链。</p>\n<ul>\n<li>route</li>\n</ul>\n<p>该包主要是定义路由信息，构造路由等。</p>\n<ul>\n<li>support</li>\n</ul>\n<p>该包主要是一些工具方法。用于全局。</p>\n<h2 id=\"源码分析-1\"><a href=\"#源码分析-1\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"问题一：如何转发请求\"><a href=\"#问题一：如何转发请求\" class=\"headerlink\" title=\"问题一：如何转发请求\"></a>问题一：如何转发请求</h3><h4 id=\"DispatchHandler类\"><a href=\"#DispatchHandler类\" class=\"headerlink\" title=\"DispatchHandler类\"></a>DispatchHandler类</h4><p>WebFlux请求转发核心类：DispatchHandler</p>\n<p>DispatchHandler内部主要的私有字段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;HandlerResultHandler&gt; resultHandlers;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HandlerMapping</td>\n<td>映射请求到一个处理器。该映射是基于一定的标准、细节因不同HandlerMapping而不同。<br>例如有注解控制器, 简单URL匹配映射等等。<br>主要的HandlerMapping实现：<br>1.有RequestMappingHandlerMapping对于注解的@RequestMapping。<br>2.RouterFunctionMapping 对应于函数式端点路由。<br>3.SimpleUrlHandlerMappingURI路径模式的显式注册。<br>4.WebHandler的实例</td>\n</tr>\n<tr>\n<td>HandlerAdapter</td>\n<td>帮助DispatcherHandler调用映射的请求的处理器，而不管该处理程序实际上是如何调用的。<br>例如执行一个注解控制器需要解释注解。其主要目的是帮助DispatcherHandler隐藏实现的细节。</td>\n</tr>\n<tr>\n<td>HandlerResultHandler</td>\n<td>处理程序调用的结果并最后确定响应。<br>1.ResponseEntityResultHandler：ResponseEntity，处理@Controller实例。<br>2.ServerResponseResultHandler：ServerResponse，处理函数式端点。<br>3.ResponseBodyResultHandler：处理从@ResponseBody方法和@RestController类的返回值。<br>4.ViewResolutionResultHandler：处理成CharSequence,View, Model, Map, Rendering等其他的模型属性。</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title\">handle</span><span class=\"params\">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.handlerMappings == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Mono.error(HANDLER_NOT_FOUND_EXCEPTION);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Flux.fromIterable(<span class=\"keyword\">this</span>.handlerMappings)</span><br><span class=\"line\">\t\t\t.concatMap(mapping -&gt; mapping.getHandler(exchange))</span><br><span class=\"line\">\t\t\t.next()</span><br><span class=\"line\">\t\t\t.switchIfEmpty(Mono.error(HANDLER_NOT_FOUND_EXCEPTION))</span><br><span class=\"line\">\t\t\t.flatMap(handler -&gt; invokeHandler(exchange, handler))</span><br><span class=\"line\">\t\t\t.flatMap(result -&gt; handleResult(exchange, result));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>核心方法主要做了三个步骤：</p>\n<ol>\n<li>匹配每一个不同HandlerMapping，使用首先匹配的那个。</li>\n<li>执行器被找到就会找到对应的HandlerAdapter,然后就会将返回结果返回到HandlerResult里。</li>\n<li>HandlerResult会给出一个合适的处理器去完成直接写到响应里面或者使用View来渲染的处理。</li>\n</ol>\n<h4 id=\"RoutePredicateHandlerMapping类\"><a href=\"#RoutePredicateHandlerMapping类\" class=\"headerlink\" title=\"RoutePredicateHandlerMapping类\"></a>RoutePredicateHandlerMapping类</h4><p>刚说完DispatchHandler的类，就到HandlerMapping了，类RoutePredicateHandlerMapping实现了HandlerMapping。</p>\n<p>其核心私有字段分别有：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FilteringWebHandler webHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RouteLocator routeLocator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Integer managmentPort;</span><br></pre></td></tr></table></figure></p>\n<table>\n<thead>\n<tr>\n<th>Bean类型</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>webHandler</td>\n<td>构建过滤器的责任链</td>\n</tr>\n<tr>\n<td>routeLocator</td>\n<td>路由的定义信息</td>\n</tr>\n<tr>\n<td>managmentPort</td>\n<td>gateway管理端口</td>\n</tr>\n</tbody>\n</table>\n<p>其核心方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Mono&lt;?&gt; getHandlerInternal(ServerWebExchange exchange) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// don't handle requests on the management port if set</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (managmentPort != <span class=\"keyword\">null</span> &amp;&amp; exchange.getRequest().getURI().getPort() == managmentPort.intValue()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Mono.empty();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\texchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lookupRoute(exchange)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// .log(\"route-predicate-handler-mapping\", Level.FINER) //name this</span></span><br><span class=\"line\">\t\t\t.flatMap((Function&lt;Route, Mono&lt;?&gt;&gt;) r -&gt; &#123;</span><br><span class=\"line\">\t\t\t\texchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(<span class=\"string\">\"Mapping [\"</span> + getExchangeDesc(exchange) + <span class=\"string\">\"] to \"</span> + r);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\texchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> Mono.just(webHandler);</span><br><span class=\"line\">\t\t\t&#125;).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class=\"line\">\t\t\t\texchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.trace(<span class=\"string\">\"No RouteDefinition found for [\"</span> + getExchangeDesc(exchange) + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该核心方法做了几件事：</p>\n<ol>\n<li>找到合适的路由lookupRoute方法。</li>\n<li>将路由信息放到ServerWebExchange请求线程的属性里，以便整个运行随时可用。</li>\n<li>执行webHandler中的过滤器链。==（后面会介绍如何执行）==</li>\n</ol>\n<p>lookupRoute执行过程：</p>\n<ol>\n<li>通过routeLocator的获取所有配置好的路由信息。 ==（后面会介绍如何加载路由信息、过滤器、断言）==</li>\n<li>匹配每一个路由的断言，是否符合，若符合则返回对应的路由信息。若不符合则next()下一个路由的断言匹配。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Mono&lt;Route&gt; <span class=\"title\">lookupRoute</span><span class=\"params\">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.routeLocator</span><br><span class=\"line\">\t\t\t.getRoutes()</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//individually filter routes so that filterWhen error delaying is not a problem</span></span><br><span class=\"line\">\t\t\t.concatMap(route -&gt; Mono</span><br><span class=\"line\">\t\t\t\t\t.just(route)</span><br><span class=\"line\">\t\t\t\t\t.filterWhen(r -&gt; &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// add the current route we are testing</span></span><br><span class=\"line\">\t\t\t\t\t\texchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> r.getPredicate().apply(exchange);</span><br><span class=\"line\">\t\t\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//instead of immediately stopping main flux due to error, log and swallow it</span></span><br><span class=\"line\">\t\t\t\t\t.doOnError(e -&gt; logger.error(<span class=\"string\">\"Error applying predicate for route: \"</span>+route.getId(), e))</span><br><span class=\"line\">\t\t\t\t\t.onErrorResume(e -&gt; Mono.empty())</span><br><span class=\"line\">\t\t\t)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// .defaultIfEmpty() put a static Route not found</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// or .switchIfEmpty()</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// .switchIfEmpty(Mono.&lt;Route&gt;empty().log(\"noroute\"))</span></span><br><span class=\"line\">\t\t\t.next()</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//<span class=\"doctag\">TODO:</span> error handling</span></span><br><span class=\"line\">\t\t\t.map(route -&gt; &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(<span class=\"string\">\"Route matched: \"</span> + route.getId());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tvalidateRoute(route, exchange);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> route;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"问题二：如何执行Filter\"><a href=\"#问题二：如何执行Filter\" class=\"headerlink\" title=\"问题二：如何执行Filter\"></a>问题二：如何执行Filter</h3><h4 id=\"如何执行Filter-FilteringWebHandler类\"><a href=\"#如何执行Filter-FilteringWebHandler类\" class=\"headerlink\" title=\"如何执行Filter(FilteringWebHandler类)\"></a>如何执行Filter(FilteringWebHandler类)</h4><p>执行流程：</p>\n<ol>\n<li>初始化时候构造好全局的过滤器集合。</li>\n<li>合并路由上配置的过滤器与全局过滤器</li>\n<li>排序好所有过滤器传入DefaultGatewayFilterChain的责任链里执行。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Mono&lt;Void&gt; handle(ServerWebExchange exchange) &#123;</span><br><span class=\"line\">\tRoute route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);</span><br><span class=\"line\">\tList&lt;GatewayFilter&gt; gatewayFilters = route.getFilters();</span><br><span class=\"line\"></span><br><span class=\"line\">\tList&lt;GatewayFilter&gt; combined = new ArrayList&lt;&gt;(this.globalFilters);</span><br><span class=\"line\">\tcombined.addAll(gatewayFilters);</span><br><span class=\"line\">\t//TODO: needed or cached?</span><br><span class=\"line\">\tAnnotationAwareOrderComparator.sort(combined);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.debug(&quot;Sorted gatewayFilterFactories: &quot;+ combined);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn new DefaultGatewayFilterChain(combined).filter(exchange);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>责任链是一个常用的编程设计模式，它能够将请求与处理步骤解耦，请求操作对链内部的执行透明，而且每个链子都有自己具体实现，能够自由组装复用，不相互影响，使得代码更加简洁。不过责任联在调试方面相对来说比较麻烦，不便于观察等缺点。</p>\n<p>看下如何构造一个责任联，内部类DefaultGatewayFilterChain<br>的filter方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultGatewayFilterChain</span> <span class=\"keyword\">implements</span> <span class=\"title\">GatewayFilterChain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;GatewayFilter&gt; filters;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DefaultGatewayFilterChain</span><span class=\"params\">(List&lt;GatewayFilter&gt; filters)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.filters = filters;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DefaultGatewayFilterChain</span><span class=\"params\">(DefaultGatewayFilterChain parent, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.filters = parent.getFilters();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.index = index;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;GatewayFilter&gt; <span class=\"title\">getFilters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> filters;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title\">filter</span><span class=\"params\">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Mono.defer(() -&gt; &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.index &lt; filters.size()) &#123;</span><br><span class=\"line\">\t\t\t\t\tGatewayFilter filter = filters.get(<span class=\"keyword\">this</span>.index);</span><br><span class=\"line\">\t\t\t\t\tDefaultGatewayFilterChain chain = <span class=\"keyword\">new</span> DefaultGatewayFilterChain(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.index + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> filter.filter(exchange, chain);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> Mono.empty(); <span class=\"comment\">// complete</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"问题三：如何加载路由、过滤器、断言等信息\"><a href=\"#问题三：如何加载路由、过滤器、断言等信息\" class=\"headerlink\" title=\"问题三：如何加载路由、过滤器、断言等信息\"></a>问题三：如何加载路由、过滤器、断言等信息</h3><h4 id=\"RouteDefinitionRouteLocator类\"><a href=\"#RouteDefinitionRouteLocator类\" class=\"headerlink\" title=\"RouteDefinitionRouteLocator类\"></a>RouteDefinitionRouteLocator类</h4><ul>\n<li>获取路由信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Flux&lt;Route&gt; getRoutes() &#123;</span><br><span class=\"line\">\treturn this.routeDefinitionLocator.getRouteDefinitions()</span><br><span class=\"line\">\t\t\t.map(this::convertToRoute)</span><br><span class=\"line\">\t\t\t//TODO: error handling</span><br><span class=\"line\">\t\t\t.map(route -&gt; &#123;</span><br><span class=\"line\">\t\t\t\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(&quot;RouteDefinition matched: &quot; + route.getId());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\treturn route;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t/* TODO: trace logging</span><br><span class=\"line\">\t\tif (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.trace(&quot;RouteDefinition did not match: &quot; + routeDefinition.getId());</span><br><span class=\"line\">\t\t&#125;*/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>==this.routeDefinitionLocator.getRouteDefinitions()== 初始化首次加载获取配置文件中定义的路由信息并存于缓存中以便下次使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CachingRouteDefinitionLocator(RouteDefinitionLocator delegate) &#123;</span><br><span class=\"line\">\t\tthis.delegate = delegate;</span><br><span class=\"line\">\t\trouteDefinitions = CacheFlux.lookup(cache, &quot;routeDefs&quot;, RouteDefinition.class)</span><br><span class=\"line\">\t\t\t\t.onCacheMissResume(this.delegate::getRouteDefinitions);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>==convertToRoute==则是将配置信息定义的路由信息转变为真正内部使用的路由实体，具体实现如下：</p>\n<ol>\n<li>组装断言链表</li>\n<li>获取配置信息定义过滤器</li>\n<li>组装成真正路由对象Route<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Route convertToRoute(RouteDefinition routeDefinition) &#123;</span><br><span class=\"line\">\t\tAsyncPredicate&lt;ServerWebExchange&gt; predicate = combinePredicates(routeDefinition);</span><br><span class=\"line\">\t\tList&lt;GatewayFilter&gt; gatewayFilters = getFilters(routeDefinition);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn Route.async(routeDefinition)</span><br><span class=\"line\">\t\t\t\t.asyncPredicate(predicate)</span><br><span class=\"line\">\t\t\t\t.replaceFilters(gatewayFilters)</span><br><span class=\"line\">\t\t\t\t.build();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其实这段代码使用了一个设计模式就是建造者模式。该模式能将构建和实现分离开来，建造者能逐步细化而不影响其它模块功能。不过建造者对产品会依赖，当产品发生变化，建造者相应也需要改变。所以这种模式建议用在比较简化的建造者依赖类上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return Route.async(routeDefinition)</span><br><span class=\"line\">\t\t\t\t.asyncPredicate(predicate)</span><br><span class=\"line\">\t\t\t\t.replaceFilters(gatewayFilters)</span><br><span class=\"line\">\t\t\t\t.build();</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/video/Router的结构图.png\" alt=\"建造者模式\"></p>\n<p>“断言”的功能在我看来实现得是非常巧妙的，所有断言正如过滤器一样都有一个共同的父类AbstractRoutePredicateFactory，实现apply的方法。看个例子：</p>\n<p>PathRoutePredicateFactory断言类：作用是匹配请求uri资源。可以看出返回的是一个Predicate的实例，这样的好处就是在下次执行只会执行return返回的这一部分代码功能，不再需要执行配置行的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Predicate&lt;ServerWebExchange&gt; apply(Config config) &#123;</span><br><span class=\"line\">\tfinal ArrayList&lt;PathPattern&gt; pathPatterns = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\tsynchronized (this.pathPatternParser) &#123;</span><br><span class=\"line\">\t\tpathPatternParser.setMatchOptionalTrailingSeparator(config.isMatchOptionalTrailingSeparator());</span><br><span class=\"line\">\t\tconfig.getPatterns().forEach(pattern -&gt; &#123;</span><br><span class=\"line\">\t\t\tPathPattern pathPattern = this.pathPatternParser.parse(pattern);</span><br><span class=\"line\">\t\t\tpathPatterns.add(pathPattern);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn exchange -&gt; &#123;</span><br><span class=\"line\">\t\tPathContainer path = parsePath(exchange.getRequest().getURI().getPath());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tOptional&lt;PathPattern&gt; optionalPathPattern = pathPatterns.stream()</span><br><span class=\"line\">\t\t\t\t.filter(pattern -&gt; pattern.matches(path))</span><br><span class=\"line\">\t\t\t\t.findFirst();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (optionalPathPattern.isPresent()) &#123;</span><br><span class=\"line\">\t\t\tPathPattern pathPattern = optionalPathPattern.get();</span><br><span class=\"line\">\t\t\ttraceMatch(&quot;Pattern&quot;, pathPattern.getPatternString(), path, true);</span><br><span class=\"line\">\t\t\tPathMatchInfo pathMatchInfo = pathPattern.matchAndExtract(path);</span><br><span class=\"line\">\t\t\tputUriTemplateVariables(exchange, pathMatchInfo.getUriVariables());</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\ttraceMatch(&quot;Pattern&quot;, config.getPatterns(), path, false);</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后通过Flux.zip方法连成一条断言链子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private AsyncPredicate&lt;ServerWebExchange&gt; combinePredicates(RouteDefinition routeDefinition) &#123;</span><br><span class=\"line\">\tList&lt;PredicateDefinition&gt; predicates = routeDefinition.getPredicates();</span><br><span class=\"line\">\tAsyncPredicate&lt;ServerWebExchange&gt; predicate = lookup(routeDefinition, predicates.get(0));</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (PredicateDefinition andPredicate : predicates.subList(1, predicates.size())) &#123;</span><br><span class=\"line\">\t\tAsyncPredicate&lt;ServerWebExchange&gt; found = lookup(routeDefinition, andPredicate);</span><br><span class=\"line\">\t\tpredicate = predicate.and(found);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn predicate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">default AsyncPredicate&lt;T&gt; and(AsyncPredicate&lt;? super T&gt; other) &#123;</span><br><span class=\"line\">\tObjects.requireNonNull(other, &quot;other must not be null&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn t -&gt; Flux.zip(apply(t), other.apply(t))</span><br><span class=\"line\">\t\t\t.map(tuple -&gt; tuple.getT1() &amp;&amp; tuple.getT2());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>其实到这里这一章就差不多了，基本上Gateway的主要总体框架功能就这些。这一次的阅读源码能够使我对lambda表达式的用处更深刻，而且，对这种响应式流的理解更进一步了，后续还会持续学习关于netty reactor的用法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>这一章开始记录我开始Gateway阅读之路，看下究竟是如何实现网关。</p>\n<h1 id=\"个人疑问\"><a href=\"#个人疑问\" class=\"headerlink\" title=\"个人疑问\"></a>个人疑问</h1><ol>\n<li><p>Gateway的网关框架是如何接收请求并转发</p>\n</li>\n<li><p>如何执行Filter</p>\n</li>\n<li><p>如何加载路由、过滤器、断言等信息</p>\n</li>\n</ol>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactI&gt;</span><br><span class=\"line\">\t&lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"架构图\"><a href=\"#架构图\" class=\"headerlink\" title=\"架构图\"></a>架构图</h2><p>还是一样的图<br><img src=\"/images/video/gateway网关图.png\" alt=\"Gateway框架\"></p>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h2><p>gateway-core.jar是gateway的核心包，主要的实现都在里面。阅读代码前最好先知道个个包的主要功能.</p>\n<p><img src=\"/images/video/gateway的jar包架构图.png\" alt=\"包组成\"></p>\n<ul>\n<li>actuate</li>\n</ul>\n<p>该包主要是gateway自带的一个控制器GatewayControllerEndpoint，该endpiont提供了关于filter及routes的信息查询以及指定route信息更新的rest api，这给web界面提供管理配置功能提供了极大的便利</p>\n<ul>\n<li>config</li>\n</ul>\n<p>该包主要是Gateway的配置实体类，譬如yml上面的配置GatewayProperties、全局的跨域配置GlobalCorsProperties等等。</p>\n<ul>\n<li>discovery</li>\n</ul>\n<p>该包主要是实现服务发现的功能。从服务注册中心获取服务注册信息，然后配置相应的路由</p>\n<ul>\n<li>event</li>\n</ul>\n<p>该包是一些发布事件的定义。</p>\n<ul>\n<li>filter</li>\n</ul>\n<p>该包包含了gateway所有内置的过滤器。</p>\n<ul>\n<li>handler</li>\n</ul>\n<p>该包主要包括了所有内置的Predicates断言，RoutePredicateHandlerMapping类是一个实现了将接收请求到转发到filter里面的功能，FilteringWebHandler主要是构造过滤器链。</p>\n<ul>\n<li>route</li>\n</ul>\n<p>该包主要是定义路由信息，构造路由等。</p>\n<ul>\n<li>support</li>\n</ul>\n<p>该包主要是一些工具方法。用于全局。</p>\n<h2 id=\"源码分析-1\"><a href=\"#源码分析-1\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"问题一：如何转发请求\"><a href=\"#问题一：如何转发请求\" class=\"headerlink\" title=\"问题一：如何转发请求\"></a>问题一：如何转发请求</h3><h4 id=\"DispatchHandler类\"><a href=\"#DispatchHandler类\" class=\"headerlink\" title=\"DispatchHandler类\"></a>DispatchHandler类</h4><p>WebFlux请求转发核心类：DispatchHandler</p>\n<p>DispatchHandler内部主要的私有字段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;HandlerResultHandler&gt; resultHandlers;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HandlerMapping</td>\n<td>映射请求到一个处理器。该映射是基于一定的标准、细节因不同HandlerMapping而不同。<br>例如有注解控制器, 简单URL匹配映射等等。<br>主要的HandlerMapping实现：<br>1.有RequestMappingHandlerMapping对于注解的@RequestMapping。<br>2.RouterFunctionMapping 对应于函数式端点路由。<br>3.SimpleUrlHandlerMappingURI路径模式的显式注册。<br>4.WebHandler的实例</td>\n</tr>\n<tr>\n<td>HandlerAdapter</td>\n<td>帮助DispatcherHandler调用映射的请求的处理器，而不管该处理程序实际上是如何调用的。<br>例如执行一个注解控制器需要解释注解。其主要目的是帮助DispatcherHandler隐藏实现的细节。</td>\n</tr>\n<tr>\n<td>HandlerResultHandler</td>\n<td>处理程序调用的结果并最后确定响应。<br>1.ResponseEntityResultHandler：ResponseEntity，处理@Controller实例。<br>2.ServerResponseResultHandler：ServerResponse，处理函数式端点。<br>3.ResponseBodyResultHandler：处理从@ResponseBody方法和@RestController类的返回值。<br>4.ViewResolutionResultHandler：处理成CharSequence,View, Model, Map, Rendering等其他的模型属性。</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title\">handle</span><span class=\"params\">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.handlerMappings == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Mono.error(HANDLER_NOT_FOUND_EXCEPTION);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Flux.fromIterable(<span class=\"keyword\">this</span>.handlerMappings)</span><br><span class=\"line\">\t\t\t.concatMap(mapping -&gt; mapping.getHandler(exchange))</span><br><span class=\"line\">\t\t\t.next()</span><br><span class=\"line\">\t\t\t.switchIfEmpty(Mono.error(HANDLER_NOT_FOUND_EXCEPTION))</span><br><span class=\"line\">\t\t\t.flatMap(handler -&gt; invokeHandler(exchange, handler))</span><br><span class=\"line\">\t\t\t.flatMap(result -&gt; handleResult(exchange, result));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>核心方法主要做了三个步骤：</p>\n<ol>\n<li>匹配每一个不同HandlerMapping，使用首先匹配的那个。</li>\n<li>执行器被找到就会找到对应的HandlerAdapter,然后就会将返回结果返回到HandlerResult里。</li>\n<li>HandlerResult会给出一个合适的处理器去完成直接写到响应里面或者使用View来渲染的处理。</li>\n</ol>\n<h4 id=\"RoutePredicateHandlerMapping类\"><a href=\"#RoutePredicateHandlerMapping类\" class=\"headerlink\" title=\"RoutePredicateHandlerMapping类\"></a>RoutePredicateHandlerMapping类</h4><p>刚说完DispatchHandler的类，就到HandlerMapping了，类RoutePredicateHandlerMapping实现了HandlerMapping。</p>\n<p>其核心私有字段分别有：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FilteringWebHandler webHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RouteLocator routeLocator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Integer managmentPort;</span><br></pre></td></tr></table></figure></p>\n<table>\n<thead>\n<tr>\n<th>Bean类型</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>webHandler</td>\n<td>构建过滤器的责任链</td>\n</tr>\n<tr>\n<td>routeLocator</td>\n<td>路由的定义信息</td>\n</tr>\n<tr>\n<td>managmentPort</td>\n<td>gateway管理端口</td>\n</tr>\n</tbody>\n</table>\n<p>其核心方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Mono&lt;?&gt; getHandlerInternal(ServerWebExchange exchange) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// don't handle requests on the management port if set</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (managmentPort != <span class=\"keyword\">null</span> &amp;&amp; exchange.getRequest().getURI().getPort() == managmentPort.intValue()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Mono.empty();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\texchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lookupRoute(exchange)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// .log(\"route-predicate-handler-mapping\", Level.FINER) //name this</span></span><br><span class=\"line\">\t\t\t.flatMap((Function&lt;Route, Mono&lt;?&gt;&gt;) r -&gt; &#123;</span><br><span class=\"line\">\t\t\t\texchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(<span class=\"string\">\"Mapping [\"</span> + getExchangeDesc(exchange) + <span class=\"string\">\"] to \"</span> + r);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\texchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> Mono.just(webHandler);</span><br><span class=\"line\">\t\t\t&#125;).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class=\"line\">\t\t\t\texchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.trace(<span class=\"string\">\"No RouteDefinition found for [\"</span> + getExchangeDesc(exchange) + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该核心方法做了几件事：</p>\n<ol>\n<li>找到合适的路由lookupRoute方法。</li>\n<li>将路由信息放到ServerWebExchange请求线程的属性里，以便整个运行随时可用。</li>\n<li>执行webHandler中的过滤器链。==（后面会介绍如何执行）==</li>\n</ol>\n<p>lookupRoute执行过程：</p>\n<ol>\n<li>通过routeLocator的获取所有配置好的路由信息。 ==（后面会介绍如何加载路由信息、过滤器、断言）==</li>\n<li>匹配每一个路由的断言，是否符合，若符合则返回对应的路由信息。若不符合则next()下一个路由的断言匹配。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Mono&lt;Route&gt; <span class=\"title\">lookupRoute</span><span class=\"params\">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.routeLocator</span><br><span class=\"line\">\t\t\t.getRoutes()</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//individually filter routes so that filterWhen error delaying is not a problem</span></span><br><span class=\"line\">\t\t\t.concatMap(route -&gt; Mono</span><br><span class=\"line\">\t\t\t\t\t.just(route)</span><br><span class=\"line\">\t\t\t\t\t.filterWhen(r -&gt; &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// add the current route we are testing</span></span><br><span class=\"line\">\t\t\t\t\t\texchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> r.getPredicate().apply(exchange);</span><br><span class=\"line\">\t\t\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//instead of immediately stopping main flux due to error, log and swallow it</span></span><br><span class=\"line\">\t\t\t\t\t.doOnError(e -&gt; logger.error(<span class=\"string\">\"Error applying predicate for route: \"</span>+route.getId(), e))</span><br><span class=\"line\">\t\t\t\t\t.onErrorResume(e -&gt; Mono.empty())</span><br><span class=\"line\">\t\t\t)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// .defaultIfEmpty() put a static Route not found</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// or .switchIfEmpty()</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// .switchIfEmpty(Mono.&lt;Route&gt;empty().log(\"noroute\"))</span></span><br><span class=\"line\">\t\t\t.next()</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//<span class=\"doctag\">TODO:</span> error handling</span></span><br><span class=\"line\">\t\t\t.map(route -&gt; &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(<span class=\"string\">\"Route matched: \"</span> + route.getId());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tvalidateRoute(route, exchange);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> route;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"问题二：如何执行Filter\"><a href=\"#问题二：如何执行Filter\" class=\"headerlink\" title=\"问题二：如何执行Filter\"></a>问题二：如何执行Filter</h3><h4 id=\"如何执行Filter-FilteringWebHandler类\"><a href=\"#如何执行Filter-FilteringWebHandler类\" class=\"headerlink\" title=\"如何执行Filter(FilteringWebHandler类)\"></a>如何执行Filter(FilteringWebHandler类)</h4><p>执行流程：</p>\n<ol>\n<li>初始化时候构造好全局的过滤器集合。</li>\n<li>合并路由上配置的过滤器与全局过滤器</li>\n<li>排序好所有过滤器传入DefaultGatewayFilterChain的责任链里执行。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Mono&lt;Void&gt; handle(ServerWebExchange exchange) &#123;</span><br><span class=\"line\">\tRoute route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);</span><br><span class=\"line\">\tList&lt;GatewayFilter&gt; gatewayFilters = route.getFilters();</span><br><span class=\"line\"></span><br><span class=\"line\">\tList&lt;GatewayFilter&gt; combined = new ArrayList&lt;&gt;(this.globalFilters);</span><br><span class=\"line\">\tcombined.addAll(gatewayFilters);</span><br><span class=\"line\">\t//TODO: needed or cached?</span><br><span class=\"line\">\tAnnotationAwareOrderComparator.sort(combined);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.debug(&quot;Sorted gatewayFilterFactories: &quot;+ combined);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn new DefaultGatewayFilterChain(combined).filter(exchange);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>责任链是一个常用的编程设计模式，它能够将请求与处理步骤解耦，请求操作对链内部的执行透明，而且每个链子都有自己具体实现，能够自由组装复用，不相互影响，使得代码更加简洁。不过责任联在调试方面相对来说比较麻烦，不便于观察等缺点。</p>\n<p>看下如何构造一个责任联，内部类DefaultGatewayFilterChain<br>的filter方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultGatewayFilterChain</span> <span class=\"keyword\">implements</span> <span class=\"title\">GatewayFilterChain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;GatewayFilter&gt; filters;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DefaultGatewayFilterChain</span><span class=\"params\">(List&lt;GatewayFilter&gt; filters)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.filters = filters;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DefaultGatewayFilterChain</span><span class=\"params\">(DefaultGatewayFilterChain parent, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.filters = parent.getFilters();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.index = index;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;GatewayFilter&gt; <span class=\"title\">getFilters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> filters;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title\">filter</span><span class=\"params\">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Mono.defer(() -&gt; &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.index &lt; filters.size()) &#123;</span><br><span class=\"line\">\t\t\t\t\tGatewayFilter filter = filters.get(<span class=\"keyword\">this</span>.index);</span><br><span class=\"line\">\t\t\t\t\tDefaultGatewayFilterChain chain = <span class=\"keyword\">new</span> DefaultGatewayFilterChain(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.index + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> filter.filter(exchange, chain);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> Mono.empty(); <span class=\"comment\">// complete</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"问题三：如何加载路由、过滤器、断言等信息\"><a href=\"#问题三：如何加载路由、过滤器、断言等信息\" class=\"headerlink\" title=\"问题三：如何加载路由、过滤器、断言等信息\"></a>问题三：如何加载路由、过滤器、断言等信息</h3><h4 id=\"RouteDefinitionRouteLocator类\"><a href=\"#RouteDefinitionRouteLocator类\" class=\"headerlink\" title=\"RouteDefinitionRouteLocator类\"></a>RouteDefinitionRouteLocator类</h4><ul>\n<li>获取路由信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Flux&lt;Route&gt; getRoutes() &#123;</span><br><span class=\"line\">\treturn this.routeDefinitionLocator.getRouteDefinitions()</span><br><span class=\"line\">\t\t\t.map(this::convertToRoute)</span><br><span class=\"line\">\t\t\t//TODO: error handling</span><br><span class=\"line\">\t\t\t.map(route -&gt; &#123;</span><br><span class=\"line\">\t\t\t\tif (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(&quot;RouteDefinition matched: &quot; + route.getId());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\treturn route;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t/* TODO: trace logging</span><br><span class=\"line\">\t\tif (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.trace(&quot;RouteDefinition did not match: &quot; + routeDefinition.getId());</span><br><span class=\"line\">\t\t&#125;*/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>==this.routeDefinitionLocator.getRouteDefinitions()== 初始化首次加载获取配置文件中定义的路由信息并存于缓存中以便下次使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CachingRouteDefinitionLocator(RouteDefinitionLocator delegate) &#123;</span><br><span class=\"line\">\t\tthis.delegate = delegate;</span><br><span class=\"line\">\t\trouteDefinitions = CacheFlux.lookup(cache, &quot;routeDefs&quot;, RouteDefinition.class)</span><br><span class=\"line\">\t\t\t\t.onCacheMissResume(this.delegate::getRouteDefinitions);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>==convertToRoute==则是将配置信息定义的路由信息转变为真正内部使用的路由实体，具体实现如下：</p>\n<ol>\n<li>组装断言链表</li>\n<li>获取配置信息定义过滤器</li>\n<li>组装成真正路由对象Route<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Route convertToRoute(RouteDefinition routeDefinition) &#123;</span><br><span class=\"line\">\t\tAsyncPredicate&lt;ServerWebExchange&gt; predicate = combinePredicates(routeDefinition);</span><br><span class=\"line\">\t\tList&lt;GatewayFilter&gt; gatewayFilters = getFilters(routeDefinition);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn Route.async(routeDefinition)</span><br><span class=\"line\">\t\t\t\t.asyncPredicate(predicate)</span><br><span class=\"line\">\t\t\t\t.replaceFilters(gatewayFilters)</span><br><span class=\"line\">\t\t\t\t.build();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其实这段代码使用了一个设计模式就是建造者模式。该模式能将构建和实现分离开来，建造者能逐步细化而不影响其它模块功能。不过建造者对产品会依赖，当产品发生变化，建造者相应也需要改变。所以这种模式建议用在比较简化的建造者依赖类上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return Route.async(routeDefinition)</span><br><span class=\"line\">\t\t\t\t.asyncPredicate(predicate)</span><br><span class=\"line\">\t\t\t\t.replaceFilters(gatewayFilters)</span><br><span class=\"line\">\t\t\t\t.build();</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/video/Router的结构图.png\" alt=\"建造者模式\"></p>\n<p>“断言”的功能在我看来实现得是非常巧妙的，所有断言正如过滤器一样都有一个共同的父类AbstractRoutePredicateFactory，实现apply的方法。看个例子：</p>\n<p>PathRoutePredicateFactory断言类：作用是匹配请求uri资源。可以看出返回的是一个Predicate的实例，这样的好处就是在下次执行只会执行return返回的这一部分代码功能，不再需要执行配置行的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public Predicate&lt;ServerWebExchange&gt; apply(Config config) &#123;</span><br><span class=\"line\">\tfinal ArrayList&lt;PathPattern&gt; pathPatterns = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\tsynchronized (this.pathPatternParser) &#123;</span><br><span class=\"line\">\t\tpathPatternParser.setMatchOptionalTrailingSeparator(config.isMatchOptionalTrailingSeparator());</span><br><span class=\"line\">\t\tconfig.getPatterns().forEach(pattern -&gt; &#123;</span><br><span class=\"line\">\t\t\tPathPattern pathPattern = this.pathPatternParser.parse(pattern);</span><br><span class=\"line\">\t\t\tpathPatterns.add(pathPattern);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn exchange -&gt; &#123;</span><br><span class=\"line\">\t\tPathContainer path = parsePath(exchange.getRequest().getURI().getPath());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tOptional&lt;PathPattern&gt; optionalPathPattern = pathPatterns.stream()</span><br><span class=\"line\">\t\t\t\t.filter(pattern -&gt; pattern.matches(path))</span><br><span class=\"line\">\t\t\t\t.findFirst();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (optionalPathPattern.isPresent()) &#123;</span><br><span class=\"line\">\t\t\tPathPattern pathPattern = optionalPathPattern.get();</span><br><span class=\"line\">\t\t\ttraceMatch(&quot;Pattern&quot;, pathPattern.getPatternString(), path, true);</span><br><span class=\"line\">\t\t\tPathMatchInfo pathMatchInfo = pathPattern.matchAndExtract(path);</span><br><span class=\"line\">\t\t\tputUriTemplateVariables(exchange, pathMatchInfo.getUriVariables());</span><br><span class=\"line\">\t\t\treturn true;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\ttraceMatch(&quot;Pattern&quot;, config.getPatterns(), path, false);</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后通过Flux.zip方法连成一条断言链子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private AsyncPredicate&lt;ServerWebExchange&gt; combinePredicates(RouteDefinition routeDefinition) &#123;</span><br><span class=\"line\">\tList&lt;PredicateDefinition&gt; predicates = routeDefinition.getPredicates();</span><br><span class=\"line\">\tAsyncPredicate&lt;ServerWebExchange&gt; predicate = lookup(routeDefinition, predicates.get(0));</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (PredicateDefinition andPredicate : predicates.subList(1, predicates.size())) &#123;</span><br><span class=\"line\">\t\tAsyncPredicate&lt;ServerWebExchange&gt; found = lookup(routeDefinition, andPredicate);</span><br><span class=\"line\">\t\tpredicate = predicate.and(found);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn predicate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">---------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">default AsyncPredicate&lt;T&gt; and(AsyncPredicate&lt;? super T&gt; other) &#123;</span><br><span class=\"line\">\tObjects.requireNonNull(other, &quot;other must not be null&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn t -&gt; Flux.zip(apply(t), other.apply(t))</span><br><span class=\"line\">\t\t\t.map(tuple -&gt; tuple.getT1() &amp;&amp; tuple.getT2());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>其实到这里这一章就差不多了，基本上Gateway的主要总体框架功能就这些。这一次的阅读源码能够使我对lambda表达式的用处更深刻，而且，对这种响应式流的理解更进一步了，后续还会持续学习关于netty reactor的用法。</p>\n"},{"title":"Gateway源码分析（一）","date":"2021-07-25T03:16:39.000Z","_content":"\n## 背景\n\n当选用了SpringCloud Gateway作为视频项目的网关之后,出于学习的心态，看下视频网关是如何构造起来的。\n\n\n## Spring WebFlux学习\n\n阅读源码之前首先学习下WebFlux基础概念和相关常用的API\n\nSpring WebFlux简单说是与Spring MVC类似的一门响应式异步非阻塞Web端控制框架。与Spring MVC有着相同功能的注解\n\n1. 什么是响应式编程(Reactive)\n\n官方解释：\n>The term, “reactive,”  refers to programming models that are built around reacting to change\n响应式编程是一种围绕对变化作出反应而构建的编程模型。\n\n后面给出了例子：\n>network components reacting to I/O events, UI controllers reacting to mouse events, and others. In that sense, non-blocking is reactive, because, instead of being blocked, we are now in the mode of reacting to notifications as operations complete or data becomes available.\n网络组件对IO事件的响应，UI控制器对鼠标事件的响应。从这个意义上说，非阻塞也是响应式,因为我们现在也是在操作完成或者数据可用的时候作出响应的模式，而不是被阻塞。\n\n2. 什么是背压（back pressure）\n\n官方解析：\n>Reactive Streams is a small spec (also adopted in Java 9) that defines the interaction between asynchronous components with back pressure. For example a data repository (acting as Publisher) can produce data that an HTTP server (acting as Subscriber) can then write to the response. The main purpose of Reactive Streams is to let the subscriber control how quickly or how slowly the publisher produces data.\n响应式流是一个小小的规范，定义了带有背压异步组件交互。例如，数据仓库（作为发布者）产生数据使HTTP服务（作为订阅者）能响应。主要目的就是响应式能让订阅者控制发布者发布数据的快与慢。\n\n其实上述说白了就是订阅者能够通过生产者需要多小数据，这样能够以免生产者无限量产生数据压垮订阅者。\n\n3. SpringMVC与WebFlux选择\n![webFlux&SpringMVC](https://docs.spring.io/spring-framework/docs/current/reference/html/images/spring-mvc-and-webflux-venn.png)\n\n- 如果您有运行正常的Spring MVC应用程序，则无需更改。命令式编程是编写，理解和调试代码的最简单方法。您有最大的库选择空间，因为从历史上看，大多数库都是阻塞的。\n\n- 如果您已经在选择无阻塞的Web堆栈，Spring WebFlux可以提供与该领域其他服务器相同的执行模型优势，还可以选择服务器（Netty，Tomcat，Jetty，Undertow和Servlet 3.1+容器），选择编程模型（带注释的控制器和功能性Web端点），以及选择反应式库（Reactor，RxJava或其他）。\n\n- 如果您对与Java 8 lambda或Kotlin一起使用的轻量级功能性Web框架感兴趣，则可以使用Spring WebFlux功能性Web端点。对于要求较低复杂性的较小应用程序或微服务（可以受益于更高的透明度和控制）而言，这也是一个不错的选择。\n\n- 在微服务架构中，您可以混合使用带有Spring MVC或Spring WebFlux控制器或带有Spring WebFlux功能端点的应用程序。在两个框架中都支持相同的基于注释的编程模型，这使得重用知识变得更加容易，同时还为正确的工作选择了正确的工具。\n\n- 评估应用程序的一种简单方法是检查其依赖关系。如果您要使用阻塞性持久性API（JPA，JDBC）或网络API，则Spring MVC至少是通用体系结构的最佳选择。使用Reactor和RxJava在单独的线程上执行阻塞调用在技术上是可行的，但您不会充分利用非阻塞Web堆栈。\n\n- 如果您的Spring MVC应用程序具有对远程服务的调用，请尝试使用active WebClient。您可以直接从Spring MVC控制器方法返回反应类型（Reactor，RxJava或其他）。每个呼叫的等待时间或呼叫之间的相互依赖性越大，好处就越明显。Spring MVC控制器也可以调用其他反应式组件。\n\n\n\n4. WebFlux提供了两种模型\n- 注解控制器（Annotated Controllers）：与Spring MVC有一致的注解，都是基于spring-web模型。一个显著的区别是，WebFlux也支持响应式@RequestBody参数。\n- 函数终端（Functional Endpoints）：基于Lambda,轻量级和函数编程模型。提供了大量的方法来路由和处理请求。与注解控制器（Annotated Controllers）最大区别就是函数端模型能够负责请求的从头到尾的处理而不是只是通过声明注解然后回调。\n\n\n### API\n\n两个Publisher接口：Flux与Mono。两者区别在于Flux是代表多个元素的发布者，Mono是单个元素的发布者.\n\nMono 实现了 Publisher 接口，\n```\nempty()：创建一个不包含任何元素，只发布结束消息的序列。\njust()：可以指定序列中包含的全部元素。创建出来的 Mono序列在发布这些元素之后会自动结束。\njustOrEmpty()：从一个 Optional 对象或可能为 null 的对象中创建 Mono。只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。\nerror(Throwable error)：创建一个只包含错误消息的序列。\nnever()：创建一个不包含任何消息通知的序列。\nfromCallable()、fromCompletionStage()、fromFuture()、fromRunnable()和 fromSupplier()：分别从 Callable、CompletionStage、CompletableFuture、Runnable 和 Supplier 中创建 Mono。\ndelay(Duration duration)和 delayMillis(long duration)：创建一个 Mono 序列，在指定的延迟时间之后，产生数字 0 作为唯一值。\ncreate()：通过 create()方法来使用 MonoSink 来创建 Mono。\n```\n\nFlux\n```\njust：可以指定序列中包含的全部元素。创建出来的 Flux 序列在发布这些元素之后会自动结束。\nfromArray、fromIterable、fromStream：可以从一个数组、Iterable 对象或 Stream 对象中创建 Flux 对象。\nempty()：创建一个不包含任何元素，只发布结束消息的序列,在响应式编程中，流的传递是基于元素的，empty表示没有任何元素，所以不会进行后续传递，需要用switchIfEmpty等处理\nerror(Throwable error)：创建一个只包含错误消息的序列。\nnever()：创建一个不包含任何消息通知的序列。使用示例：\nrange(int start, int count)：创建包含从 start 起始的 count 个数量的 Integer 对象的序列。\nintervalMillis(long period)： interval()方法的作用相同，只不过该方法通过毫秒数来指定时间间隔和延迟时间。\ncreate()：与 generate()方法的不同之处在于所使用的是 FluxSink 对象。FluxSink 支持同步和异步的消息产生，并且可以在一次调用中产生多个元素。\n```\n\n## 总结\n\n这一章主要是简单记录下WebFlux的介绍以及简单说明下WebFlux相关的几个概念。WebFlux的官方文档还是相对比较完善的，里面都有挺详细的说明，我就不一一照搬到这里。下一章就开始阅读Gateway的代码，看下Gateway里面是如何使用WebFlux构建网关。\n\n\n\n## 参考\n\n- [webFlux官网](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#spring-webflux)\n\n\n- [外行人都能看得懂的WebFlux](https://zhuanlan.zhihu.com/p/92460075)\n\n\n- [最近学到的Lambda表达式基础知识](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247485692&idx=1&sn=a6b3f040b13fa2324992b11a927e34dc&chksm=ebd749fddca0c0eb1b05c08ede7ee4a44699584fbc0c3449ec2cac7642fd13819470ec7f44d8&token=1024331018&lang=zh_CN#rd)\n\n\n","source":"_posts/gateway源码分析(一).md","raw":"---\ntitle: Gateway源码分析（一）\ndate: 2021-07-25 11:16:39\ncategories: \n- 视频\ntags:\n- 视频\n---\n\n## 背景\n\n当选用了SpringCloud Gateway作为视频项目的网关之后,出于学习的心态，看下视频网关是如何构造起来的。\n\n\n## Spring WebFlux学习\n\n阅读源码之前首先学习下WebFlux基础概念和相关常用的API\n\nSpring WebFlux简单说是与Spring MVC类似的一门响应式异步非阻塞Web端控制框架。与Spring MVC有着相同功能的注解\n\n1. 什么是响应式编程(Reactive)\n\n官方解释：\n>The term, “reactive,”  refers to programming models that are built around reacting to change\n响应式编程是一种围绕对变化作出反应而构建的编程模型。\n\n后面给出了例子：\n>network components reacting to I/O events, UI controllers reacting to mouse events, and others. In that sense, non-blocking is reactive, because, instead of being blocked, we are now in the mode of reacting to notifications as operations complete or data becomes available.\n网络组件对IO事件的响应，UI控制器对鼠标事件的响应。从这个意义上说，非阻塞也是响应式,因为我们现在也是在操作完成或者数据可用的时候作出响应的模式，而不是被阻塞。\n\n2. 什么是背压（back pressure）\n\n官方解析：\n>Reactive Streams is a small spec (also adopted in Java 9) that defines the interaction between asynchronous components with back pressure. For example a data repository (acting as Publisher) can produce data that an HTTP server (acting as Subscriber) can then write to the response. The main purpose of Reactive Streams is to let the subscriber control how quickly or how slowly the publisher produces data.\n响应式流是一个小小的规范，定义了带有背压异步组件交互。例如，数据仓库（作为发布者）产生数据使HTTP服务（作为订阅者）能响应。主要目的就是响应式能让订阅者控制发布者发布数据的快与慢。\n\n其实上述说白了就是订阅者能够通过生产者需要多小数据，这样能够以免生产者无限量产生数据压垮订阅者。\n\n3. SpringMVC与WebFlux选择\n![webFlux&SpringMVC](https://docs.spring.io/spring-framework/docs/current/reference/html/images/spring-mvc-and-webflux-venn.png)\n\n- 如果您有运行正常的Spring MVC应用程序，则无需更改。命令式编程是编写，理解和调试代码的最简单方法。您有最大的库选择空间，因为从历史上看，大多数库都是阻塞的。\n\n- 如果您已经在选择无阻塞的Web堆栈，Spring WebFlux可以提供与该领域其他服务器相同的执行模型优势，还可以选择服务器（Netty，Tomcat，Jetty，Undertow和Servlet 3.1+容器），选择编程模型（带注释的控制器和功能性Web端点），以及选择反应式库（Reactor，RxJava或其他）。\n\n- 如果您对与Java 8 lambda或Kotlin一起使用的轻量级功能性Web框架感兴趣，则可以使用Spring WebFlux功能性Web端点。对于要求较低复杂性的较小应用程序或微服务（可以受益于更高的透明度和控制）而言，这也是一个不错的选择。\n\n- 在微服务架构中，您可以混合使用带有Spring MVC或Spring WebFlux控制器或带有Spring WebFlux功能端点的应用程序。在两个框架中都支持相同的基于注释的编程模型，这使得重用知识变得更加容易，同时还为正确的工作选择了正确的工具。\n\n- 评估应用程序的一种简单方法是检查其依赖关系。如果您要使用阻塞性持久性API（JPA，JDBC）或网络API，则Spring MVC至少是通用体系结构的最佳选择。使用Reactor和RxJava在单独的线程上执行阻塞调用在技术上是可行的，但您不会充分利用非阻塞Web堆栈。\n\n- 如果您的Spring MVC应用程序具有对远程服务的调用，请尝试使用active WebClient。您可以直接从Spring MVC控制器方法返回反应类型（Reactor，RxJava或其他）。每个呼叫的等待时间或呼叫之间的相互依赖性越大，好处就越明显。Spring MVC控制器也可以调用其他反应式组件。\n\n\n\n4. WebFlux提供了两种模型\n- 注解控制器（Annotated Controllers）：与Spring MVC有一致的注解，都是基于spring-web模型。一个显著的区别是，WebFlux也支持响应式@RequestBody参数。\n- 函数终端（Functional Endpoints）：基于Lambda,轻量级和函数编程模型。提供了大量的方法来路由和处理请求。与注解控制器（Annotated Controllers）最大区别就是函数端模型能够负责请求的从头到尾的处理而不是只是通过声明注解然后回调。\n\n\n### API\n\n两个Publisher接口：Flux与Mono。两者区别在于Flux是代表多个元素的发布者，Mono是单个元素的发布者.\n\nMono 实现了 Publisher 接口，\n```\nempty()：创建一个不包含任何元素，只发布结束消息的序列。\njust()：可以指定序列中包含的全部元素。创建出来的 Mono序列在发布这些元素之后会自动结束。\njustOrEmpty()：从一个 Optional 对象或可能为 null 的对象中创建 Mono。只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。\nerror(Throwable error)：创建一个只包含错误消息的序列。\nnever()：创建一个不包含任何消息通知的序列。\nfromCallable()、fromCompletionStage()、fromFuture()、fromRunnable()和 fromSupplier()：分别从 Callable、CompletionStage、CompletableFuture、Runnable 和 Supplier 中创建 Mono。\ndelay(Duration duration)和 delayMillis(long duration)：创建一个 Mono 序列，在指定的延迟时间之后，产生数字 0 作为唯一值。\ncreate()：通过 create()方法来使用 MonoSink 来创建 Mono。\n```\n\nFlux\n```\njust：可以指定序列中包含的全部元素。创建出来的 Flux 序列在发布这些元素之后会自动结束。\nfromArray、fromIterable、fromStream：可以从一个数组、Iterable 对象或 Stream 对象中创建 Flux 对象。\nempty()：创建一个不包含任何元素，只发布结束消息的序列,在响应式编程中，流的传递是基于元素的，empty表示没有任何元素，所以不会进行后续传递，需要用switchIfEmpty等处理\nerror(Throwable error)：创建一个只包含错误消息的序列。\nnever()：创建一个不包含任何消息通知的序列。使用示例：\nrange(int start, int count)：创建包含从 start 起始的 count 个数量的 Integer 对象的序列。\nintervalMillis(long period)： interval()方法的作用相同，只不过该方法通过毫秒数来指定时间间隔和延迟时间。\ncreate()：与 generate()方法的不同之处在于所使用的是 FluxSink 对象。FluxSink 支持同步和异步的消息产生，并且可以在一次调用中产生多个元素。\n```\n\n## 总结\n\n这一章主要是简单记录下WebFlux的介绍以及简单说明下WebFlux相关的几个概念。WebFlux的官方文档还是相对比较完善的，里面都有挺详细的说明，我就不一一照搬到这里。下一章就开始阅读Gateway的代码，看下Gateway里面是如何使用WebFlux构建网关。\n\n\n\n## 参考\n\n- [webFlux官网](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#spring-webflux)\n\n\n- [外行人都能看得懂的WebFlux](https://zhuanlan.zhihu.com/p/92460075)\n\n\n- [最近学到的Lambda表达式基础知识](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247485692&idx=1&sn=a6b3f040b13fa2324992b11a927e34dc&chksm=ebd749fddca0c0eb1b05c08ede7ee4a44699584fbc0c3449ec2cac7642fd13819470ec7f44d8&token=1024331018&lang=zh_CN#rd)\n\n\n","slug":"gateway源码分析(一)","published":1,"updated":"2021-09-07T08:00:52.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhra0008d0tvdg5q9lxo","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>当选用了SpringCloud Gateway作为视频项目的网关之后,出于学习的心态，看下视频网关是如何构造起来的。</p>\n<h2 id=\"Spring-WebFlux学习\"><a href=\"#Spring-WebFlux学习\" class=\"headerlink\" title=\"Spring WebFlux学习\"></a>Spring WebFlux学习</h2><p>阅读源码之前首先学习下WebFlux基础概念和相关常用的API</p>\n<p>Spring WebFlux简单说是与Spring MVC类似的一门响应式异步非阻塞Web端控制框架。与Spring MVC有着相同功能的注解</p>\n<ol>\n<li>什么是响应式编程(Reactive)</li>\n</ol>\n<p>官方解释：</p>\n<blockquote>\n<p>The term, “reactive,”  refers to programming models that are built around reacting to change<br>响应式编程是一种围绕对变化作出反应而构建的编程模型。</p>\n</blockquote>\n<p>后面给出了例子：</p>\n<blockquote>\n<p>network components reacting to I/O events, UI controllers reacting to mouse events, and others. In that sense, non-blocking is reactive, because, instead of being blocked, we are now in the mode of reacting to notifications as operations complete or data becomes available.<br>网络组件对IO事件的响应，UI控制器对鼠标事件的响应。从这个意义上说，非阻塞也是响应式,因为我们现在也是在操作完成或者数据可用的时候作出响应的模式，而不是被阻塞。</p>\n</blockquote>\n<ol>\n<li>什么是背压（back pressure）</li>\n</ol>\n<p>官方解析：</p>\n<blockquote>\n<p>Reactive Streams is a small spec (also adopted in Java 9) that defines the interaction between asynchronous components with back pressure. For example a data repository (acting as Publisher) can produce data that an HTTP server (acting as Subscriber) can then write to the response. The main purpose of Reactive Streams is to let the subscriber control how quickly or how slowly the publisher produces data.<br>响应式流是一个小小的规范，定义了带有背压异步组件交互。例如，数据仓库（作为发布者）产生数据使HTTP服务（作为订阅者）能响应。主要目的就是响应式能让订阅者控制发布者发布数据的快与慢。</p>\n</blockquote>\n<p>其实上述说白了就是订阅者能够通过生产者需要多小数据，这样能够以免生产者无限量产生数据压垮订阅者。</p>\n<ol>\n<li>SpringMVC与WebFlux选择<br><img src=\"https://docs.spring.io/spring-framework/docs/current/reference/html/images/spring-mvc-and-webflux-venn.png\" alt=\"webFlux&amp;SpringMVC\"></li>\n</ol>\n<ul>\n<li><p>如果您有运行正常的Spring MVC应用程序，则无需更改。命令式编程是编写，理解和调试代码的最简单方法。您有最大的库选择空间，因为从历史上看，大多数库都是阻塞的。</p>\n</li>\n<li><p>如果您已经在选择无阻塞的Web堆栈，Spring WebFlux可以提供与该领域其他服务器相同的执行模型优势，还可以选择服务器（Netty，Tomcat，Jetty，Undertow和Servlet 3.1+容器），选择编程模型（带注释的控制器和功能性Web端点），以及选择反应式库（Reactor，RxJava或其他）。</p>\n</li>\n<li><p>如果您对与Java 8 lambda或Kotlin一起使用的轻量级功能性Web框架感兴趣，则可以使用Spring WebFlux功能性Web端点。对于要求较低复杂性的较小应用程序或微服务（可以受益于更高的透明度和控制）而言，这也是一个不错的选择。</p>\n</li>\n<li><p>在微服务架构中，您可以混合使用带有Spring MVC或Spring WebFlux控制器或带有Spring WebFlux功能端点的应用程序。在两个框架中都支持相同的基于注释的编程模型，这使得重用知识变得更加容易，同时还为正确的工作选择了正确的工具。</p>\n</li>\n<li><p>评估应用程序的一种简单方法是检查其依赖关系。如果您要使用阻塞性持久性API（JPA，JDBC）或网络API，则Spring MVC至少是通用体系结构的最佳选择。使用Reactor和RxJava在单独的线程上执行阻塞调用在技术上是可行的，但您不会充分利用非阻塞Web堆栈。</p>\n</li>\n<li><p>如果您的Spring MVC应用程序具有对远程服务的调用，请尝试使用active WebClient。您可以直接从Spring MVC控制器方法返回反应类型（Reactor，RxJava或其他）。每个呼叫的等待时间或呼叫之间的相互依赖性越大，好处就越明显。Spring MVC控制器也可以调用其他反应式组件。</p>\n</li>\n</ul>\n<ol>\n<li>WebFlux提供了两种模型</li>\n</ol>\n<ul>\n<li>注解控制器（Annotated Controllers）：与Spring MVC有一致的注解，都是基于spring-web模型。一个显著的区别是，WebFlux也支持响应式@RequestBody参数。</li>\n<li>函数终端（Functional Endpoints）：基于Lambda,轻量级和函数编程模型。提供了大量的方法来路由和处理请求。与注解控制器（Annotated Controllers）最大区别就是函数端模型能够负责请求的从头到尾的处理而不是只是通过声明注解然后回调。</li>\n</ul>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><p>两个Publisher接口：Flux与Mono。两者区别在于Flux是代表多个元素的发布者，Mono是单个元素的发布者.</p>\n<p>Mono 实现了 Publisher 接口，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">empty()：创建一个不包含任何元素，只发布结束消息的序列。</span><br><span class=\"line\">just()：可以指定序列中包含的全部元素。创建出来的 Mono序列在发布这些元素之后会自动结束。</span><br><span class=\"line\">justOrEmpty()：从一个 Optional 对象或可能为 null 的对象中创建 Mono。只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。</span><br><span class=\"line\">error(Throwable error)：创建一个只包含错误消息的序列。</span><br><span class=\"line\">never()：创建一个不包含任何消息通知的序列。</span><br><span class=\"line\">fromCallable()、fromCompletionStage()、fromFuture()、fromRunnable()和 fromSupplier()：分别从 Callable、CompletionStage、CompletableFuture、Runnable 和 Supplier 中创建 Mono。</span><br><span class=\"line\">delay(Duration duration)和 delayMillis(long duration)：创建一个 Mono 序列，在指定的延迟时间之后，产生数字 0 作为唯一值。</span><br><span class=\"line\">create()：通过 create()方法来使用 MonoSink 来创建 Mono。</span><br></pre></td></tr></table></figure></p>\n<p>Flux<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">just：可以指定序列中包含的全部元素。创建出来的 Flux 序列在发布这些元素之后会自动结束。</span><br><span class=\"line\">fromArray、fromIterable、fromStream：可以从一个数组、Iterable 对象或 Stream 对象中创建 Flux 对象。</span><br><span class=\"line\">empty()：创建一个不包含任何元素，只发布结束消息的序列,在响应式编程中，流的传递是基于元素的，empty表示没有任何元素，所以不会进行后续传递，需要用switchIfEmpty等处理</span><br><span class=\"line\">error(Throwable error)：创建一个只包含错误消息的序列。</span><br><span class=\"line\">never()：创建一个不包含任何消息通知的序列。使用示例：</span><br><span class=\"line\">range(int start, int count)：创建包含从 start 起始的 count 个数量的 Integer 对象的序列。</span><br><span class=\"line\">intervalMillis(long period)： interval()方法的作用相同，只不过该方法通过毫秒数来指定时间间隔和延迟时间。</span><br><span class=\"line\">create()：与 generate()方法的不同之处在于所使用的是 FluxSink 对象。FluxSink 支持同步和异步的消息产生，并且可以在一次调用中产生多个元素。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这一章主要是简单记录下WebFlux的介绍以及简单说明下WebFlux相关的几个概念。WebFlux的官方文档还是相对比较完善的，里面都有挺详细的说明，我就不一一照搬到这里。下一章就开始阅读Gateway的代码，看下Gateway里面是如何使用WebFlux构建网关。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#spring-webflux\" target=\"_blank\" rel=\"noopener\">webFlux官网</a></li>\n</ul>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/92460075\" target=\"_blank\" rel=\"noopener\">外行人都能看得懂的WebFlux</a></li>\n</ul>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485692&amp;idx=1&amp;sn=a6b3f040b13fa2324992b11a927e34dc&amp;chksm=ebd749fddca0c0eb1b05c08ede7ee4a44699584fbc0c3449ec2cac7642fd13819470ec7f44d8&amp;token=1024331018&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">最近学到的Lambda表达式基础知识</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>当选用了SpringCloud Gateway作为视频项目的网关之后,出于学习的心态，看下视频网关是如何构造起来的。</p>\n<h2 id=\"Spring-WebFlux学习\"><a href=\"#Spring-WebFlux学习\" class=\"headerlink\" title=\"Spring WebFlux学习\"></a>Spring WebFlux学习</h2><p>阅读源码之前首先学习下WebFlux基础概念和相关常用的API</p>\n<p>Spring WebFlux简单说是与Spring MVC类似的一门响应式异步非阻塞Web端控制框架。与Spring MVC有着相同功能的注解</p>\n<ol>\n<li>什么是响应式编程(Reactive)</li>\n</ol>\n<p>官方解释：</p>\n<blockquote>\n<p>The term, “reactive,”  refers to programming models that are built around reacting to change<br>响应式编程是一种围绕对变化作出反应而构建的编程模型。</p>\n</blockquote>\n<p>后面给出了例子：</p>\n<blockquote>\n<p>network components reacting to I/O events, UI controllers reacting to mouse events, and others. In that sense, non-blocking is reactive, because, instead of being blocked, we are now in the mode of reacting to notifications as operations complete or data becomes available.<br>网络组件对IO事件的响应，UI控制器对鼠标事件的响应。从这个意义上说，非阻塞也是响应式,因为我们现在也是在操作完成或者数据可用的时候作出响应的模式，而不是被阻塞。</p>\n</blockquote>\n<ol>\n<li>什么是背压（back pressure）</li>\n</ol>\n<p>官方解析：</p>\n<blockquote>\n<p>Reactive Streams is a small spec (also adopted in Java 9) that defines the interaction between asynchronous components with back pressure. For example a data repository (acting as Publisher) can produce data that an HTTP server (acting as Subscriber) can then write to the response. The main purpose of Reactive Streams is to let the subscriber control how quickly or how slowly the publisher produces data.<br>响应式流是一个小小的规范，定义了带有背压异步组件交互。例如，数据仓库（作为发布者）产生数据使HTTP服务（作为订阅者）能响应。主要目的就是响应式能让订阅者控制发布者发布数据的快与慢。</p>\n</blockquote>\n<p>其实上述说白了就是订阅者能够通过生产者需要多小数据，这样能够以免生产者无限量产生数据压垮订阅者。</p>\n<ol>\n<li>SpringMVC与WebFlux选择<br><img src=\"https://docs.spring.io/spring-framework/docs/current/reference/html/images/spring-mvc-and-webflux-venn.png\" alt=\"webFlux&amp;SpringMVC\"></li>\n</ol>\n<ul>\n<li><p>如果您有运行正常的Spring MVC应用程序，则无需更改。命令式编程是编写，理解和调试代码的最简单方法。您有最大的库选择空间，因为从历史上看，大多数库都是阻塞的。</p>\n</li>\n<li><p>如果您已经在选择无阻塞的Web堆栈，Spring WebFlux可以提供与该领域其他服务器相同的执行模型优势，还可以选择服务器（Netty，Tomcat，Jetty，Undertow和Servlet 3.1+容器），选择编程模型（带注释的控制器和功能性Web端点），以及选择反应式库（Reactor，RxJava或其他）。</p>\n</li>\n<li><p>如果您对与Java 8 lambda或Kotlin一起使用的轻量级功能性Web框架感兴趣，则可以使用Spring WebFlux功能性Web端点。对于要求较低复杂性的较小应用程序或微服务（可以受益于更高的透明度和控制）而言，这也是一个不错的选择。</p>\n</li>\n<li><p>在微服务架构中，您可以混合使用带有Spring MVC或Spring WebFlux控制器或带有Spring WebFlux功能端点的应用程序。在两个框架中都支持相同的基于注释的编程模型，这使得重用知识变得更加容易，同时还为正确的工作选择了正确的工具。</p>\n</li>\n<li><p>评估应用程序的一种简单方法是检查其依赖关系。如果您要使用阻塞性持久性API（JPA，JDBC）或网络API，则Spring MVC至少是通用体系结构的最佳选择。使用Reactor和RxJava在单独的线程上执行阻塞调用在技术上是可行的，但您不会充分利用非阻塞Web堆栈。</p>\n</li>\n<li><p>如果您的Spring MVC应用程序具有对远程服务的调用，请尝试使用active WebClient。您可以直接从Spring MVC控制器方法返回反应类型（Reactor，RxJava或其他）。每个呼叫的等待时间或呼叫之间的相互依赖性越大，好处就越明显。Spring MVC控制器也可以调用其他反应式组件。</p>\n</li>\n</ul>\n<ol>\n<li>WebFlux提供了两种模型</li>\n</ol>\n<ul>\n<li>注解控制器（Annotated Controllers）：与Spring MVC有一致的注解，都是基于spring-web模型。一个显著的区别是，WebFlux也支持响应式@RequestBody参数。</li>\n<li>函数终端（Functional Endpoints）：基于Lambda,轻量级和函数编程模型。提供了大量的方法来路由和处理请求。与注解控制器（Annotated Controllers）最大区别就是函数端模型能够负责请求的从头到尾的处理而不是只是通过声明注解然后回调。</li>\n</ul>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><p>两个Publisher接口：Flux与Mono。两者区别在于Flux是代表多个元素的发布者，Mono是单个元素的发布者.</p>\n<p>Mono 实现了 Publisher 接口，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">empty()：创建一个不包含任何元素，只发布结束消息的序列。</span><br><span class=\"line\">just()：可以指定序列中包含的全部元素。创建出来的 Mono序列在发布这些元素之后会自动结束。</span><br><span class=\"line\">justOrEmpty()：从一个 Optional 对象或可能为 null 的对象中创建 Mono。只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。</span><br><span class=\"line\">error(Throwable error)：创建一个只包含错误消息的序列。</span><br><span class=\"line\">never()：创建一个不包含任何消息通知的序列。</span><br><span class=\"line\">fromCallable()、fromCompletionStage()、fromFuture()、fromRunnable()和 fromSupplier()：分别从 Callable、CompletionStage、CompletableFuture、Runnable 和 Supplier 中创建 Mono。</span><br><span class=\"line\">delay(Duration duration)和 delayMillis(long duration)：创建一个 Mono 序列，在指定的延迟时间之后，产生数字 0 作为唯一值。</span><br><span class=\"line\">create()：通过 create()方法来使用 MonoSink 来创建 Mono。</span><br></pre></td></tr></table></figure></p>\n<p>Flux<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">just：可以指定序列中包含的全部元素。创建出来的 Flux 序列在发布这些元素之后会自动结束。</span><br><span class=\"line\">fromArray、fromIterable、fromStream：可以从一个数组、Iterable 对象或 Stream 对象中创建 Flux 对象。</span><br><span class=\"line\">empty()：创建一个不包含任何元素，只发布结束消息的序列,在响应式编程中，流的传递是基于元素的，empty表示没有任何元素，所以不会进行后续传递，需要用switchIfEmpty等处理</span><br><span class=\"line\">error(Throwable error)：创建一个只包含错误消息的序列。</span><br><span class=\"line\">never()：创建一个不包含任何消息通知的序列。使用示例：</span><br><span class=\"line\">range(int start, int count)：创建包含从 start 起始的 count 个数量的 Integer 对象的序列。</span><br><span class=\"line\">intervalMillis(long period)： interval()方法的作用相同，只不过该方法通过毫秒数来指定时间间隔和延迟时间。</span><br><span class=\"line\">create()：与 generate()方法的不同之处在于所使用的是 FluxSink 对象。FluxSink 支持同步和异步的消息产生，并且可以在一次调用中产生多个元素。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这一章主要是简单记录下WebFlux的介绍以及简单说明下WebFlux相关的几个概念。WebFlux的官方文档还是相对比较完善的，里面都有挺详细的说明，我就不一一照搬到这里。下一章就开始阅读Gateway的代码，看下Gateway里面是如何使用WebFlux构建网关。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#spring-webflux\" target=\"_blank\" rel=\"noopener\">webFlux官网</a></li>\n</ul>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/92460075\" target=\"_blank\" rel=\"noopener\">外行人都能看得懂的WebFlux</a></li>\n</ul>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485692&amp;idx=1&amp;sn=a6b3f040b13fa2324992b11a927e34dc&amp;chksm=ebd749fddca0c0eb1b05c08ede7ee4a44699584fbc0c3449ec2cac7642fd13819470ec7f44d8&amp;token=1024331018&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">最近学到的Lambda表达式基础知识</a></li>\n</ul>\n"},{"title":"git指令用法","date":"2017-02-23T03:16:39.000Z","_content":"\n### 常用git命令的使用\n```github\ngit init 初始化当前文件夹\n#分支\ngit branch -r 查看已有的分支\ngit checkout -b 分支 创建并切换分支\ngit checkout 分支 切换分支\ngit branch 显示当前分支\ngit branch -d 分支 删除分支\n#提交\ngit add . 添加操作，将将所有修改过的文件添加到版本库的暂缓区内\ngit commit -m \"文字说明\" 提交操作，将暂缓区内的代码提交到本地仓库中\ngit push origin 分支 push到远程仓库中\n#版本回退\ngit reset HEAD^ 回退到上一个版本\ngit reset --hard commit_id 回退到指定的commit_id的版本中\n#添加远程仓库\ngit remote add origin git@github.com:245831311(github账号名)/245831311.github.io.git(github仓库名)  添加远程仓库\ngit remote -v 查看origin远程主机名对应远程仓库\ngit remote rm origin 删除远程仓库\n#查看配置\ngit config -l 查看\n#查看git状态\ngit status\n#拉取代码\ngit fetch 将远程分支上的代码拉取下来并不合并\ngit rebase\ngit merge 合并代码\ngit pull 拉取并与当前分支合并代码\n```\n\n### 重点记录\n#### 1.git push <远程主机名> <本地分支名>  <远程分支名>\n__1.1 git push origin__\n 省略了本地分支与远程分支，当前分支与上一次的远程分支存在对应的关系，则会通过这个关系推送出去\n__1.2 git push origin master__\n 省略了远程分支名，则本地分支会推送到上一次对应存在的远程分支关系(一般同名).不存在则创建新的远程分支\n__1.3 git push origin :refs/for/master__\n 省略了本地分支名，则相当与删除远程分支\n__1.4 git push -u origin master__\n-u可以将本地分支与远程分支建立一个upstream的关系，若使用，则本地分支与远程分支建立了对应关系\n\n\n\n\n\n","source":"_posts/git常用指令记录.md","raw":"---\ntitle: git指令用法\ndate: 2017-02-23 11:16:39\ncategories: \n- git总结\ntags:\n- 笔记\n---\n\n### 常用git命令的使用\n```github\ngit init 初始化当前文件夹\n#分支\ngit branch -r 查看已有的分支\ngit checkout -b 分支 创建并切换分支\ngit checkout 分支 切换分支\ngit branch 显示当前分支\ngit branch -d 分支 删除分支\n#提交\ngit add . 添加操作，将将所有修改过的文件添加到版本库的暂缓区内\ngit commit -m \"文字说明\" 提交操作，将暂缓区内的代码提交到本地仓库中\ngit push origin 分支 push到远程仓库中\n#版本回退\ngit reset HEAD^ 回退到上一个版本\ngit reset --hard commit_id 回退到指定的commit_id的版本中\n#添加远程仓库\ngit remote add origin git@github.com:245831311(github账号名)/245831311.github.io.git(github仓库名)  添加远程仓库\ngit remote -v 查看origin远程主机名对应远程仓库\ngit remote rm origin 删除远程仓库\n#查看配置\ngit config -l 查看\n#查看git状态\ngit status\n#拉取代码\ngit fetch 将远程分支上的代码拉取下来并不合并\ngit rebase\ngit merge 合并代码\ngit pull 拉取并与当前分支合并代码\n```\n\n### 重点记录\n#### 1.git push <远程主机名> <本地分支名>  <远程分支名>\n__1.1 git push origin__\n 省略了本地分支与远程分支，当前分支与上一次的远程分支存在对应的关系，则会通过这个关系推送出去\n__1.2 git push origin master__\n 省略了远程分支名，则本地分支会推送到上一次对应存在的远程分支关系(一般同名).不存在则创建新的远程分支\n__1.3 git push origin :refs/for/master__\n 省略了本地分支名，则相当与删除远程分支\n__1.4 git push -u origin master__\n-u可以将本地分支与远程分支建立一个upstream的关系，若使用，则本地分支与远程分支建立了对应关系\n\n\n\n\n\n","slug":"git常用指令记录","published":1,"updated":"2021-09-07T08:00:52.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhrb0009d0tvjka9ib8g","content":"<h3 id=\"常用git命令的使用\"><a href=\"#常用git命令的使用\" class=\"headerlink\" title=\"常用git命令的使用\"></a>常用git命令的使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init 初始化当前文件夹</span><br><span class=\"line\">#分支</span><br><span class=\"line\">git branch -r 查看已有的分支</span><br><span class=\"line\">git checkout -b 分支 创建并切换分支</span><br><span class=\"line\">git checkout 分支 切换分支</span><br><span class=\"line\">git branch 显示当前分支</span><br><span class=\"line\">git branch -d 分支 删除分支</span><br><span class=\"line\">#提交</span><br><span class=\"line\">git add . 添加操作，将将所有修改过的文件添加到版本库的暂缓区内</span><br><span class=\"line\">git commit -m &quot;文字说明&quot; 提交操作，将暂缓区内的代码提交到本地仓库中</span><br><span class=\"line\">git push origin 分支 push到远程仓库中</span><br><span class=\"line\">#版本回退</span><br><span class=\"line\">git reset HEAD^ 回退到上一个版本</span><br><span class=\"line\">git reset --hard commit_id 回退到指定的commit_id的版本中</span><br><span class=\"line\">#添加远程仓库</span><br><span class=\"line\">git remote add origin git@github.com:245831311(github账号名)/245831311.github.io.git(github仓库名)  添加远程仓库</span><br><span class=\"line\">git remote -v 查看origin远程主机名对应远程仓库</span><br><span class=\"line\">git remote rm origin 删除远程仓库</span><br><span class=\"line\">#查看配置</span><br><span class=\"line\">git config -l 查看</span><br><span class=\"line\">#查看git状态</span><br><span class=\"line\">git status</span><br><span class=\"line\">#拉取代码</span><br><span class=\"line\">git fetch 将远程分支上的代码拉取下来并不合并</span><br><span class=\"line\">git rebase</span><br><span class=\"line\">git merge 合并代码</span><br><span class=\"line\">git pull 拉取并与当前分支合并代码</span><br></pre></td></tr></table></figure>\n<h3 id=\"重点记录\"><a href=\"#重点记录\" class=\"headerlink\" title=\"重点记录\"></a>重点记录</h3><h4 id=\"1-git-push-lt-远程主机名-gt-lt-本地分支名-gt-lt-远程分支名-gt\"><a href=\"#1-git-push-lt-远程主机名-gt-lt-本地分支名-gt-lt-远程分支名-gt\" class=\"headerlink\" title=\"1.git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;\"></a>1.git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;</h4><p><strong>1.1 git push origin</strong><br> 省略了本地分支与远程分支，当前分支与上一次的远程分支存在对应的关系，则会通过这个关系推送出去<br><strong>1.2 git push origin master</strong><br> 省略了远程分支名，则本地分支会推送到上一次对应存在的远程分支关系(一般同名).不存在则创建新的远程分支<br><strong>1.3 git push origin :refs/for/master</strong><br> 省略了本地分支名，则相当与删除远程分支<br><strong>1.4 git push -u origin master</strong><br>-u可以将本地分支与远程分支建立一个upstream的关系，若使用，则本地分支与远程分支建立了对应关系</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"常用git命令的使用\"><a href=\"#常用git命令的使用\" class=\"headerlink\" title=\"常用git命令的使用\"></a>常用git命令的使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init 初始化当前文件夹</span><br><span class=\"line\">#分支</span><br><span class=\"line\">git branch -r 查看已有的分支</span><br><span class=\"line\">git checkout -b 分支 创建并切换分支</span><br><span class=\"line\">git checkout 分支 切换分支</span><br><span class=\"line\">git branch 显示当前分支</span><br><span class=\"line\">git branch -d 分支 删除分支</span><br><span class=\"line\">#提交</span><br><span class=\"line\">git add . 添加操作，将将所有修改过的文件添加到版本库的暂缓区内</span><br><span class=\"line\">git commit -m &quot;文字说明&quot; 提交操作，将暂缓区内的代码提交到本地仓库中</span><br><span class=\"line\">git push origin 分支 push到远程仓库中</span><br><span class=\"line\">#版本回退</span><br><span class=\"line\">git reset HEAD^ 回退到上一个版本</span><br><span class=\"line\">git reset --hard commit_id 回退到指定的commit_id的版本中</span><br><span class=\"line\">#添加远程仓库</span><br><span class=\"line\">git remote add origin git@github.com:245831311(github账号名)/245831311.github.io.git(github仓库名)  添加远程仓库</span><br><span class=\"line\">git remote -v 查看origin远程主机名对应远程仓库</span><br><span class=\"line\">git remote rm origin 删除远程仓库</span><br><span class=\"line\">#查看配置</span><br><span class=\"line\">git config -l 查看</span><br><span class=\"line\">#查看git状态</span><br><span class=\"line\">git status</span><br><span class=\"line\">#拉取代码</span><br><span class=\"line\">git fetch 将远程分支上的代码拉取下来并不合并</span><br><span class=\"line\">git rebase</span><br><span class=\"line\">git merge 合并代码</span><br><span class=\"line\">git pull 拉取并与当前分支合并代码</span><br></pre></td></tr></table></figure>\n<h3 id=\"重点记录\"><a href=\"#重点记录\" class=\"headerlink\" title=\"重点记录\"></a>重点记录</h3><h4 id=\"1-git-push-lt-远程主机名-gt-lt-本地分支名-gt-lt-远程分支名-gt\"><a href=\"#1-git-push-lt-远程主机名-gt-lt-本地分支名-gt-lt-远程分支名-gt\" class=\"headerlink\" title=\"1.git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;\"></a>1.git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;</h4><p><strong>1.1 git push origin</strong><br> 省略了本地分支与远程分支，当前分支与上一次的远程分支存在对应的关系，则会通过这个关系推送出去<br><strong>1.2 git push origin master</strong><br> 省略了远程分支名，则本地分支会推送到上一次对应存在的远程分支关系(一般同名).不存在则创建新的远程分支<br><strong>1.3 git push origin :refs/for/master</strong><br> 省略了本地分支名，则相当与删除远程分支<br><strong>1.4 git push -u origin master</strong><br>-u可以将本地分支与远程分支建立一个upstream的关系，若使用，则本地分支与远程分支建立了对应关系</p>\n"},{"title":"hexo的搭建与使用","date":"2017-02-22T04:00:00.000Z","_content":"\n### Hexo 是什么\n    hexo是基于node.js的一个简洁的博客框架。hexo是一款使用markdown渲染，快速生成静态页面的框架。\n\n### 为什么使用hexo作为博客\n* 不走数据库，可以通过md作为存储文件\n* 高效快速，生成和渲染静态页面快\n* 部署发布简单，操作简便\n\n### hexo部署\n一. 安装node.js（网上很多，不详细解释）\n安装完毕后可以输入node -v查看是否安装成功.\n\n二. 安装hexo\n```html\n#由于npm的源比较慢，建议先换成淘宝的镜像\nnpm config set registry \"https://registry.npm.taobao.org\"\n\n#安装hexo客户端\nnpm install hexo-cli g\n\n#安装服务端插件\nnpm install hexo-server --save\n\n#安装hexo发布插件\nnpm install hexo-deployer-git --save\n```\n### hexo相关语法\n```hexo\n1.hexo init 文件夹 初始化文件夹为hexo目录形式\n2.hexo server(hexo s) 开启服务端,默认4000\n3.hexo s -p 5000 开启服务端并设置端口号\n4.hexo generate(hexo g) 生成静态页面\n5.hexo clean 清空静态页面\n6.hexo deploy 发布\n7.hexo g -d 生成并发布\n8.hexo g -s 生成并开启服务\n```\n\n","source":"_posts/hexo用法.md","raw":"---\ntitle: hexo的搭建与使用\ndate: 2017-02-22 12:00:00\ncategories: \n- hexo总结\ntags:\n- 笔记\n---\n\n### Hexo 是什么\n    hexo是基于node.js的一个简洁的博客框架。hexo是一款使用markdown渲染，快速生成静态页面的框架。\n\n### 为什么使用hexo作为博客\n* 不走数据库，可以通过md作为存储文件\n* 高效快速，生成和渲染静态页面快\n* 部署发布简单，操作简便\n\n### hexo部署\n一. 安装node.js（网上很多，不详细解释）\n安装完毕后可以输入node -v查看是否安装成功.\n\n二. 安装hexo\n```html\n#由于npm的源比较慢，建议先换成淘宝的镜像\nnpm config set registry \"https://registry.npm.taobao.org\"\n\n#安装hexo客户端\nnpm install hexo-cli g\n\n#安装服务端插件\nnpm install hexo-server --save\n\n#安装hexo发布插件\nnpm install hexo-deployer-git --save\n```\n### hexo相关语法\n```hexo\n1.hexo init 文件夹 初始化文件夹为hexo目录形式\n2.hexo server(hexo s) 开启服务端,默认4000\n3.hexo s -p 5000 开启服务端并设置端口号\n4.hexo generate(hexo g) 生成静态页面\n5.hexo clean 清空静态页面\n6.hexo deploy 发布\n7.hexo g -d 生成并发布\n8.hexo g -s 生成并开启服务\n```\n\n","slug":"hexo用法","published":1,"updated":"2021-09-07T08:00:52.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhrd000dd0tvfglkon3m","content":"<h3 id=\"Hexo-是什么\"><a href=\"#Hexo-是什么\" class=\"headerlink\" title=\"Hexo 是什么\"></a>Hexo 是什么</h3><pre><code>hexo是基于node.js的一个简洁的博客框架。hexo是一款使用markdown渲染，快速生成静态页面的框架。\n</code></pre><h3 id=\"为什么使用hexo作为博客\"><a href=\"#为什么使用hexo作为博客\" class=\"headerlink\" title=\"为什么使用hexo作为博客\"></a>为什么使用hexo作为博客</h3><ul>\n<li>不走数据库，可以通过md作为存储文件</li>\n<li>高效快速，生成和渲染静态页面快</li>\n<li>部署发布简单，操作简便</li>\n</ul>\n<h3 id=\"hexo部署\"><a href=\"#hexo部署\" class=\"headerlink\" title=\"hexo部署\"></a>hexo部署</h3><p>一. 安装node.js（网上很多，不详细解释）<br>安装完毕后可以输入node -v查看是否安装成功.</p>\n<p>二. 安装hexo<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#由于npm的源比较慢，建议先换成淘宝的镜像</span><br><span class=\"line\">npm config set registry \"https://registry.npm.taobao.org\"</span><br><span class=\"line\"></span><br><span class=\"line\">#安装hexo客户端</span><br><span class=\"line\">npm install hexo-cli g</span><br><span class=\"line\"></span><br><span class=\"line\">#安装服务端插件</span><br><span class=\"line\">npm install hexo-server --save</span><br><span class=\"line\"></span><br><span class=\"line\">#安装hexo发布插件</span><br><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"hexo相关语法\"><a href=\"#hexo相关语法\" class=\"headerlink\" title=\"hexo相关语法\"></a>hexo相关语法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.hexo init 文件夹 初始化文件夹为hexo目录形式</span><br><span class=\"line\">2.hexo server(hexo s) 开启服务端,默认4000</span><br><span class=\"line\">3.hexo s -p 5000 开启服务端并设置端口号</span><br><span class=\"line\">4.hexo generate(hexo g) 生成静态页面</span><br><span class=\"line\">5.hexo clean 清空静态页面</span><br><span class=\"line\">6.hexo deploy 发布</span><br><span class=\"line\">7.hexo g -d 生成并发布</span><br><span class=\"line\">8.hexo g -s 生成并开启服务</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Hexo-是什么\"><a href=\"#Hexo-是什么\" class=\"headerlink\" title=\"Hexo 是什么\"></a>Hexo 是什么</h3><pre><code>hexo是基于node.js的一个简洁的博客框架。hexo是一款使用markdown渲染，快速生成静态页面的框架。\n</code></pre><h3 id=\"为什么使用hexo作为博客\"><a href=\"#为什么使用hexo作为博客\" class=\"headerlink\" title=\"为什么使用hexo作为博客\"></a>为什么使用hexo作为博客</h3><ul>\n<li>不走数据库，可以通过md作为存储文件</li>\n<li>高效快速，生成和渲染静态页面快</li>\n<li>部署发布简单，操作简便</li>\n</ul>\n<h3 id=\"hexo部署\"><a href=\"#hexo部署\" class=\"headerlink\" title=\"hexo部署\"></a>hexo部署</h3><p>一. 安装node.js（网上很多，不详细解释）<br>安装完毕后可以输入node -v查看是否安装成功.</p>\n<p>二. 安装hexo<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#由于npm的源比较慢，建议先换成淘宝的镜像</span><br><span class=\"line\">npm config set registry \"https://registry.npm.taobao.org\"</span><br><span class=\"line\"></span><br><span class=\"line\">#安装hexo客户端</span><br><span class=\"line\">npm install hexo-cli g</span><br><span class=\"line\"></span><br><span class=\"line\">#安装服务端插件</span><br><span class=\"line\">npm install hexo-server --save</span><br><span class=\"line\"></span><br><span class=\"line\">#安装hexo发布插件</span><br><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"hexo相关语法\"><a href=\"#hexo相关语法\" class=\"headerlink\" title=\"hexo相关语法\"></a>hexo相关语法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.hexo init 文件夹 初始化文件夹为hexo目录形式</span><br><span class=\"line\">2.hexo server(hexo s) 开启服务端,默认4000</span><br><span class=\"line\">3.hexo s -p 5000 开启服务端并设置端口号</span><br><span class=\"line\">4.hexo generate(hexo g) 生成静态页面</span><br><span class=\"line\">5.hexo clean 清空静态页面</span><br><span class=\"line\">6.hexo deploy 发布</span><br><span class=\"line\">7.hexo g -d 生成并发布</span><br><span class=\"line\">8.hexo g -s 生成并开启服务</span><br></pre></td></tr></table></figure>\n"},{"title":"kettle-8.2安装手册","date":"2017-08-21T04:00:00.000Z","_content":"\n# 1 简介\n本编文章主要介绍如何安装kettle 8.2\n\n# 2 准备\n  1) 安装jdk1.8(已在上一章说明)\n  2) 下载kettle 8.2安装包：*[https://sourceforge.net/projects/pentaho/files/latest/download?aliId=137249511](https://sourceforge.net/projects/pentaho/files/latest/download?aliId=137249511)*\n# 3 安装kettle 8.2\n  1) 解压下载的安装包\n  2) 进入目录pdi-ce-8.2.0.0-342 **->** data-integration **->** ,打开spoon.bat\n![spoon-bat](/images/bdata/kettl-pc启动器.png)\n  3) 出现以上页面，代表安装成功\n![success-page](/images/bdata/kettle-pc界面.png)\n\n# 4 如何运行kettle脚本程序\n  1) 下载kettle脚本程序.zip,并重命名成后缀为zip压缩包：*[http://192.168.2.45:1174/AAYQAf__AAAAAQAAAAAAAAAAyUKMcgAORL6xOFABvf-aoA](http://192.168.2.45:1174/AAYQAf__AAAAAQAAAAAAAAAAyUKMcgAORL6xOFABvf-aoA)*\n  2) 解压压缩包，获取rest2file.ktr脚本程序\n  3) 点击打开按钮并选择存放脚本的指定位置\n![open](/images/bdata/kettle打开界面.png)\n  4) 执行脚本，并看当前脚本返回结果\n![perform](/images/bdata/kettle执行按钮.png)","source":"_posts/kettle-8.2安装手册.md","raw":"---\ntitle: kettle-8.2安装手册\ndate: 2017-08-21 12:00:00\ncategories: \n- 大数据\ntags:\n- 大数据\n---\n\n# 1 简介\n本编文章主要介绍如何安装kettle 8.2\n\n# 2 准备\n  1) 安装jdk1.8(已在上一章说明)\n  2) 下载kettle 8.2安装包：*[https://sourceforge.net/projects/pentaho/files/latest/download?aliId=137249511](https://sourceforge.net/projects/pentaho/files/latest/download?aliId=137249511)*\n# 3 安装kettle 8.2\n  1) 解压下载的安装包\n  2) 进入目录pdi-ce-8.2.0.0-342 **->** data-integration **->** ,打开spoon.bat\n![spoon-bat](/images/bdata/kettl-pc启动器.png)\n  3) 出现以上页面，代表安装成功\n![success-page](/images/bdata/kettle-pc界面.png)\n\n# 4 如何运行kettle脚本程序\n  1) 下载kettle脚本程序.zip,并重命名成后缀为zip压缩包：*[http://192.168.2.45:1174/AAYQAf__AAAAAQAAAAAAAAAAyUKMcgAORL6xOFABvf-aoA](http://192.168.2.45:1174/AAYQAf__AAAAAQAAAAAAAAAAyUKMcgAORL6xOFABvf-aoA)*\n  2) 解压压缩包，获取rest2file.ktr脚本程序\n  3) 点击打开按钮并选择存放脚本的指定位置\n![open](/images/bdata/kettle打开界面.png)\n  4) 执行脚本，并看当前脚本返回结果\n![perform](/images/bdata/kettle执行按钮.png)","slug":"kettle-8.2安装手册","published":1,"updated":"2021-09-07T11:41:03.771Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhrg000fd0tvktltqsk6","content":"<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h1><p>本编文章主要介绍如何安装kettle 8.2</p>\n<h1 id=\"2-准备\"><a href=\"#2-准备\" class=\"headerlink\" title=\"2 准备\"></a>2 准备</h1><p>  1) 安装jdk1.8(已在上一章说明)<br>  2) 下载kettle 8.2安装包：<em><a href=\"https://sourceforge.net/projects/pentaho/files/latest/download?aliId=137249511\" target=\"_blank\" rel=\"noopener\">https://sourceforge.net/projects/pentaho/files/latest/download?aliId=137249511</a></em></p>\n<h1 id=\"3-安装kettle-8-2\"><a href=\"#3-安装kettle-8-2\" class=\"headerlink\" title=\"3 安装kettle 8.2\"></a>3 安装kettle 8.2</h1><p>  1) 解压下载的安装包<br>  2) 进入目录pdi-ce-8.2.0.0-342 <strong>-&gt;</strong> data-integration <strong>-&gt;</strong> ,打开spoon.bat<br><img src=\"/images/bdata/kettl-pc启动器.png\" alt=\"spoon-bat\"><br>  3) 出现以上页面，代表安装成功<br><img src=\"/images/bdata/kettle-pc界面.png\" alt=\"success-page\"></p>\n<h1 id=\"4-如何运行kettle脚本程序\"><a href=\"#4-如何运行kettle脚本程序\" class=\"headerlink\" title=\"4 如何运行kettle脚本程序\"></a>4 如何运行kettle脚本程序</h1><p>  1) 下载kettle脚本程序.zip,并重命名成后缀为zip压缩包：<em><a href=\"http://192.168.2.45:1174/AAYQAf__AAAAAQAAAAAAAAAAyUKMcgAORL6xOFABvf-aoA\" target=\"_blank\" rel=\"noopener\">http://192.168.2.45:1174/AAYQAf__AAAAAQAAAAAAAAAAyUKMcgAORL6xOFABvf-aoA</a></em><br>  2) 解压压缩包，获取rest2file.ktr脚本程序<br>  3) 点击打开按钮并选择存放脚本的指定位置<br><img src=\"/images/bdata/kettle打开界面.png\" alt=\"open\"><br>  4) 执行脚本，并看当前脚本返回结果<br><img src=\"/images/bdata/kettle执行按钮.png\" alt=\"perform\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h1><p>本编文章主要介绍如何安装kettle 8.2</p>\n<h1 id=\"2-准备\"><a href=\"#2-准备\" class=\"headerlink\" title=\"2 准备\"></a>2 准备</h1><p>  1) 安装jdk1.8(已在上一章说明)<br>  2) 下载kettle 8.2安装包：<em><a href=\"https://sourceforge.net/projects/pentaho/files/latest/download?aliId=137249511\" target=\"_blank\" rel=\"noopener\">https://sourceforge.net/projects/pentaho/files/latest/download?aliId=137249511</a></em></p>\n<h1 id=\"3-安装kettle-8-2\"><a href=\"#3-安装kettle-8-2\" class=\"headerlink\" title=\"3 安装kettle 8.2\"></a>3 安装kettle 8.2</h1><p>  1) 解压下载的安装包<br>  2) 进入目录pdi-ce-8.2.0.0-342 <strong>-&gt;</strong> data-integration <strong>-&gt;</strong> ,打开spoon.bat<br><img src=\"/images/bdata/kettl-pc启动器.png\" alt=\"spoon-bat\"><br>  3) 出现以上页面，代表安装成功<br><img src=\"/images/bdata/kettle-pc界面.png\" alt=\"success-page\"></p>\n<h1 id=\"4-如何运行kettle脚本程序\"><a href=\"#4-如何运行kettle脚本程序\" class=\"headerlink\" title=\"4 如何运行kettle脚本程序\"></a>4 如何运行kettle脚本程序</h1><p>  1) 下载kettle脚本程序.zip,并重命名成后缀为zip压缩包：<em><a href=\"http://192.168.2.45:1174/AAYQAf__AAAAAQAAAAAAAAAAyUKMcgAORL6xOFABvf-aoA\" target=\"_blank\" rel=\"noopener\">http://192.168.2.45:1174/AAYQAf__AAAAAQAAAAAAAAAAyUKMcgAORL6xOFABvf-aoA</a></em><br>  2) 解压压缩包，获取rest2file.ktr脚本程序<br>  3) 点击打开按钮并选择存放脚本的指定位置<br><img src=\"/images/bdata/kettle打开界面.png\" alt=\"open\"><br>  4) 执行脚本，并看当前脚本返回结果<br><img src=\"/images/bdata/kettle执行按钮.png\" alt=\"perform\"></p>\n"},{"title":"kettle在项目中应用","date":"2021-08-20T04:00:00.000Z","_content":"\n## 背景\n\n随着发展，公司后续对接的项目对大数据量的存储和清洗需求越来越旺盛，我有幸接触这个项目并成为其中开发一员，致力于构建了一个底层的ETL清洗服务。这也是我首次调部门的第一个项目。\n\n## Kettle的介绍\n\nKettle从名称就可以知道“水壶”，顾名思义就是封装了很多内置功能，它是一个ETL的开源工具。Kettle就像一个容纳器，将很多ETL所需要的功能都涵盖进去，形成一个独立的生态系统。\n\n### 功能介绍\n\n下图可以看出,kettle包含了丰富的功能。\n\n![Kettle功能图](/images/bdata/kettle功能图.png)\n\n<html>\n<center>kettle功能图</center>\n</html>\n\n### 为什么使用kettle\n\n基于Kettle开发了一段时间，也逐渐深入了解到kettle的优势。以下是我使用Kettle以来个人的观点：\n\n优势：\n- 内置众多的成熟稳定开源组件，天然支持多种ETL业务场景。\n- kettle设计是基于职责单一原则，各个组件独立，不相互依赖。因此提高重用性。\n- 构建任务脚本简单，通过PC客户端拖拉组件的方式就能轻松实现转化任务。因此不用有编程基础的人都能够自行实现。\n- kettle有独立的官网，上面文档较为完善，但是可能市面上不怎么流行，网上关于kettle的问题并不是很多。\n\n\n劣势：\n- 组件繁多，有额外的学习门槛。\n- 没有提供Web端的开发页面，只有PC客户端，因此开发人员只能通过客户端调试并开发。\n- 由于基于开源组件开发，调试难度相对较大。线上部署测试难度大。\n- 天然包含众多组件，偏重量级开源框架，因此打包会比较大。\n- 不支持对非结构化文本的解释，如非结构化网页html、爬虫、不支持对流的操作和传输、难以支持逻辑较为复杂的业务流程，如数据融合，数据分析等。\n- 开发自定义组件相对复杂，调试比较难。\n\n我大大小小也基于kettle开发过几十个脚本，但是往全公司推广确实举步维艰，因为需要学习成本，这个也跟公司的架构有关系（主要原因）。一旦脚本众多，维护起来就越来越麻烦，特别对于过于复杂的脚本来说，没几多人愿意维护起来。\n\n### Kettle安装与使用\n\n[Kettle安装使用](http://note.youdao.com/noteshare?id=28505b7348b9d73ed38d8da36bfd1425&sub=171D26FDD37442F184CA9B8947192B95)\n\n### 集成Kettle\n\n1. 添加Maven\n```\n<kettle.version>8.3.0.0-371</kettle.version>\n\n<dependency>\n\t<groupId>pentaho-kettle</groupId>\n\t<artifactId>kettle-core</artifactId>\n\t<version>${kettle.version}</version>\n</dependency>\n<dependency>\n\t<groupId>pentaho-kettle</groupId>\n\t<artifactId>kettle-engine</artifactId>\n\t<version>${kettle.version}</version>\n</dependency>\n<dependency>\n\t<groupId>pentaho-kettle</groupId>\n\t<artifactId>kettle-dbdialog</artifactId>\n\t<version>${kettle.version}</version>\n</dependency>\n```\n\n需要额外添加Pentaho自身的仓库，不然下载不了对应的Jar包\n```\n<repositories>\n  \t<repository>\n      <id>pentaho-public</id>\n      <name>Pentaho Public</name>\n      <url>http://nexus.pentaho.org/content/groups/omni</url>\n    </repository>\n</repositories>\n\t\n```\n\n2. 代码集成\n\n- 加载插件并进行kettle环境的初始化\n```\n@Override\npublic boolean init() {\n\ttry {\n\t\tif (pluginDir != null) {\n\t\t\t// Load plugins\n\t\t\tStepPluginType.getInstance().getPluginFolders().add(new PluginFolder(pluginDir, false, true));\n\t\t}\n\t\tKettleEnvironment.init();\n\t} catch (KettleException e) {\n\t\te.printStackTrace();\n\t\tLog.error(\"kettle executor init\",e);\n\t\treturn false;\n\t}\n\treturn true;\n}\n```\n\n- 执行Trans任务具体实现\n```java\n/**\n * \n * @param filePath  脚本路径\n * @param paramMap  脚本参数\n * @param level 脚本输出日志级别\n * @return\n */\npublic boolean runTrans(String filePath, Map<String, String> paramMap,String level) {\n\t\tTrans trans = null;\n\t\ttry {\n\t\t\t\n\t\t\tLOG.info(\"Running trans {}...\", filePath);\n\t\t\tlong st = System.currentTimeMillis();\n\t\t\t\n\t\t\tTransMeta transMeta = new TransMeta(filePath);    //构建Tran文件元数据对象\n\t\t\t\n\t\t\ttrans = new Trans(transMeta);   //构建Trans任务\n\n            //设置Trans里面输入的参数\n\t\t\tif (paramMap != null) {\n\t\t\t\tfor( String param: paramMap.keySet() ) {\n\t\t\t\t\ttrans.setParameterValue( param, paramMap.get(param));\n\t\t\t\t\ttransMeta.setParameterValue( param, paramMap.get(param));\n\t\t\t\t}\t\t\n\t\t\t\ttrans.activateParameters();\n\t\t\t}\n\t\t\t//执行Trans任务的脚本\n\t\t\ttrans.execute(null);\n\t\t\ttrans.waitUntilFinished();\n\t\t\t\n\t\t\tif (trans.getErrors() > 0) {\n\t\t\t\tLOG.error(\"There are errors while running transformation! Error Code: {}\", trans.getErrors());\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tlong dt = System.currentTimeMillis() - st;\n\t\t\t\tLOG.info(\"Run trans {} finish in {} ms\", filePath, dt);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tif(!trans.isFinished()){\n\t\t\t\ttrans.stopAll();\n\t\t\t}\n\t\t} \n\t\treturn false;\n\t}\n```\n\n3. 运行\n\n到了这部基本上已经可以跑kettle生成的trans的脚本，如果还想增加调度的功能话可以集成quartz调度包、市面上比较流行的saturn、xxl-job等调度框架，或者基于公司的业务架构来自行实现调度框架也是可以。以上的框架我也有使用过并进行对比和集成。后面会有一章节额外说明，这里就不详细说了。\n\n\n\n## 参考\n\n[kettle官网](https://community.hitachivantara.com/s/article/data-integration-kettle)\n","source":"_posts/kettle在项目中应用.md","raw":"---\ntitle: kettle在项目中应用\ndate: 2021-08-20 12:00:00\ncategories: \n- 大数据\ntags:\n- 大数据\n---\n\n## 背景\n\n随着发展，公司后续对接的项目对大数据量的存储和清洗需求越来越旺盛，我有幸接触这个项目并成为其中开发一员，致力于构建了一个底层的ETL清洗服务。这也是我首次调部门的第一个项目。\n\n## Kettle的介绍\n\nKettle从名称就可以知道“水壶”，顾名思义就是封装了很多内置功能，它是一个ETL的开源工具。Kettle就像一个容纳器，将很多ETL所需要的功能都涵盖进去，形成一个独立的生态系统。\n\n### 功能介绍\n\n下图可以看出,kettle包含了丰富的功能。\n\n![Kettle功能图](/images/bdata/kettle功能图.png)\n\n<html>\n<center>kettle功能图</center>\n</html>\n\n### 为什么使用kettle\n\n基于Kettle开发了一段时间，也逐渐深入了解到kettle的优势。以下是我使用Kettle以来个人的观点：\n\n优势：\n- 内置众多的成熟稳定开源组件，天然支持多种ETL业务场景。\n- kettle设计是基于职责单一原则，各个组件独立，不相互依赖。因此提高重用性。\n- 构建任务脚本简单，通过PC客户端拖拉组件的方式就能轻松实现转化任务。因此不用有编程基础的人都能够自行实现。\n- kettle有独立的官网，上面文档较为完善，但是可能市面上不怎么流行，网上关于kettle的问题并不是很多。\n\n\n劣势：\n- 组件繁多，有额外的学习门槛。\n- 没有提供Web端的开发页面，只有PC客户端，因此开发人员只能通过客户端调试并开发。\n- 由于基于开源组件开发，调试难度相对较大。线上部署测试难度大。\n- 天然包含众多组件，偏重量级开源框架，因此打包会比较大。\n- 不支持对非结构化文本的解释，如非结构化网页html、爬虫、不支持对流的操作和传输、难以支持逻辑较为复杂的业务流程，如数据融合，数据分析等。\n- 开发自定义组件相对复杂，调试比较难。\n\n我大大小小也基于kettle开发过几十个脚本，但是往全公司推广确实举步维艰，因为需要学习成本，这个也跟公司的架构有关系（主要原因）。一旦脚本众多，维护起来就越来越麻烦，特别对于过于复杂的脚本来说，没几多人愿意维护起来。\n\n### Kettle安装与使用\n\n[Kettle安装使用](http://note.youdao.com/noteshare?id=28505b7348b9d73ed38d8da36bfd1425&sub=171D26FDD37442F184CA9B8947192B95)\n\n### 集成Kettle\n\n1. 添加Maven\n```\n<kettle.version>8.3.0.0-371</kettle.version>\n\n<dependency>\n\t<groupId>pentaho-kettle</groupId>\n\t<artifactId>kettle-core</artifactId>\n\t<version>${kettle.version}</version>\n</dependency>\n<dependency>\n\t<groupId>pentaho-kettle</groupId>\n\t<artifactId>kettle-engine</artifactId>\n\t<version>${kettle.version}</version>\n</dependency>\n<dependency>\n\t<groupId>pentaho-kettle</groupId>\n\t<artifactId>kettle-dbdialog</artifactId>\n\t<version>${kettle.version}</version>\n</dependency>\n```\n\n需要额外添加Pentaho自身的仓库，不然下载不了对应的Jar包\n```\n<repositories>\n  \t<repository>\n      <id>pentaho-public</id>\n      <name>Pentaho Public</name>\n      <url>http://nexus.pentaho.org/content/groups/omni</url>\n    </repository>\n</repositories>\n\t\n```\n\n2. 代码集成\n\n- 加载插件并进行kettle环境的初始化\n```\n@Override\npublic boolean init() {\n\ttry {\n\t\tif (pluginDir != null) {\n\t\t\t// Load plugins\n\t\t\tStepPluginType.getInstance().getPluginFolders().add(new PluginFolder(pluginDir, false, true));\n\t\t}\n\t\tKettleEnvironment.init();\n\t} catch (KettleException e) {\n\t\te.printStackTrace();\n\t\tLog.error(\"kettle executor init\",e);\n\t\treturn false;\n\t}\n\treturn true;\n}\n```\n\n- 执行Trans任务具体实现\n```java\n/**\n * \n * @param filePath  脚本路径\n * @param paramMap  脚本参数\n * @param level 脚本输出日志级别\n * @return\n */\npublic boolean runTrans(String filePath, Map<String, String> paramMap,String level) {\n\t\tTrans trans = null;\n\t\ttry {\n\t\t\t\n\t\t\tLOG.info(\"Running trans {}...\", filePath);\n\t\t\tlong st = System.currentTimeMillis();\n\t\t\t\n\t\t\tTransMeta transMeta = new TransMeta(filePath);    //构建Tran文件元数据对象\n\t\t\t\n\t\t\ttrans = new Trans(transMeta);   //构建Trans任务\n\n            //设置Trans里面输入的参数\n\t\t\tif (paramMap != null) {\n\t\t\t\tfor( String param: paramMap.keySet() ) {\n\t\t\t\t\ttrans.setParameterValue( param, paramMap.get(param));\n\t\t\t\t\ttransMeta.setParameterValue( param, paramMap.get(param));\n\t\t\t\t}\t\t\n\t\t\t\ttrans.activateParameters();\n\t\t\t}\n\t\t\t//执行Trans任务的脚本\n\t\t\ttrans.execute(null);\n\t\t\ttrans.waitUntilFinished();\n\t\t\t\n\t\t\tif (trans.getErrors() > 0) {\n\t\t\t\tLOG.error(\"There are errors while running transformation! Error Code: {}\", trans.getErrors());\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tlong dt = System.currentTimeMillis() - st;\n\t\t\t\tLOG.info(\"Run trans {} finish in {} ms\", filePath, dt);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tif(!trans.isFinished()){\n\t\t\t\ttrans.stopAll();\n\t\t\t}\n\t\t} \n\t\treturn false;\n\t}\n```\n\n3. 运行\n\n到了这部基本上已经可以跑kettle生成的trans的脚本，如果还想增加调度的功能话可以集成quartz调度包、市面上比较流行的saturn、xxl-job等调度框架，或者基于公司的业务架构来自行实现调度框架也是可以。以上的框架我也有使用过并进行对比和集成。后面会有一章节额外说明，这里就不详细说了。\n\n\n\n## 参考\n\n[kettle官网](https://community.hitachivantara.com/s/article/data-integration-kettle)\n","slug":"kettle在项目中应用","published":1,"updated":"2021-09-07T11:41:22.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhrl000jd0tv22qkmemr","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着发展，公司后续对接的项目对大数据量的存储和清洗需求越来越旺盛，我有幸接触这个项目并成为其中开发一员，致力于构建了一个底层的ETL清洗服务。这也是我首次调部门的第一个项目。</p>\n<h2 id=\"Kettle的介绍\"><a href=\"#Kettle的介绍\" class=\"headerlink\" title=\"Kettle的介绍\"></a>Kettle的介绍</h2><p>Kettle从名称就可以知道“水壶”，顾名思义就是封装了很多内置功能，它是一个ETL的开源工具。Kettle就像一个容纳器，将很多ETL所需要的功能都涵盖进去，形成一个独立的生态系统。</p>\n<h3 id=\"功能介绍\"><a href=\"#功能介绍\" class=\"headerlink\" title=\"功能介绍\"></a>功能介绍</h3><p>下图可以看出,kettle包含了丰富的功能。</p>\n<p><img src=\"/images/bdata/kettle功能图.png\" alt=\"Kettle功能图\"></p>\n<html><br><center>kettle功能图</center><br></html>\n\n<h3 id=\"为什么使用kettle\"><a href=\"#为什么使用kettle\" class=\"headerlink\" title=\"为什么使用kettle\"></a>为什么使用kettle</h3><p>基于Kettle开发了一段时间，也逐渐深入了解到kettle的优势。以下是我使用Kettle以来个人的观点：</p>\n<p>优势：</p>\n<ul>\n<li>内置众多的成熟稳定开源组件，天然支持多种ETL业务场景。</li>\n<li>kettle设计是基于职责单一原则，各个组件独立，不相互依赖。因此提高重用性。</li>\n<li>构建任务脚本简单，通过PC客户端拖拉组件的方式就能轻松实现转化任务。因此不用有编程基础的人都能够自行实现。</li>\n<li>kettle有独立的官网，上面文档较为完善，但是可能市面上不怎么流行，网上关于kettle的问题并不是很多。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>组件繁多，有额外的学习门槛。</li>\n<li>没有提供Web端的开发页面，只有PC客户端，因此开发人员只能通过客户端调试并开发。</li>\n<li>由于基于开源组件开发，调试难度相对较大。线上部署测试难度大。</li>\n<li>天然包含众多组件，偏重量级开源框架，因此打包会比较大。</li>\n<li>不支持对非结构化文本的解释，如非结构化网页html、爬虫、不支持对流的操作和传输、难以支持逻辑较为复杂的业务流程，如数据融合，数据分析等。</li>\n<li>开发自定义组件相对复杂，调试比较难。</li>\n</ul>\n<p>我大大小小也基于kettle开发过几十个脚本，但是往全公司推广确实举步维艰，因为需要学习成本，这个也跟公司的架构有关系（主要原因）。一旦脚本众多，维护起来就越来越麻烦，特别对于过于复杂的脚本来说，没几多人愿意维护起来。</p>\n<h3 id=\"Kettle安装与使用\"><a href=\"#Kettle安装与使用\" class=\"headerlink\" title=\"Kettle安装与使用\"></a>Kettle安装与使用</h3><p><a href=\"http://note.youdao.com/noteshare?id=28505b7348b9d73ed38d8da36bfd1425&amp;sub=171D26FDD37442F184CA9B8947192B95\" target=\"_blank\" rel=\"noopener\">Kettle安装使用</a></p>\n<h3 id=\"集成Kettle\"><a href=\"#集成Kettle\" class=\"headerlink\" title=\"集成Kettle\"></a>集成Kettle</h3><ol>\n<li>添加Maven<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;kettle.version&gt;8.3.0.0-371&lt;/kettle.version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;kettle-core&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;kettle-engine&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;kettle-dbdialog&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>需要额外添加Pentaho自身的仓库，不然下载不了对应的Jar包<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;repositories&gt;</span><br><span class=\"line\">  \t&lt;repository&gt;</span><br><span class=\"line\">      &lt;id&gt;pentaho-public&lt;/id&gt;</span><br><span class=\"line\">      &lt;name&gt;Pentaho Public&lt;/name&gt;</span><br><span class=\"line\">      &lt;url&gt;http://nexus.pentaho.org/content/groups/omni&lt;/url&gt;</span><br><span class=\"line\">    &lt;/repository&gt;</span><br><span class=\"line\">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>代码集成</li>\n</ol>\n<ul>\n<li><p>加载插件并进行kettle环境的初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean init() &#123;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tif (pluginDir != null) &#123;</span><br><span class=\"line\">\t\t\t// Load plugins</span><br><span class=\"line\">\t\t\tStepPluginType.getInstance().getPluginFolders().add(new PluginFolder(pluginDir, false, true));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tKettleEnvironment.init();</span><br><span class=\"line\">\t&#125; catch (KettleException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t\tLog.error(&quot;kettle executor init&quot;,e);</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行Trans任务具体实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> filePath  脚本路径</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> paramMap  脚本参数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> level 脚本输出日志级别</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runTrans</span><span class=\"params\">(String filePath, Map&lt;String, String&gt; paramMap,String level)</span> </span>&#123;</span><br><span class=\"line\">\t\tTrans trans = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tLOG.info(<span class=\"string\">\"Running trans &#123;&#125;...\"</span>, filePath);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">long</span> st = System.currentTimeMillis();</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tTransMeta transMeta = <span class=\"keyword\">new</span> TransMeta(filePath);    <span class=\"comment\">//构建Tran文件元数据对象</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\ttrans = <span class=\"keyword\">new</span> Trans(transMeta);   <span class=\"comment\">//构建Trans任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//设置Trans里面输入的参数</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (paramMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>( String param: paramMap.keySet() ) &#123;</span><br><span class=\"line\">\t\t\t\t\ttrans.setParameterValue( param, paramMap.get(param));</span><br><span class=\"line\">\t\t\t\t\ttransMeta.setParameterValue( param, paramMap.get(param));</span><br><span class=\"line\">\t\t\t\t&#125;\t\t</span><br><span class=\"line\">\t\t\t\ttrans.activateParameters();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//执行Trans任务的脚本</span></span><br><span class=\"line\">\t\t\ttrans.execute(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\ttrans.waitUntilFinished();</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (trans.getErrors() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tLOG.error(<span class=\"string\">\"There are errors while running transformation! Error Code: &#123;&#125;\"</span>, trans.getErrors());</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">long</span> dt = System.currentTimeMillis() - st;</span><br><span class=\"line\">\t\t\t\tLOG.info(<span class=\"string\">\"Run trans &#123;&#125; finish in &#123;&#125; ms\"</span>, filePath, dt);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!trans.isFinished())&#123;</span><br><span class=\"line\">\t\t\t\ttrans.stopAll();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>运行</li>\n</ol>\n<p>到了这部基本上已经可以跑kettle生成的trans的脚本，如果还想增加调度的功能话可以集成quartz调度包、市面上比较流行的saturn、xxl-job等调度框架，或者基于公司的业务架构来自行实现调度框架也是可以。以上的框架我也有使用过并进行对比和集成。后面会有一章节额外说明，这里就不详细说了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://community.hitachivantara.com/s/article/data-integration-kettle\" target=\"_blank\" rel=\"noopener\">kettle官网</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着发展，公司后续对接的项目对大数据量的存储和清洗需求越来越旺盛，我有幸接触这个项目并成为其中开发一员，致力于构建了一个底层的ETL清洗服务。这也是我首次调部门的第一个项目。</p>\n<h2 id=\"Kettle的介绍\"><a href=\"#Kettle的介绍\" class=\"headerlink\" title=\"Kettle的介绍\"></a>Kettle的介绍</h2><p>Kettle从名称就可以知道“水壶”，顾名思义就是封装了很多内置功能，它是一个ETL的开源工具。Kettle就像一个容纳器，将很多ETL所需要的功能都涵盖进去，形成一个独立的生态系统。</p>\n<h3 id=\"功能介绍\"><a href=\"#功能介绍\" class=\"headerlink\" title=\"功能介绍\"></a>功能介绍</h3><p>下图可以看出,kettle包含了丰富的功能。</p>\n<p><img src=\"/images/bdata/kettle功能图.png\" alt=\"Kettle功能图\"></p>\n<html><br><center>kettle功能图</center><br></html>\n\n<h3 id=\"为什么使用kettle\"><a href=\"#为什么使用kettle\" class=\"headerlink\" title=\"为什么使用kettle\"></a>为什么使用kettle</h3><p>基于Kettle开发了一段时间，也逐渐深入了解到kettle的优势。以下是我使用Kettle以来个人的观点：</p>\n<p>优势：</p>\n<ul>\n<li>内置众多的成熟稳定开源组件，天然支持多种ETL业务场景。</li>\n<li>kettle设计是基于职责单一原则，各个组件独立，不相互依赖。因此提高重用性。</li>\n<li>构建任务脚本简单，通过PC客户端拖拉组件的方式就能轻松实现转化任务。因此不用有编程基础的人都能够自行实现。</li>\n<li>kettle有独立的官网，上面文档较为完善，但是可能市面上不怎么流行，网上关于kettle的问题并不是很多。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>组件繁多，有额外的学习门槛。</li>\n<li>没有提供Web端的开发页面，只有PC客户端，因此开发人员只能通过客户端调试并开发。</li>\n<li>由于基于开源组件开发，调试难度相对较大。线上部署测试难度大。</li>\n<li>天然包含众多组件，偏重量级开源框架，因此打包会比较大。</li>\n<li>不支持对非结构化文本的解释，如非结构化网页html、爬虫、不支持对流的操作和传输、难以支持逻辑较为复杂的业务流程，如数据融合，数据分析等。</li>\n<li>开发自定义组件相对复杂，调试比较难。</li>\n</ul>\n<p>我大大小小也基于kettle开发过几十个脚本，但是往全公司推广确实举步维艰，因为需要学习成本，这个也跟公司的架构有关系（主要原因）。一旦脚本众多，维护起来就越来越麻烦，特别对于过于复杂的脚本来说，没几多人愿意维护起来。</p>\n<h3 id=\"Kettle安装与使用\"><a href=\"#Kettle安装与使用\" class=\"headerlink\" title=\"Kettle安装与使用\"></a>Kettle安装与使用</h3><p><a href=\"http://note.youdao.com/noteshare?id=28505b7348b9d73ed38d8da36bfd1425&amp;sub=171D26FDD37442F184CA9B8947192B95\" target=\"_blank\" rel=\"noopener\">Kettle安装使用</a></p>\n<h3 id=\"集成Kettle\"><a href=\"#集成Kettle\" class=\"headerlink\" title=\"集成Kettle\"></a>集成Kettle</h3><ol>\n<li>添加Maven<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;kettle.version&gt;8.3.0.0-371&lt;/kettle.version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;kettle-core&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;kettle-engine&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;kettle-dbdialog&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>需要额外添加Pentaho自身的仓库，不然下载不了对应的Jar包<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;repositories&gt;</span><br><span class=\"line\">  \t&lt;repository&gt;</span><br><span class=\"line\">      &lt;id&gt;pentaho-public&lt;/id&gt;</span><br><span class=\"line\">      &lt;name&gt;Pentaho Public&lt;/name&gt;</span><br><span class=\"line\">      &lt;url&gt;http://nexus.pentaho.org/content/groups/omni&lt;/url&gt;</span><br><span class=\"line\">    &lt;/repository&gt;</span><br><span class=\"line\">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>代码集成</li>\n</ol>\n<ul>\n<li><p>加载插件并进行kettle环境的初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean init() &#123;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tif (pluginDir != null) &#123;</span><br><span class=\"line\">\t\t\t// Load plugins</span><br><span class=\"line\">\t\t\tStepPluginType.getInstance().getPluginFolders().add(new PluginFolder(pluginDir, false, true));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tKettleEnvironment.init();</span><br><span class=\"line\">\t&#125; catch (KettleException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t\tLog.error(&quot;kettle executor init&quot;,e);</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行Trans任务具体实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> filePath  脚本路径</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> paramMap  脚本参数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> level 脚本输出日志级别</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runTrans</span><span class=\"params\">(String filePath, Map&lt;String, String&gt; paramMap,String level)</span> </span>&#123;</span><br><span class=\"line\">\t\tTrans trans = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tLOG.info(<span class=\"string\">\"Running trans &#123;&#125;...\"</span>, filePath);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">long</span> st = System.currentTimeMillis();</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tTransMeta transMeta = <span class=\"keyword\">new</span> TransMeta(filePath);    <span class=\"comment\">//构建Tran文件元数据对象</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\ttrans = <span class=\"keyword\">new</span> Trans(transMeta);   <span class=\"comment\">//构建Trans任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//设置Trans里面输入的参数</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (paramMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>( String param: paramMap.keySet() ) &#123;</span><br><span class=\"line\">\t\t\t\t\ttrans.setParameterValue( param, paramMap.get(param));</span><br><span class=\"line\">\t\t\t\t\ttransMeta.setParameterValue( param, paramMap.get(param));</span><br><span class=\"line\">\t\t\t\t&#125;\t\t</span><br><span class=\"line\">\t\t\t\ttrans.activateParameters();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//执行Trans任务的脚本</span></span><br><span class=\"line\">\t\t\ttrans.execute(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\ttrans.waitUntilFinished();</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (trans.getErrors() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tLOG.error(<span class=\"string\">\"There are errors while running transformation! Error Code: &#123;&#125;\"</span>, trans.getErrors());</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">long</span> dt = System.currentTimeMillis() - st;</span><br><span class=\"line\">\t\t\t\tLOG.info(<span class=\"string\">\"Run trans &#123;&#125; finish in &#123;&#125; ms\"</span>, filePath, dt);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!trans.isFinished())&#123;</span><br><span class=\"line\">\t\t\t\ttrans.stopAll();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>运行</li>\n</ol>\n<p>到了这部基本上已经可以跑kettle生成的trans的脚本，如果还想增加调度的功能话可以集成quartz调度包、市面上比较流行的saturn、xxl-job等调度框架，或者基于公司的业务架构来自行实现调度框架也是可以。以上的框架我也有使用过并进行对比和集成。后面会有一章节额外说明，这里就不详细说了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://community.hitachivantara.com/s/article/data-integration-kettle\" target=\"_blank\" rel=\"noopener\">kettle官网</a></p>\n"},{"title":"nginx原理分析","date":"2017-12-05T04:00:00.000Z","_content":"**导语:**\n>本章主要记录一下我对nginx原理的理解，以及相关的重点与难点\n\n### 一.nginx优点\n\n#### IO多路复用（重点）\n前一章中提及到了nginx能支撑高并发的一个主要原因就是使用到io多路复用的这种技术。\n\n1.  什么是io多路复用？\n定义上：获取并监听多个fd(文件描述符)，通过单个线程内完成IO的读写,复用指的是线程\n例子:某快递公司快递员（<font color=\"red\">处理线程</font>），寄件（<font color=\"red\">IO网络请求</font>）\n    * 例子一：快递员不知道哪家需要寄件，逐间逐户询问是否需要寄件，这样的话就会造成耗费时间过长，万一某一户出现某些情况，寄件人还未回来，就会一直阻塞。这就是一个典型的单线程阻塞例子。\n    * 例子二：快递公司觉得一个快递员收件太慢了，就聘请了多个快递员去收件。这样会造成一个问题就是收件速度确实比以前快，但这也会使快递公司成本变得高，造成不必要的人力浪费。这个就是多线程+阻塞的例子。\n    * 例子三：寄件方准本好需要的寄件，然后打电话通知快递员某户寄件已准备好，快递员就上门收取。这样就能用一个快递员高效的收纳寄件。这就是一个io多路复用的例子，打电话通知寄件已准备好其实可以看作io事件准备就绪主动上报的一个过程，程序机制就会对已准备好的事件做一系列的io读写操作。\n\n1. nginx的io多路复用模型有哪些？\nnginx中提供了多种io多路复用模型的机制如select,poll,epoll等。目前，linux2.6以上才能使用epoll机制。本质上,select与epoll都是属于非阻塞的同步IO.下面，我简单介绍一下select与epoll的区别。\n    - select介绍\n    ![selectIO模型图](/images/nginx/select.jpg)\n    1. 进程通过select调用，将fd集合从用户态全部复制到内核态当中，这个过程中会阻塞进程。\n    2. select会遍历的fd集合，如果存在准备就绪的fd，就会返回可读的指示并将对应连接放入监听队列中(表示监听IO数据)。在第二次遍历如果发现存在已经就绪的数据，则会调用recvfrom的方法,进程会将数据从内核态复制到用户态中并进行对应读写事件处理。处理完毕则会移除对应监听队列的socket。\n    3. 在select遍历完所有的fd都没有发现可读的fd后,则会进入休眠期。当有发现新的可读写资源，则会唤醒select进程。如果超过一定超时时间，则会重新被唤醒。重新遍历fd集合。\n        <span><font color=\"red\">\n        select总结:\n            -  每次select调用都需要遍历fd集合。\n            -  监视的文件描述符的数量存在最大限制，可以调节，但是随着增大也会导致用户态与内核态之间的复制带来的资源开销（如内存）呈线性增大\n            -  每次都要将整个集合的数据在用户态与内核到之间的互相复制。\n        </font></span>\n        \n    - epoll介绍\n    epoll的核心主要是三个函数:epoll_create(创建epoll句柄)，epoll_ctl(管理epoll注册监听事件，增删查改等)，epoll_wait(等待执行事件)\n    4. 首先调用epoll_create创建一个epoll句柄对象，epoll含有一个红黑树和一个就绪队列。\n    5. 当调用epoll_ctl创建注册监听事件时候，会为fd注册一个回调函数，并将fd从用户态复制到内核态。如果fd就绪后，会通过回掉函数将fd放入就绪队列中。\n    6. epoll_wait则会扫描就绪队列并执行相应事件,并把数据返回给用户。与select类似都是苏醒与睡眠交替进行，但是select是不停遍历整个fd集合，而epoll_wait只是遍历就绪列表就可以了，仅判断是否为空就OK拉。\n> 总结：  \n简单类比一下，其实select模型与epoll模型好比如在茶楼结账时候，服务员只告诉老板有人结账了，你过去收。此时老板并不知道具体要结账的是哪一桌，就一个一个去问（遍历fd集合是否有就绪），这是select模型做的；而epoll则是服务员具体告诉老板是那几桌要结账（利用回调函数，将就绪事件直接放到epoll队列中），老板就能直接过去结账。\n\n1. io多路复用的优缺点?\n\n| 优点 | 缺点 |\n| :---: | :---: |\n|单线程，消耗少|不适宜处理少量的请求数|\n|能支撑大并发量的请求|\n|非阻塞|\n\n#### cpu的亲和性\n能够将nginx上的worker绑定到某一特定的cpu上，这样大大避免了进程中缓存的丢失以及切换带来的资源消耗。而且，nginx中还会将某些字符串转换成特定的int，再进行比较，减少了指令条数（如nginx在解释请求头中的method信息时候,会将其值（post|get）转换成int类型进行比较）\n\n#### 轻量级\nnginx只保留核心功能模块，而且并不多，可进行相应扩展。\nnginx模块化开发，比较易读\n\n### 二.nginx 工作原理\n![nginx工作图解](/images/nginx/worker.jpg)\n- master进程工作范围\n    -  master负责接收外界的信号并分发给worker各个进程。worker进程会通过抢排斥锁accept_mutex来抢占资源（各个worker抢占资源是有一个算法，能均衡每个worker抢占到的资源）\n    -  master管理和监控着各个worker的运行状态。\n    -  master加载配置文件(如执行重启，关闭操作)。如重启操作，首先重新加载配置文件，fork出新的worker并通知旧的worker停止接收资源，等到旧worker已经完成了剩下的请求后就退出。\n- worker进程工作范围\n    -  每个抢到互斥锁的worker进程会进行读取请求、解释请求、处理请求、产生数据、返回客户端的步骤。\n\n### 三.nginx中对connection流程\n<center>\n\n```flow\nst=>start: 开始\nstep1=>operation: 客户端与nginx通过三次握手tcp连接,并创建好socket\nstep2=>operation: worker抢占锁并将connection封装到ngx_connection_t实体中\nstep3=>operation: 将socket设置好读写事件\nstep4=>operation: 与其他server创建连接与创建\nngx_connection_t实体并设置好读写事件\n\nstep5=>operation: 执行读写事件，完成后nginx与客户端交换数据\nstep6=>operation: 释放ngx_connection_t,nginx或客户端主动关掉连接\ncond=>condition: 是否有其他server(如upstream等)\ne=>end: 结束\nst->step1\nstep1->step2\nstep2->step3->cond\ncond(yes)->step4\ncond(no)->step5\nstep4->step5->step6->e\n```\n</center>\n\n### 四.总结\n以上是经过我这一段时间对nginx的了解作出的总结，可能会有一些偏差或者不够完善的地方。在今后会不停地去反复完善，希望能将nginx理解得更为透彻。\n\n### 五.参考\n1.  [io模式与IO](https://www.cnblogs.com/zingp/p/6863170.html)\n2.  [select模型的说明](https://www.jianshu.com/p/edb9ddd51c3d)\n3.  [nginx从入门到精通](http://tengine.taobao.org/book/)\n\n","source":"_posts/nginx原理分析.md","raw":"---\ntitle: nginx原理分析\ndate: 2017-12-05 12:00:00\ncategories: \n- nginx总结\ntags:\n- 总结\n---\n**导语:**\n>本章主要记录一下我对nginx原理的理解，以及相关的重点与难点\n\n### 一.nginx优点\n\n#### IO多路复用（重点）\n前一章中提及到了nginx能支撑高并发的一个主要原因就是使用到io多路复用的这种技术。\n\n1.  什么是io多路复用？\n定义上：获取并监听多个fd(文件描述符)，通过单个线程内完成IO的读写,复用指的是线程\n例子:某快递公司快递员（<font color=\"red\">处理线程</font>），寄件（<font color=\"red\">IO网络请求</font>）\n    * 例子一：快递员不知道哪家需要寄件，逐间逐户询问是否需要寄件，这样的话就会造成耗费时间过长，万一某一户出现某些情况，寄件人还未回来，就会一直阻塞。这就是一个典型的单线程阻塞例子。\n    * 例子二：快递公司觉得一个快递员收件太慢了，就聘请了多个快递员去收件。这样会造成一个问题就是收件速度确实比以前快，但这也会使快递公司成本变得高，造成不必要的人力浪费。这个就是多线程+阻塞的例子。\n    * 例子三：寄件方准本好需要的寄件，然后打电话通知快递员某户寄件已准备好，快递员就上门收取。这样就能用一个快递员高效的收纳寄件。这就是一个io多路复用的例子，打电话通知寄件已准备好其实可以看作io事件准备就绪主动上报的一个过程，程序机制就会对已准备好的事件做一系列的io读写操作。\n\n1. nginx的io多路复用模型有哪些？\nnginx中提供了多种io多路复用模型的机制如select,poll,epoll等。目前，linux2.6以上才能使用epoll机制。本质上,select与epoll都是属于非阻塞的同步IO.下面，我简单介绍一下select与epoll的区别。\n    - select介绍\n    ![selectIO模型图](/images/nginx/select.jpg)\n    1. 进程通过select调用，将fd集合从用户态全部复制到内核态当中，这个过程中会阻塞进程。\n    2. select会遍历的fd集合，如果存在准备就绪的fd，就会返回可读的指示并将对应连接放入监听队列中(表示监听IO数据)。在第二次遍历如果发现存在已经就绪的数据，则会调用recvfrom的方法,进程会将数据从内核态复制到用户态中并进行对应读写事件处理。处理完毕则会移除对应监听队列的socket。\n    3. 在select遍历完所有的fd都没有发现可读的fd后,则会进入休眠期。当有发现新的可读写资源，则会唤醒select进程。如果超过一定超时时间，则会重新被唤醒。重新遍历fd集合。\n        <span><font color=\"red\">\n        select总结:\n            -  每次select调用都需要遍历fd集合。\n            -  监视的文件描述符的数量存在最大限制，可以调节，但是随着增大也会导致用户态与内核态之间的复制带来的资源开销（如内存）呈线性增大\n            -  每次都要将整个集合的数据在用户态与内核到之间的互相复制。\n        </font></span>\n        \n    - epoll介绍\n    epoll的核心主要是三个函数:epoll_create(创建epoll句柄)，epoll_ctl(管理epoll注册监听事件，增删查改等)，epoll_wait(等待执行事件)\n    4. 首先调用epoll_create创建一个epoll句柄对象，epoll含有一个红黑树和一个就绪队列。\n    5. 当调用epoll_ctl创建注册监听事件时候，会为fd注册一个回调函数，并将fd从用户态复制到内核态。如果fd就绪后，会通过回掉函数将fd放入就绪队列中。\n    6. epoll_wait则会扫描就绪队列并执行相应事件,并把数据返回给用户。与select类似都是苏醒与睡眠交替进行，但是select是不停遍历整个fd集合，而epoll_wait只是遍历就绪列表就可以了，仅判断是否为空就OK拉。\n> 总结：  \n简单类比一下，其实select模型与epoll模型好比如在茶楼结账时候，服务员只告诉老板有人结账了，你过去收。此时老板并不知道具体要结账的是哪一桌，就一个一个去问（遍历fd集合是否有就绪），这是select模型做的；而epoll则是服务员具体告诉老板是那几桌要结账（利用回调函数，将就绪事件直接放到epoll队列中），老板就能直接过去结账。\n\n1. io多路复用的优缺点?\n\n| 优点 | 缺点 |\n| :---: | :---: |\n|单线程，消耗少|不适宜处理少量的请求数|\n|能支撑大并发量的请求|\n|非阻塞|\n\n#### cpu的亲和性\n能够将nginx上的worker绑定到某一特定的cpu上，这样大大避免了进程中缓存的丢失以及切换带来的资源消耗。而且，nginx中还会将某些字符串转换成特定的int，再进行比较，减少了指令条数（如nginx在解释请求头中的method信息时候,会将其值（post|get）转换成int类型进行比较）\n\n#### 轻量级\nnginx只保留核心功能模块，而且并不多，可进行相应扩展。\nnginx模块化开发，比较易读\n\n### 二.nginx 工作原理\n![nginx工作图解](/images/nginx/worker.jpg)\n- master进程工作范围\n    -  master负责接收外界的信号并分发给worker各个进程。worker进程会通过抢排斥锁accept_mutex来抢占资源（各个worker抢占资源是有一个算法，能均衡每个worker抢占到的资源）\n    -  master管理和监控着各个worker的运行状态。\n    -  master加载配置文件(如执行重启，关闭操作)。如重启操作，首先重新加载配置文件，fork出新的worker并通知旧的worker停止接收资源，等到旧worker已经完成了剩下的请求后就退出。\n- worker进程工作范围\n    -  每个抢到互斥锁的worker进程会进行读取请求、解释请求、处理请求、产生数据、返回客户端的步骤。\n\n### 三.nginx中对connection流程\n<center>\n\n```flow\nst=>start: 开始\nstep1=>operation: 客户端与nginx通过三次握手tcp连接,并创建好socket\nstep2=>operation: worker抢占锁并将connection封装到ngx_connection_t实体中\nstep3=>operation: 将socket设置好读写事件\nstep4=>operation: 与其他server创建连接与创建\nngx_connection_t实体并设置好读写事件\n\nstep5=>operation: 执行读写事件，完成后nginx与客户端交换数据\nstep6=>operation: 释放ngx_connection_t,nginx或客户端主动关掉连接\ncond=>condition: 是否有其他server(如upstream等)\ne=>end: 结束\nst->step1\nstep1->step2\nstep2->step3->cond\ncond(yes)->step4\ncond(no)->step5\nstep4->step5->step6->e\n```\n</center>\n\n### 四.总结\n以上是经过我这一段时间对nginx的了解作出的总结，可能会有一些偏差或者不够完善的地方。在今后会不停地去反复完善，希望能将nginx理解得更为透彻。\n\n### 五.参考\n1.  [io模式与IO](https://www.cnblogs.com/zingp/p/6863170.html)\n2.  [select模型的说明](https://www.jianshu.com/p/edb9ddd51c3d)\n3.  [nginx从入门到精通](http://tengine.taobao.org/book/)\n\n","slug":"nginx原理分析","published":1,"updated":"2021-09-07T08:00:52.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhro000md0tvzqoyedst","content":"<p><strong>导语:</strong></p>\n<blockquote>\n<p>本章主要记录一下我对nginx原理的理解，以及相关的重点与难点</p>\n</blockquote>\n<h3 id=\"一-nginx优点\"><a href=\"#一-nginx优点\" class=\"headerlink\" title=\"一.nginx优点\"></a>一.nginx优点</h3><h4 id=\"IO多路复用（重点）\"><a href=\"#IO多路复用（重点）\" class=\"headerlink\" title=\"IO多路复用（重点）\"></a>IO多路复用（重点）</h4><p>前一章中提及到了nginx能支撑高并发的一个主要原因就是使用到io多路复用的这种技术。</p>\n<ol>\n<li><p>什么是io多路复用？<br>定义上：获取并监听多个fd(文件描述符)，通过单个线程内完成IO的读写,复用指的是线程<br>例子:某快递公司快递员（<font color=\"red\">处理线程</font>），寄件（<font color=\"red\">IO网络请求</font>）</p>\n<ul>\n<li>例子一：快递员不知道哪家需要寄件，逐间逐户询问是否需要寄件，这样的话就会造成耗费时间过长，万一某一户出现某些情况，寄件人还未回来，就会一直阻塞。这就是一个典型的单线程阻塞例子。</li>\n<li>例子二：快递公司觉得一个快递员收件太慢了，就聘请了多个快递员去收件。这样会造成一个问题就是收件速度确实比以前快，但这也会使快递公司成本变得高，造成不必要的人力浪费。这个就是多线程+阻塞的例子。</li>\n<li>例子三：寄件方准本好需要的寄件，然后打电话通知快递员某户寄件已准备好，快递员就上门收取。这样就能用一个快递员高效的收纳寄件。这就是一个io多路复用的例子，打电话通知寄件已准备好其实可以看作io事件准备就绪主动上报的一个过程，程序机制就会对已准备好的事件做一系列的io读写操作。</li>\n</ul>\n</li>\n<li><p>nginx的io多路复用模型有哪些？<br>nginx中提供了多种io多路复用模型的机制如select,poll,epoll等。目前，linux2.6以上才能使用epoll机制。本质上,select与epoll都是属于非阻塞的同步IO.下面，我简单介绍一下select与epoll的区别。</p>\n<ul>\n<li>select介绍<br><img src=\"/images/nginx/select.jpg\" alt=\"selectIO模型图\"></li>\n</ul>\n<ol>\n<li>进程通过select调用，将fd集合从用户态全部复制到内核态当中，这个过程中会阻塞进程。</li>\n<li>select会遍历的fd集合，如果存在准备就绪的fd，就会返回可读的指示并将对应连接放入监听队列中(表示监听IO数据)。在第二次遍历如果发现存在已经就绪的数据，则会调用recvfrom的方法,进程会将数据从内核态复制到用户态中并进行对应读写事件处理。处理完毕则会移除对应监听队列的socket。</li>\n<li>在select遍历完所有的fd都没有发现可读的fd后,则会进入休眠期。当有发现新的可读写资源，则会唤醒select进程。如果超过一定超时时间，则会重新被唤醒。重新遍历fd集合。<br> <span><font color=\"red\"><br> select总结:<pre><code>-  每次select调用都需要遍历fd集合。\n-  监视的文件描述符的数量存在最大限制，可以调节，但是随着增大也会导致用户态与内核态之间的复制带来的资源开销（如内存）呈线性增大\n-  每次都要将整个集合的数据在用户态与内核到之间的互相复制。\n</code></pre> </font></span></li>\n</ol>\n<ul>\n<li>epoll介绍<br>epoll的核心主要是三个函数:epoll_create(创建epoll句柄)，epoll_ctl(管理epoll注册监听事件，增删查改等)，epoll_wait(等待执行事件)</li>\n</ul>\n<ol>\n<li>首先调用epoll_create创建一个epoll句柄对象，epoll含有一个红黑树和一个就绪队列。</li>\n<li>当调用epoll_ctl创建注册监听事件时候，会为fd注册一个回调函数，并将fd从用户态复制到内核态。如果fd就绪后，会通过回掉函数将fd放入就绪队列中。</li>\n<li>epoll_wait则会扫描就绪队列并执行相应事件,并把数据返回给用户。与select类似都是苏醒与睡眠交替进行，但是select是不停遍历整个fd集合，而epoll_wait只是遍历就绪列表就可以了，仅判断是否为空就OK拉。<blockquote>\n<p>总结：<br>简单类比一下，其实select模型与epoll模型好比如在茶楼结账时候，服务员只告诉老板有人结账了，你过去收。此时老板并不知道具体要结账的是哪一桌，就一个一个去问（遍历fd集合是否有就绪），这是select模型做的；而epoll则是服务员具体告诉老板是那几桌要结账（利用回调函数，将就绪事件直接放到epoll队列中），老板就能直接过去结账。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>io多路复用的优缺点?</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">单线程，消耗少</td>\n<td style=\"text-align:center\">不适宜处理少量的请求数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">能支撑大并发量的请求</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">非阻塞</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"cpu的亲和性\"><a href=\"#cpu的亲和性\" class=\"headerlink\" title=\"cpu的亲和性\"></a>cpu的亲和性</h4><p>能够将nginx上的worker绑定到某一特定的cpu上，这样大大避免了进程中缓存的丢失以及切换带来的资源消耗。而且，nginx中还会将某些字符串转换成特定的int，再进行比较，减少了指令条数（如nginx在解释请求头中的method信息时候,会将其值（post|get）转换成int类型进行比较）</p>\n<h4 id=\"轻量级\"><a href=\"#轻量级\" class=\"headerlink\" title=\"轻量级\"></a>轻量级</h4><p>nginx只保留核心功能模块，而且并不多，可进行相应扩展。<br>nginx模块化开发，比较易读</p>\n<h3 id=\"二-nginx-工作原理\"><a href=\"#二-nginx-工作原理\" class=\"headerlink\" title=\"二.nginx 工作原理\"></a>二.nginx 工作原理</h3><p><img src=\"/images/nginx/worker.jpg\" alt=\"nginx工作图解\"></p>\n<ul>\n<li>master进程工作范围<ul>\n<li>master负责接收外界的信号并分发给worker各个进程。worker进程会通过抢排斥锁accept_mutex来抢占资源（各个worker抢占资源是有一个算法，能均衡每个worker抢占到的资源）</li>\n<li>master管理和监控着各个worker的运行状态。</li>\n<li>master加载配置文件(如执行重启，关闭操作)。如重启操作，首先重新加载配置文件，fork出新的worker并通知旧的worker停止接收资源，等到旧worker已经完成了剩下的请求后就退出。</li>\n</ul>\n</li>\n<li>worker进程工作范围<ul>\n<li>每个抢到互斥锁的worker进程会进行读取请求、解释请求、处理请求、产生数据、返回客户端的步骤。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三-nginx中对connection流程\"><a href=\"#三-nginx中对connection流程\" class=\"headerlink\" title=\"三.nginx中对connection流程\"></a>三.nginx中对connection流程</h3><center><br><br><div id=\"flowchart-0\" class=\"flow-chart\"></div><br></center>\n\n<h3 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四.总结\"></a>四.总结</h3><p>以上是经过我这一段时间对nginx的了解作出的总结，可能会有一些偏差或者不够完善的地方。在今后会不停地去反复完善，希望能将nginx理解得更为透彻。</p>\n<h3 id=\"五-参考\"><a href=\"#五-参考\" class=\"headerlink\" title=\"五.参考\"></a>五.参考</h3><ol>\n<li><a href=\"https://www.cnblogs.com/zingp/p/6863170.html\" target=\"_blank\" rel=\"noopener\">io模式与IO</a></li>\n<li><a href=\"https://www.jianshu.com/p/edb9ddd51c3d\" target=\"_blank\" rel=\"noopener\">select模型的说明</a></li>\n<li><a href=\"http://tengine.taobao.org/book/\" target=\"_blank\" rel=\"noopener\">nginx从入门到精通</a></li>\n</ol>\n<p><script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: 开始\nstep1=>operation: 客户端与nginx通过三次握手tcp连接,并创建好socket\nstep2=>operation: worker抢占锁并将connection封装到ngx_connection_t实体中\nstep3=>operation: 将socket设置好读写事件\nstep4=>operation: 与其他server创建连接与创建\nngx_connection_t实体并设置好读写事件\n\nstep5=>operation: 执行读写事件，完成后nginx与客户端交换数据\nstep6=>operation: 释放ngx_connection_t,nginx或客户端主动关掉连接\ncond=>condition: 是否有其他server(如upstream等)\ne=>end: 结束\nst->step1\nstep1->step2\nstep2->step3->cond\ncond(yes)->step4\ncond(no)->step5\nstep4->step5->step6->e</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>导语:</strong></p>\n<blockquote>\n<p>本章主要记录一下我对nginx原理的理解，以及相关的重点与难点</p>\n</blockquote>\n<h3 id=\"一-nginx优点\"><a href=\"#一-nginx优点\" class=\"headerlink\" title=\"一.nginx优点\"></a>一.nginx优点</h3><h4 id=\"IO多路复用（重点）\"><a href=\"#IO多路复用（重点）\" class=\"headerlink\" title=\"IO多路复用（重点）\"></a>IO多路复用（重点）</h4><p>前一章中提及到了nginx能支撑高并发的一个主要原因就是使用到io多路复用的这种技术。</p>\n<ol>\n<li><p>什么是io多路复用？<br>定义上：获取并监听多个fd(文件描述符)，通过单个线程内完成IO的读写,复用指的是线程<br>例子:某快递公司快递员（<font color=\"red\">处理线程</font>），寄件（<font color=\"red\">IO网络请求</font>）</p>\n<ul>\n<li>例子一：快递员不知道哪家需要寄件，逐间逐户询问是否需要寄件，这样的话就会造成耗费时间过长，万一某一户出现某些情况，寄件人还未回来，就会一直阻塞。这就是一个典型的单线程阻塞例子。</li>\n<li>例子二：快递公司觉得一个快递员收件太慢了，就聘请了多个快递员去收件。这样会造成一个问题就是收件速度确实比以前快，但这也会使快递公司成本变得高，造成不必要的人力浪费。这个就是多线程+阻塞的例子。</li>\n<li>例子三：寄件方准本好需要的寄件，然后打电话通知快递员某户寄件已准备好，快递员就上门收取。这样就能用一个快递员高效的收纳寄件。这就是一个io多路复用的例子，打电话通知寄件已准备好其实可以看作io事件准备就绪主动上报的一个过程，程序机制就会对已准备好的事件做一系列的io读写操作。</li>\n</ul>\n</li>\n<li><p>nginx的io多路复用模型有哪些？<br>nginx中提供了多种io多路复用模型的机制如select,poll,epoll等。目前，linux2.6以上才能使用epoll机制。本质上,select与epoll都是属于非阻塞的同步IO.下面，我简单介绍一下select与epoll的区别。</p>\n<ul>\n<li>select介绍<br><img src=\"/images/nginx/select.jpg\" alt=\"selectIO模型图\"></li>\n</ul>\n<ol>\n<li>进程通过select调用，将fd集合从用户态全部复制到内核态当中，这个过程中会阻塞进程。</li>\n<li>select会遍历的fd集合，如果存在准备就绪的fd，就会返回可读的指示并将对应连接放入监听队列中(表示监听IO数据)。在第二次遍历如果发现存在已经就绪的数据，则会调用recvfrom的方法,进程会将数据从内核态复制到用户态中并进行对应读写事件处理。处理完毕则会移除对应监听队列的socket。</li>\n<li>在select遍历完所有的fd都没有发现可读的fd后,则会进入休眠期。当有发现新的可读写资源，则会唤醒select进程。如果超过一定超时时间，则会重新被唤醒。重新遍历fd集合。<br> <span><font color=\"red\"><br> select总结:<pre><code>-  每次select调用都需要遍历fd集合。\n-  监视的文件描述符的数量存在最大限制，可以调节，但是随着增大也会导致用户态与内核态之间的复制带来的资源开销（如内存）呈线性增大\n-  每次都要将整个集合的数据在用户态与内核到之间的互相复制。\n</code></pre> </font></span></li>\n</ol>\n<ul>\n<li>epoll介绍<br>epoll的核心主要是三个函数:epoll_create(创建epoll句柄)，epoll_ctl(管理epoll注册监听事件，增删查改等)，epoll_wait(等待执行事件)</li>\n</ul>\n<ol>\n<li>首先调用epoll_create创建一个epoll句柄对象，epoll含有一个红黑树和一个就绪队列。</li>\n<li>当调用epoll_ctl创建注册监听事件时候，会为fd注册一个回调函数，并将fd从用户态复制到内核态。如果fd就绪后，会通过回掉函数将fd放入就绪队列中。</li>\n<li>epoll_wait则会扫描就绪队列并执行相应事件,并把数据返回给用户。与select类似都是苏醒与睡眠交替进行，但是select是不停遍历整个fd集合，而epoll_wait只是遍历就绪列表就可以了，仅判断是否为空就OK拉。<blockquote>\n<p>总结：<br>简单类比一下，其实select模型与epoll模型好比如在茶楼结账时候，服务员只告诉老板有人结账了，你过去收。此时老板并不知道具体要结账的是哪一桌，就一个一个去问（遍历fd集合是否有就绪），这是select模型做的；而epoll则是服务员具体告诉老板是那几桌要结账（利用回调函数，将就绪事件直接放到epoll队列中），老板就能直接过去结账。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>io多路复用的优缺点?</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">单线程，消耗少</td>\n<td style=\"text-align:center\">不适宜处理少量的请求数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">能支撑大并发量的请求</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">非阻塞</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"cpu的亲和性\"><a href=\"#cpu的亲和性\" class=\"headerlink\" title=\"cpu的亲和性\"></a>cpu的亲和性</h4><p>能够将nginx上的worker绑定到某一特定的cpu上，这样大大避免了进程中缓存的丢失以及切换带来的资源消耗。而且，nginx中还会将某些字符串转换成特定的int，再进行比较，减少了指令条数（如nginx在解释请求头中的method信息时候,会将其值（post|get）转换成int类型进行比较）</p>\n<h4 id=\"轻量级\"><a href=\"#轻量级\" class=\"headerlink\" title=\"轻量级\"></a>轻量级</h4><p>nginx只保留核心功能模块，而且并不多，可进行相应扩展。<br>nginx模块化开发，比较易读</p>\n<h3 id=\"二-nginx-工作原理\"><a href=\"#二-nginx-工作原理\" class=\"headerlink\" title=\"二.nginx 工作原理\"></a>二.nginx 工作原理</h3><p><img src=\"/images/nginx/worker.jpg\" alt=\"nginx工作图解\"></p>\n<ul>\n<li>master进程工作范围<ul>\n<li>master负责接收外界的信号并分发给worker各个进程。worker进程会通过抢排斥锁accept_mutex来抢占资源（各个worker抢占资源是有一个算法，能均衡每个worker抢占到的资源）</li>\n<li>master管理和监控着各个worker的运行状态。</li>\n<li>master加载配置文件(如执行重启，关闭操作)。如重启操作，首先重新加载配置文件，fork出新的worker并通知旧的worker停止接收资源，等到旧worker已经完成了剩下的请求后就退出。</li>\n</ul>\n</li>\n<li>worker进程工作范围<ul>\n<li>每个抢到互斥锁的worker进程会进行读取请求、解释请求、处理请求、产生数据、返回客户端的步骤。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三-nginx中对connection流程\"><a href=\"#三-nginx中对connection流程\" class=\"headerlink\" title=\"三.nginx中对connection流程\"></a>三.nginx中对connection流程</h3><center><br><br><div id=\"flowchart-0\" class=\"flow-chart\"></div><br></center>\n\n<h3 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四.总结\"></a>四.总结</h3><p>以上是经过我这一段时间对nginx的了解作出的总结，可能会有一些偏差或者不够完善的地方。在今后会不停地去反复完善，希望能将nginx理解得更为透彻。</p>\n<h3 id=\"五-参考\"><a href=\"#五-参考\" class=\"headerlink\" title=\"五.参考\"></a>五.参考</h3><ol>\n<li><a href=\"https://www.cnblogs.com/zingp/p/6863170.html\" target=\"_blank\" rel=\"noopener\">io模式与IO</a></li>\n<li><a href=\"https://www.jianshu.com/p/edb9ddd51c3d\" target=\"_blank\" rel=\"noopener\">select模型的说明</a></li>\n<li><a href=\"http://tengine.taobao.org/book/\" target=\"_blank\" rel=\"noopener\">nginx从入门到精通</a></li>\n</ol>\n<p><script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: 开始\nstep1=>operation: 客户端与nginx通过三次握手tcp连接,并创建好socket\nstep2=>operation: worker抢占锁并将connection封装到ngx_connection_t实体中\nstep3=>operation: 将socket设置好读写事件\nstep4=>operation: 与其他server创建连接与创建\nngx_connection_t实体并设置好读写事件\n\nstep5=>operation: 执行读写事件，完成后nginx与客户端交换数据\nstep6=>operation: 释放ngx_connection_t,nginx或客户端主动关掉连接\ncond=>condition: 是否有其他server(如upstream等)\ne=>end: 结束\nst->step1\nstep1->step2\nstep2->step3->cond\ncond(yes)->step4\ncond(no)->step5\nstep4->step5->step6->e</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script></p>\n"},{"title":"nginx的搭建","date":"2017-11-30T04:00:00.000Z","_content":"\n### nginx是什么\nnginx是一个开源且高性能、可靠的http中间件、代理服务\n\n### 为什么使用nginx（详细在下一章总结）\n- io多路复用(select,epoll等模型实现)\n- cpu亲和性\n- 轻量级\n\n### nginx的使用场景 （详细在另外一章总结）\n1. 代理服务\n    1. 正向代理\n    2. 反向代理\n2. 缓存服务\n3. https服务\n4. 静态web服务\n    1. 跨域\n    2. 防盗链\n    3. 客户端缓存\n5. 动静分离\n6. nginx+lua \n    1. 流量监控\n    2. waf\n    3. 灰度发布(建议使用openresty)\n7. rewrite规则\n    1. 后台维护页面\n    2. seo搜索优化\n    3. 安全（伪静态）\n    4. url访问跳转（新旧域名替换）\n\n### nginx下linux的部署(fedora27)\n    简单说明下安装nginx的所需要的依赖，并不做详细讲解\n1. 下载prec,zlib,openssl\n2. yum install -y gcc g++ (c编译工具)\n3. yum install -y pcre pcre-devel(重写rewrite,正则表达式)\n4. yum install -y zlib zlib-devel(gzip压缩)\n5. yum install -y openssl openssl-devel\n6. 下载nginx（可到官网上下载.tar文件）\n7. 解压 tar -zxvf nginx-xxxx.tar.gz\n8. 进入解压目录，并执行./configure --prefix=/usr/local/nginx  \n9. make && make install\n\n### nginx的目录配置说明\n├── auto            自动检测系统环境以及编译相关的脚本\n│   ├── cc          关于编译器相关的编译选项的检测脚本\n│   ├── lib         nginx编译所需要的一些库的检测脚本\n│   ├── os          与平台相关的一些系统参数与系统调用相关的检测\n│   └── types       与数据类型相关的一些辅助脚本\n├── conf            存放默认配置文件，在make install后，会拷贝到安装目录中去\n├── contrib         存放一些实用工具，如geo配置生成工具（geo2nginx.pl）\n├── html            存放默认的网页文件，在make install后，会拷贝到安装目录中去\n├── man             nginx的man手册\n└── src             存放nginx的源代码\n    ├── core        nginx的核心源代码，包括常用数据结构的定义，以及nginx初始化运行的核心代码如main函数\n    ├── event       对系统事件处理机制的封装，以及定时器的实现相关代码\n    │   └── modules 不同事件处理方式的模块化，如select、poll、epoll、kqueue\n    ├── http        nginx作为http服务器相关的代码\n    │   └── modules 包含http的各种功能模块\n    ├── mail        nginx作为邮件代理服务器相关的代码\n    ├── misc        一些辅助代码，测试c++头的兼容性，以及对google_perftools的支持\n    └── os          主要是对各种不同体系统结构所提供的系统函数的封装，对外提供统一的系统调用接口\n\n\n\n### nginx相关命令\n```nginx\n./nginx 启动\n./nginx -s stop 关闭\n./nginx -s reload 重启\n./nginx -tc nginx 配置文件   检测nginx配置文件语法\n```\n\n### **<font color=\"red\"> 注意 </font>**\n- 在重新编译nginx时候，先将原有的nginx二进制文件备份,再执行./configure && make && make install 以免被新的nginx覆盖\n- 若直接使用yum最新版本的openssl,则会在编译某些旧版本nginx的时候出现不兼容的情况。原因是由于openssl新版本改动得挺大导致。解决方案\n    - 升级nginx版本\n    - 降级openssl的版本(额外章会记录如何降级，这里遇到了一个坑) \n\n### 参考文献\n1. [nginx从入门到精通](http://tengine.taobao.org/book/)\n2. [nginx中文官方文档](http://www.nginx.cn/doc/)\n","source":"_posts/nginx搭建与部署.md","raw":"---\ntitle: nginx的搭建\ndate: 2017-12-00 12:00:00\ncategories: \n- nginx总结\ntags:\n- 总结\n---\n\n### nginx是什么\nnginx是一个开源且高性能、可靠的http中间件、代理服务\n\n### 为什么使用nginx（详细在下一章总结）\n- io多路复用(select,epoll等模型实现)\n- cpu亲和性\n- 轻量级\n\n### nginx的使用场景 （详细在另外一章总结）\n1. 代理服务\n    1. 正向代理\n    2. 反向代理\n2. 缓存服务\n3. https服务\n4. 静态web服务\n    1. 跨域\n    2. 防盗链\n    3. 客户端缓存\n5. 动静分离\n6. nginx+lua \n    1. 流量监控\n    2. waf\n    3. 灰度发布(建议使用openresty)\n7. rewrite规则\n    1. 后台维护页面\n    2. seo搜索优化\n    3. 安全（伪静态）\n    4. url访问跳转（新旧域名替换）\n\n### nginx下linux的部署(fedora27)\n    简单说明下安装nginx的所需要的依赖，并不做详细讲解\n1. 下载prec,zlib,openssl\n2. yum install -y gcc g++ (c编译工具)\n3. yum install -y pcre pcre-devel(重写rewrite,正则表达式)\n4. yum install -y zlib zlib-devel(gzip压缩)\n5. yum install -y openssl openssl-devel\n6. 下载nginx（可到官网上下载.tar文件）\n7. 解压 tar -zxvf nginx-xxxx.tar.gz\n8. 进入解压目录，并执行./configure --prefix=/usr/local/nginx  \n9. make && make install\n\n### nginx的目录配置说明\n├── auto            自动检测系统环境以及编译相关的脚本\n│   ├── cc          关于编译器相关的编译选项的检测脚本\n│   ├── lib         nginx编译所需要的一些库的检测脚本\n│   ├── os          与平台相关的一些系统参数与系统调用相关的检测\n│   └── types       与数据类型相关的一些辅助脚本\n├── conf            存放默认配置文件，在make install后，会拷贝到安装目录中去\n├── contrib         存放一些实用工具，如geo配置生成工具（geo2nginx.pl）\n├── html            存放默认的网页文件，在make install后，会拷贝到安装目录中去\n├── man             nginx的man手册\n└── src             存放nginx的源代码\n    ├── core        nginx的核心源代码，包括常用数据结构的定义，以及nginx初始化运行的核心代码如main函数\n    ├── event       对系统事件处理机制的封装，以及定时器的实现相关代码\n    │   └── modules 不同事件处理方式的模块化，如select、poll、epoll、kqueue\n    ├── http        nginx作为http服务器相关的代码\n    │   └── modules 包含http的各种功能模块\n    ├── mail        nginx作为邮件代理服务器相关的代码\n    ├── misc        一些辅助代码，测试c++头的兼容性，以及对google_perftools的支持\n    └── os          主要是对各种不同体系统结构所提供的系统函数的封装，对外提供统一的系统调用接口\n\n\n\n### nginx相关命令\n```nginx\n./nginx 启动\n./nginx -s stop 关闭\n./nginx -s reload 重启\n./nginx -tc nginx 配置文件   检测nginx配置文件语法\n```\n\n### **<font color=\"red\"> 注意 </font>**\n- 在重新编译nginx时候，先将原有的nginx二进制文件备份,再执行./configure && make && make install 以免被新的nginx覆盖\n- 若直接使用yum最新版本的openssl,则会在编译某些旧版本nginx的时候出现不兼容的情况。原因是由于openssl新版本改动得挺大导致。解决方案\n    - 升级nginx版本\n    - 降级openssl的版本(额外章会记录如何降级，这里遇到了一个坑) \n\n### 参考文献\n1. [nginx从入门到精通](http://tengine.taobao.org/book/)\n2. [nginx中文官方文档](http://www.nginx.cn/doc/)\n","slug":"nginx搭建与部署","published":1,"updated":"2021-09-07T08:00:52.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhrr000rd0tv1732ls6x","content":"<h3 id=\"nginx是什么\"><a href=\"#nginx是什么\" class=\"headerlink\" title=\"nginx是什么\"></a>nginx是什么</h3><p>nginx是一个开源且高性能、可靠的http中间件、代理服务</p>\n<h3 id=\"为什么使用nginx（详细在下一章总结）\"><a href=\"#为什么使用nginx（详细在下一章总结）\" class=\"headerlink\" title=\"为什么使用nginx（详细在下一章总结）\"></a>为什么使用nginx（详细在下一章总结）</h3><ul>\n<li>io多路复用(select,epoll等模型实现)</li>\n<li>cpu亲和性</li>\n<li>轻量级</li>\n</ul>\n<h3 id=\"nginx的使用场景-（详细在另外一章总结）\"><a href=\"#nginx的使用场景-（详细在另外一章总结）\" class=\"headerlink\" title=\"nginx的使用场景 （详细在另外一章总结）\"></a>nginx的使用场景 （详细在另外一章总结）</h3><ol>\n<li>代理服务<ol>\n<li>正向代理</li>\n<li>反向代理</li>\n</ol>\n</li>\n<li>缓存服务</li>\n<li>https服务</li>\n<li>静态web服务<ol>\n<li>跨域</li>\n<li>防盗链</li>\n<li>客户端缓存</li>\n</ol>\n</li>\n<li>动静分离</li>\n<li>nginx+lua <ol>\n<li>流量监控</li>\n<li>waf</li>\n<li>灰度发布(建议使用openresty)</li>\n</ol>\n</li>\n<li>rewrite规则<ol>\n<li>后台维护页面</li>\n<li>seo搜索优化</li>\n<li>安全（伪静态）</li>\n<li>url访问跳转（新旧域名替换）</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"nginx下linux的部署-fedora27\"><a href=\"#nginx下linux的部署-fedora27\" class=\"headerlink\" title=\"nginx下linux的部署(fedora27)\"></a>nginx下linux的部署(fedora27)</h3><pre><code>简单说明下安装nginx的所需要的依赖，并不做详细讲解\n</code></pre><ol>\n<li>下载prec,zlib,openssl</li>\n<li>yum install -y gcc g++ (c编译工具)</li>\n<li>yum install -y pcre pcre-devel(重写rewrite,正则表达式)</li>\n<li>yum install -y zlib zlib-devel(gzip压缩)</li>\n<li>yum install -y openssl openssl-devel</li>\n<li>下载nginx（可到官网上下载.tar文件）</li>\n<li>解压 tar -zxvf nginx-xxxx.tar.gz</li>\n<li>进入解压目录，并执行./configure –prefix=/usr/local/nginx  </li>\n<li>make &amp;&amp; make install</li>\n</ol>\n<h3 id=\"nginx的目录配置说明\"><a href=\"#nginx的目录配置说明\" class=\"headerlink\" title=\"nginx的目录配置说明\"></a>nginx的目录配置说明</h3><p>├── auto            自动检测系统环境以及编译相关的脚本<br>│   ├── cc          关于编译器相关的编译选项的检测脚本<br>│   ├── lib         nginx编译所需要的一些库的检测脚本<br>│   ├── os          与平台相关的一些系统参数与系统调用相关的检测<br>│   └── types       与数据类型相关的一些辅助脚本<br>├── conf            存放默认配置文件，在make install后，会拷贝到安装目录中去<br>├── contrib         存放一些实用工具，如geo配置生成工具（geo2nginx.pl）<br>├── html            存放默认的网页文件，在make install后，会拷贝到安装目录中去<br>├── man             nginx的man手册<br>└── src             存放nginx的源代码<br>    ├── core        nginx的核心源代码，包括常用数据结构的定义，以及nginx初始化运行的核心代码如main函数<br>    ├── event       对系统事件处理机制的封装，以及定时器的实现相关代码<br>    │   └── modules 不同事件处理方式的模块化，如select、poll、epoll、kqueue<br>    ├── http        nginx作为http服务器相关的代码<br>    │   └── modules 包含http的各种功能模块<br>    ├── mail        nginx作为邮件代理服务器相关的代码<br>    ├── misc        一些辅助代码，测试c++头的兼容性，以及对google_perftools的支持<br>    └── os          主要是对各种不同体系统结构所提供的系统函数的封装，对外提供统一的系统调用接口</p>\n<h3 id=\"nginx相关命令\"><a href=\"#nginx相关命令\" class=\"headerlink\" title=\"nginx相关命令\"></a>nginx相关命令</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./nginx 启动</span><br><span class=\"line\">./nginx -s stop 关闭</span><br><span class=\"line\">./nginx -s reload 重启</span><br><span class=\"line\">./nginx -tc nginx 配置文件   检测nginx配置文件语法</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\" 注意 \"></a><strong><font color=\"red\"> 注意 </font></strong></h3><ul>\n<li>在重新编译nginx时候，先将原有的nginx二进制文件备份,再执行./configure &amp;&amp; make &amp;&amp; make install 以免被新的nginx覆盖</li>\n<li>若直接使用yum最新版本的openssl,则会在编译某些旧版本nginx的时候出现不兼容的情况。原因是由于openssl新版本改动得挺大导致。解决方案<ul>\n<li>升级nginx版本</li>\n<li>降级openssl的版本(额外章会记录如何降级，这里遇到了一个坑) </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ol>\n<li><a href=\"http://tengine.taobao.org/book/\" target=\"_blank\" rel=\"noopener\">nginx从入门到精通</a></li>\n<li><a href=\"http://www.nginx.cn/doc/\" target=\"_blank\" rel=\"noopener\">nginx中文官方文档</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"nginx是什么\"><a href=\"#nginx是什么\" class=\"headerlink\" title=\"nginx是什么\"></a>nginx是什么</h3><p>nginx是一个开源且高性能、可靠的http中间件、代理服务</p>\n<h3 id=\"为什么使用nginx（详细在下一章总结）\"><a href=\"#为什么使用nginx（详细在下一章总结）\" class=\"headerlink\" title=\"为什么使用nginx（详细在下一章总结）\"></a>为什么使用nginx（详细在下一章总结）</h3><ul>\n<li>io多路复用(select,epoll等模型实现)</li>\n<li>cpu亲和性</li>\n<li>轻量级</li>\n</ul>\n<h3 id=\"nginx的使用场景-（详细在另外一章总结）\"><a href=\"#nginx的使用场景-（详细在另外一章总结）\" class=\"headerlink\" title=\"nginx的使用场景 （详细在另外一章总结）\"></a>nginx的使用场景 （详细在另外一章总结）</h3><ol>\n<li>代理服务<ol>\n<li>正向代理</li>\n<li>反向代理</li>\n</ol>\n</li>\n<li>缓存服务</li>\n<li>https服务</li>\n<li>静态web服务<ol>\n<li>跨域</li>\n<li>防盗链</li>\n<li>客户端缓存</li>\n</ol>\n</li>\n<li>动静分离</li>\n<li>nginx+lua <ol>\n<li>流量监控</li>\n<li>waf</li>\n<li>灰度发布(建议使用openresty)</li>\n</ol>\n</li>\n<li>rewrite规则<ol>\n<li>后台维护页面</li>\n<li>seo搜索优化</li>\n<li>安全（伪静态）</li>\n<li>url访问跳转（新旧域名替换）</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"nginx下linux的部署-fedora27\"><a href=\"#nginx下linux的部署-fedora27\" class=\"headerlink\" title=\"nginx下linux的部署(fedora27)\"></a>nginx下linux的部署(fedora27)</h3><pre><code>简单说明下安装nginx的所需要的依赖，并不做详细讲解\n</code></pre><ol>\n<li>下载prec,zlib,openssl</li>\n<li>yum install -y gcc g++ (c编译工具)</li>\n<li>yum install -y pcre pcre-devel(重写rewrite,正则表达式)</li>\n<li>yum install -y zlib zlib-devel(gzip压缩)</li>\n<li>yum install -y openssl openssl-devel</li>\n<li>下载nginx（可到官网上下载.tar文件）</li>\n<li>解压 tar -zxvf nginx-xxxx.tar.gz</li>\n<li>进入解压目录，并执行./configure –prefix=/usr/local/nginx  </li>\n<li>make &amp;&amp; make install</li>\n</ol>\n<h3 id=\"nginx的目录配置说明\"><a href=\"#nginx的目录配置说明\" class=\"headerlink\" title=\"nginx的目录配置说明\"></a>nginx的目录配置说明</h3><p>├── auto            自动检测系统环境以及编译相关的脚本<br>│   ├── cc          关于编译器相关的编译选项的检测脚本<br>│   ├── lib         nginx编译所需要的一些库的检测脚本<br>│   ├── os          与平台相关的一些系统参数与系统调用相关的检测<br>│   └── types       与数据类型相关的一些辅助脚本<br>├── conf            存放默认配置文件，在make install后，会拷贝到安装目录中去<br>├── contrib         存放一些实用工具，如geo配置生成工具（geo2nginx.pl）<br>├── html            存放默认的网页文件，在make install后，会拷贝到安装目录中去<br>├── man             nginx的man手册<br>└── src             存放nginx的源代码<br>    ├── core        nginx的核心源代码，包括常用数据结构的定义，以及nginx初始化运行的核心代码如main函数<br>    ├── event       对系统事件处理机制的封装，以及定时器的实现相关代码<br>    │   └── modules 不同事件处理方式的模块化，如select、poll、epoll、kqueue<br>    ├── http        nginx作为http服务器相关的代码<br>    │   └── modules 包含http的各种功能模块<br>    ├── mail        nginx作为邮件代理服务器相关的代码<br>    ├── misc        一些辅助代码，测试c++头的兼容性，以及对google_perftools的支持<br>    └── os          主要是对各种不同体系统结构所提供的系统函数的封装，对外提供统一的系统调用接口</p>\n<h3 id=\"nginx相关命令\"><a href=\"#nginx相关命令\" class=\"headerlink\" title=\"nginx相关命令\"></a>nginx相关命令</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./nginx 启动</span><br><span class=\"line\">./nginx -s stop 关闭</span><br><span class=\"line\">./nginx -s reload 重启</span><br><span class=\"line\">./nginx -tc nginx 配置文件   检测nginx配置文件语法</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\" 注意 \"></a><strong><font color=\"red\"> 注意 </font></strong></h3><ul>\n<li>在重新编译nginx时候，先将原有的nginx二进制文件备份,再执行./configure &amp;&amp; make &amp;&amp; make install 以免被新的nginx覆盖</li>\n<li>若直接使用yum最新版本的openssl,则会在编译某些旧版本nginx的时候出现不兼容的情况。原因是由于openssl新版本改动得挺大导致。解决方案<ul>\n<li>升级nginx版本</li>\n<li>降级openssl的版本(额外章会记录如何降级，这里遇到了一个坑) </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ol>\n<li><a href=\"http://tengine.taobao.org/book/\" target=\"_blank\" rel=\"noopener\">nginx从入门到精通</a></li>\n<li><a href=\"http://www.nginx.cn/doc/\" target=\"_blank\" rel=\"noopener\">nginx中文官方文档</a></li>\n</ol>\n"},{"title":"nginx支持流媒体","date":"2021-07-25T03:16:39.000Z","_content":"\n## 简介\n本章介绍如何搭建一个nginx的流媒体服务器，可以直接通过nginx访问hls的m3u8与rtmp的链接。\n\n## 安装\n\n安装nginx其实没有什么值得说，主要是要下载nginx的nginx-rtmp-module模块,编译时候加下此模块就OK了\n\n下载nginx-rtmp-module：https://github.com/arut/nginx-rtmp-module\n\n```\n./configure --prefix=/usr/local/nginx --with-pcre=/home/user/pcre/pcre-8.32 --with-zlib=/home/user/zlib/zlib-1.2.8 --with-openssl=/home/user/openssl/openssl-1.0.1i  --add-module=/home/user/nginx-rtmp-module\n```\n\n## 配置\n\n- RTMP\n```\nrtmp {                #RTMP服务\n   server {\n       listen 1935;  #//服务端口\n       chunk_size 4096;   #//数据传输块的大小\n       application vod {\n         play /opt/video/vod; #//视频文件存放位置。\n       }\n   }\n}\n\n\nhttp {\n    include      mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen      80;\n        server_name  localhost;\n        \n        #配置nginx的rtmp一览页面\n        location /stat {\n                rtmp_stat all;\n            rtmp_stat_stylesheet stat.xsl;\n        }\n        location /stat.xsl {\n           root /etc/rtmpServer/nginx-rtmp-module/;\n        }\n\n        location / {\n            root  html;\n            index  index.html index.htm;\n        }\n\n        error_page  500 502 503 504  /50x.html;\n        location = /50x.html {\n            root  html;\n        }\n    }\n}\n```\n\n\n- HLS\n\n该配置是播放hls的配置\n```\nlocation /hls {  \n    types{  \n        application/vnd.apple.mpegurl m3u8;  \n        video/mp2t ts;  \n    }  \n    suffix m3u8;\n   #配置一个根路径 \n   root /data/baiyun/; \n   add_header Cache-Control no-cache;\n   add_header 'Access-Control-Allow-Origin' '*';\n   add_header 'Access-Control-Allow-Credentials' 'true';\n}\n```\n\n该配置是支持远程推流到nginx负责切片成m3u8的配置\n```\nrtmp {\n    server {\n        listen 1935;\n        chunk_size 4000;\n        #HLS\n        application hls {\n            live on;\n            hls on;\n            #视频流存放地址\n            hls_path /usr/local/nginx/html/hls; \n            hls_fragment 5s;\n        }\n    }\n}\n```\n\n## 参考\n[视频直播点播nginx-rtmp开发手册中文版](https://blog.csdn.net/weiyuefei/article/details/74001589)","source":"_posts/nginx支持流媒体.md","raw":"---\ntitle: nginx支持流媒体\ndate: 2021-07-25 11:16:39\ncategories: \n- 视频\ntags:\n- 视频\n---\n\n## 简介\n本章介绍如何搭建一个nginx的流媒体服务器，可以直接通过nginx访问hls的m3u8与rtmp的链接。\n\n## 安装\n\n安装nginx其实没有什么值得说，主要是要下载nginx的nginx-rtmp-module模块,编译时候加下此模块就OK了\n\n下载nginx-rtmp-module：https://github.com/arut/nginx-rtmp-module\n\n```\n./configure --prefix=/usr/local/nginx --with-pcre=/home/user/pcre/pcre-8.32 --with-zlib=/home/user/zlib/zlib-1.2.8 --with-openssl=/home/user/openssl/openssl-1.0.1i  --add-module=/home/user/nginx-rtmp-module\n```\n\n## 配置\n\n- RTMP\n```\nrtmp {                #RTMP服务\n   server {\n       listen 1935;  #//服务端口\n       chunk_size 4096;   #//数据传输块的大小\n       application vod {\n         play /opt/video/vod; #//视频文件存放位置。\n       }\n   }\n}\n\n\nhttp {\n    include      mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen      80;\n        server_name  localhost;\n        \n        #配置nginx的rtmp一览页面\n        location /stat {\n                rtmp_stat all;\n            rtmp_stat_stylesheet stat.xsl;\n        }\n        location /stat.xsl {\n           root /etc/rtmpServer/nginx-rtmp-module/;\n        }\n\n        location / {\n            root  html;\n            index  index.html index.htm;\n        }\n\n        error_page  500 502 503 504  /50x.html;\n        location = /50x.html {\n            root  html;\n        }\n    }\n}\n```\n\n\n- HLS\n\n该配置是播放hls的配置\n```\nlocation /hls {  \n    types{  \n        application/vnd.apple.mpegurl m3u8;  \n        video/mp2t ts;  \n    }  \n    suffix m3u8;\n   #配置一个根路径 \n   root /data/baiyun/; \n   add_header Cache-Control no-cache;\n   add_header 'Access-Control-Allow-Origin' '*';\n   add_header 'Access-Control-Allow-Credentials' 'true';\n}\n```\n\n该配置是支持远程推流到nginx负责切片成m3u8的配置\n```\nrtmp {\n    server {\n        listen 1935;\n        chunk_size 4000;\n        #HLS\n        application hls {\n            live on;\n            hls on;\n            #视频流存放地址\n            hls_path /usr/local/nginx/html/hls; \n            hls_fragment 5s;\n        }\n    }\n}\n```\n\n## 参考\n[视频直播点播nginx-rtmp开发手册中文版](https://blog.csdn.net/weiyuefei/article/details/74001589)","slug":"nginx支持流媒体","published":1,"updated":"2021-09-07T08:00:52.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhrt000ud0tvjtxj9t7x","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>本章介绍如何搭建一个nginx的流媒体服务器，可以直接通过nginx访问hls的m3u8与rtmp的链接。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装nginx其实没有什么值得说，主要是要下载nginx的nginx-rtmp-module模块,编译时候加下此模块就OK了</p>\n<p>下载nginx-rtmp-module：<a href=\"https://github.com/arut/nginx-rtmp-module\" target=\"_blank\" rel=\"noopener\">https://github.com/arut/nginx-rtmp-module</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr/local/nginx --with-pcre=/home/user/pcre/pcre-8.32 --with-zlib=/home/user/zlib/zlib-1.2.8 --with-openssl=/home/user/openssl/openssl-1.0.1i  --add-module=/home/user/nginx-rtmp-module</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ul>\n<li><p>RTMP</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtmp &#123;                #RTMP服务</span><br><span class=\"line\">   server &#123;</span><br><span class=\"line\">       listen 1935;  #//服务端口</span><br><span class=\"line\">       chunk_size 4096;   #//数据传输块的大小</span><br><span class=\"line\">       application vod &#123;</span><br><span class=\"line\">         play /opt/video/vod; #//视频文件存放位置。</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include      mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen      80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\">        </span><br><span class=\"line\">        #配置nginx的rtmp一览页面</span><br><span class=\"line\">        location /stat &#123;</span><br><span class=\"line\">                rtmp_stat all;</span><br><span class=\"line\">            rtmp_stat_stylesheet stat.xsl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /stat.xsl &#123;</span><br><span class=\"line\">           root /etc/rtmpServer/nginx-rtmp-module/;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root  html;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page  500 502 503 504  /50x.html;</span><br><span class=\"line\">        location = /50x.html &#123;</span><br><span class=\"line\">            root  html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HLS</p>\n</li>\n</ul>\n<p>该配置是播放hls的配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /hls &#123;  </span><br><span class=\"line\">    types&#123;  </span><br><span class=\"line\">        application/vnd.apple.mpegurl m3u8;  </span><br><span class=\"line\">        video/mp2t ts;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    suffix m3u8;</span><br><span class=\"line\">   #配置一个根路径 </span><br><span class=\"line\">   root /data/baiyun/; </span><br><span class=\"line\">   add_header Cache-Control no-cache;</span><br><span class=\"line\">   add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;</span><br><span class=\"line\">   add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该配置是支持远程推流到nginx负责切片成m3u8的配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtmp &#123;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 1935;</span><br><span class=\"line\">        chunk_size 4000;</span><br><span class=\"line\">        #HLS</span><br><span class=\"line\">        application hls &#123;</span><br><span class=\"line\">            live on;</span><br><span class=\"line\">            hls on;</span><br><span class=\"line\">            #视频流存放地址</span><br><span class=\"line\">            hls_path /usr/local/nginx/html/hls; </span><br><span class=\"line\">            hls_fragment 5s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/weiyuefei/article/details/74001589\" target=\"_blank\" rel=\"noopener\">视频直播点播nginx-rtmp开发手册中文版</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>本章介绍如何搭建一个nginx的流媒体服务器，可以直接通过nginx访问hls的m3u8与rtmp的链接。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装nginx其实没有什么值得说，主要是要下载nginx的nginx-rtmp-module模块,编译时候加下此模块就OK了</p>\n<p>下载nginx-rtmp-module：<a href=\"https://github.com/arut/nginx-rtmp-module\" target=\"_blank\" rel=\"noopener\">https://github.com/arut/nginx-rtmp-module</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr/local/nginx --with-pcre=/home/user/pcre/pcre-8.32 --with-zlib=/home/user/zlib/zlib-1.2.8 --with-openssl=/home/user/openssl/openssl-1.0.1i  --add-module=/home/user/nginx-rtmp-module</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ul>\n<li><p>RTMP</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtmp &#123;                #RTMP服务</span><br><span class=\"line\">   server &#123;</span><br><span class=\"line\">       listen 1935;  #//服务端口</span><br><span class=\"line\">       chunk_size 4096;   #//数据传输块的大小</span><br><span class=\"line\">       application vod &#123;</span><br><span class=\"line\">         play /opt/video/vod; #//视频文件存放位置。</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include      mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen      80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\">        </span><br><span class=\"line\">        #配置nginx的rtmp一览页面</span><br><span class=\"line\">        location /stat &#123;</span><br><span class=\"line\">                rtmp_stat all;</span><br><span class=\"line\">            rtmp_stat_stylesheet stat.xsl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location /stat.xsl &#123;</span><br><span class=\"line\">           root /etc/rtmpServer/nginx-rtmp-module/;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root  html;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page  500 502 503 504  /50x.html;</span><br><span class=\"line\">        location = /50x.html &#123;</span><br><span class=\"line\">            root  html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HLS</p>\n</li>\n</ul>\n<p>该配置是播放hls的配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /hls &#123;  </span><br><span class=\"line\">    types&#123;  </span><br><span class=\"line\">        application/vnd.apple.mpegurl m3u8;  </span><br><span class=\"line\">        video/mp2t ts;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    suffix m3u8;</span><br><span class=\"line\">   #配置一个根路径 </span><br><span class=\"line\">   root /data/baiyun/; </span><br><span class=\"line\">   add_header Cache-Control no-cache;</span><br><span class=\"line\">   add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;</span><br><span class=\"line\">   add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该配置是支持远程推流到nginx负责切片成m3u8的配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtmp &#123;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 1935;</span><br><span class=\"line\">        chunk_size 4000;</span><br><span class=\"line\">        #HLS</span><br><span class=\"line\">        application hls &#123;</span><br><span class=\"line\">            live on;</span><br><span class=\"line\">            hls on;</span><br><span class=\"line\">            #视频流存放地址</span><br><span class=\"line\">            hls_path /usr/local/nginx/html/hls; </span><br><span class=\"line\">            hls_fragment 5s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/weiyuefei/article/details/74001589\" target=\"_blank\" rel=\"noopener\">视频直播点播nginx-rtmp开发手册中文版</a></p>\n"},{"title":"wireshark抓包并使用","date":"2021-07-24T03:16:39.000Z","_content":"\n## 简介\n本篇是记录我在平常抓包过程中如何使用wireshark\n\n## 前提\n\n- wireshark工具\n\n\n## 详解\n\n### 抓包\n\n使用wireshark，首先就要学会怎么抓包，很简单，在linux下使用以下命令\n>tcpdump -i eth0 host [ip] -n -vv -A -w 抓包.pcap\n\n\n### 使用\n\n将抓到的包用wireshark打开就能见到下面的界面\n\n![wireshark界面](/images/video/抓包界面图.png)\n<html>\n<center>图一</center>\n</html>\n           \n                \n这是一份在对接RTSP视频协议时候抓回来的包，很明显可以看到是基于TCP来传输的。以下记录一下我常用到的主要功能：\n\n1. 面板使用\n\n![wireshark面板](/images/video/抓包上方图.png)\n<html>\n<center>图二</center>\n</html>\n\n一般来说，通过面板就能看出交互的具体内容。如图二可以前三行列表可以看出TCP三次握手的交互流程。参考TCP三次握手流程\n\n![image](/images/video/tcp三次握手图.png)\n    \n2. 数据详细区\n\n![wireshark下半部](/images/video/抓包下方图.png)\n<html>\n<center>图三</center>\n</html>\n\n\n整个传输过程的传输信息，具体每一层有什么具体信息可以看下相应的资料。由上往下\n1. 物理层\n2. 数据链路层\n3. 网络层（常用）\n4. 传输层（常用）\n5. 应用层（常用）\n\n\n3. 追踪流\n\n展示更具体交互信息\n\n>右键点击面板信息>追踪流>TCP流\n\n![追踪流](/images/video/抓包协议追踪图.png)\n<html>\n<center>图四</center>\n</html>\n\n4. 统计丢包率\n\n一般来说，我们也会去观察究竟数据的丢包率是多小，对于音视频的数据我们一般观察RTP包，特别是以UDP传输的时候。\n>电话>>RTP>>RTP流\n\n![RTP丢包率](/images/video/抓包rtp统计包.png)\n\n\n\n## 参考\n\n[Wireshark抓包使用指南](https://zhuanlan.zhihu.com/p/82498482)\n","source":"_posts/wireshark抓包并使用.md","raw":"---\ntitle: wireshark抓包并使用\ndate: 2021-07-24 11:16:39\ncategories: \n- 视频\ntags:\n- 视频\n---\n\n## 简介\n本篇是记录我在平常抓包过程中如何使用wireshark\n\n## 前提\n\n- wireshark工具\n\n\n## 详解\n\n### 抓包\n\n使用wireshark，首先就要学会怎么抓包，很简单，在linux下使用以下命令\n>tcpdump -i eth0 host [ip] -n -vv -A -w 抓包.pcap\n\n\n### 使用\n\n将抓到的包用wireshark打开就能见到下面的界面\n\n![wireshark界面](/images/video/抓包界面图.png)\n<html>\n<center>图一</center>\n</html>\n           \n                \n这是一份在对接RTSP视频协议时候抓回来的包，很明显可以看到是基于TCP来传输的。以下记录一下我常用到的主要功能：\n\n1. 面板使用\n\n![wireshark面板](/images/video/抓包上方图.png)\n<html>\n<center>图二</center>\n</html>\n\n一般来说，通过面板就能看出交互的具体内容。如图二可以前三行列表可以看出TCP三次握手的交互流程。参考TCP三次握手流程\n\n![image](/images/video/tcp三次握手图.png)\n    \n2. 数据详细区\n\n![wireshark下半部](/images/video/抓包下方图.png)\n<html>\n<center>图三</center>\n</html>\n\n\n整个传输过程的传输信息，具体每一层有什么具体信息可以看下相应的资料。由上往下\n1. 物理层\n2. 数据链路层\n3. 网络层（常用）\n4. 传输层（常用）\n5. 应用层（常用）\n\n\n3. 追踪流\n\n展示更具体交互信息\n\n>右键点击面板信息>追踪流>TCP流\n\n![追踪流](/images/video/抓包协议追踪图.png)\n<html>\n<center>图四</center>\n</html>\n\n4. 统计丢包率\n\n一般来说，我们也会去观察究竟数据的丢包率是多小，对于音视频的数据我们一般观察RTP包，特别是以UDP传输的时候。\n>电话>>RTP>>RTP流\n\n![RTP丢包率](/images/video/抓包rtp统计包.png)\n\n\n\n## 参考\n\n[Wireshark抓包使用指南](https://zhuanlan.zhihu.com/p/82498482)\n","slug":"wireshark抓包并使用","published":1,"updated":"2021-09-07T08:00:52.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhrw000zd0tvjg36o3sp","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>本篇是记录我在平常抓包过程中如何使用wireshark</p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><ul>\n<li>wireshark工具</li>\n</ul>\n<h2 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h2><h3 id=\"抓包\"><a href=\"#抓包\" class=\"headerlink\" title=\"抓包\"></a>抓包</h3><p>使用wireshark，首先就要学会怎么抓包，很简单，在linux下使用以下命令</p>\n<blockquote>\n<p>tcpdump -i eth0 host [ip] -n -vv -A -w 抓包.pcap</p>\n</blockquote>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>将抓到的包用wireshark打开就能见到下面的界面</p>\n<p><img src=\"/images/video/抓包界面图.png\" alt=\"wireshark界面\"></p>\n<html><br><center>图一</center><br></html>\n\n\n<p>这是一份在对接RTSP视频协议时候抓回来的包，很明显可以看到是基于TCP来传输的。以下记录一下我常用到的主要功能：</p>\n<ol>\n<li>面板使用</li>\n</ol>\n<p><img src=\"/images/video/抓包上方图.png\" alt=\"wireshark面板\"></p>\n<html><br><center>图二</center><br></html>\n\n<p>一般来说，通过面板就能看出交互的具体内容。如图二可以前三行列表可以看出TCP三次握手的交互流程。参考TCP三次握手流程</p>\n<p><img src=\"/images/video/tcp三次握手图.png\" alt=\"image\"></p>\n<ol>\n<li>数据详细区</li>\n</ol>\n<p><img src=\"/images/video/抓包下方图.png\" alt=\"wireshark下半部\"></p>\n<html><br><center>图三</center><br></html>\n\n\n<p>整个传输过程的传输信息，具体每一层有什么具体信息可以看下相应的资料。由上往下</p>\n<ol>\n<li>物理层</li>\n<li>数据链路层</li>\n<li>网络层（常用）</li>\n<li>传输层（常用）</li>\n<li>应用层（常用）</li>\n</ol>\n<ol>\n<li>追踪流</li>\n</ol>\n<p>展示更具体交互信息</p>\n<blockquote>\n<p>右键点击面板信息&gt;追踪流&gt;TCP流</p>\n</blockquote>\n<p><img src=\"/images/video/抓包协议追踪图.png\" alt=\"追踪流\"></p>\n<html><br><center>图四</center><br></html>\n\n<ol>\n<li>统计丢包率</li>\n</ol>\n<p>一般来说，我们也会去观察究竟数据的丢包率是多小，对于音视频的数据我们一般观察RTP包，特别是以UDP传输的时候。</p>\n<blockquote>\n<p>电话&gt;&gt;RTP&gt;&gt;RTP流</p>\n</blockquote>\n<p><img src=\"/images/video/抓包rtp统计包.png\" alt=\"RTP丢包率\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://zhuanlan.zhihu.com/p/82498482\" target=\"_blank\" rel=\"noopener\">Wireshark抓包使用指南</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>本篇是记录我在平常抓包过程中如何使用wireshark</p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><ul>\n<li>wireshark工具</li>\n</ul>\n<h2 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h2><h3 id=\"抓包\"><a href=\"#抓包\" class=\"headerlink\" title=\"抓包\"></a>抓包</h3><p>使用wireshark，首先就要学会怎么抓包，很简单，在linux下使用以下命令</p>\n<blockquote>\n<p>tcpdump -i eth0 host [ip] -n -vv -A -w 抓包.pcap</p>\n</blockquote>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>将抓到的包用wireshark打开就能见到下面的界面</p>\n<p><img src=\"/images/video/抓包界面图.png\" alt=\"wireshark界面\"></p>\n<html><br><center>图一</center><br></html>\n\n\n<p>这是一份在对接RTSP视频协议时候抓回来的包，很明显可以看到是基于TCP来传输的。以下记录一下我常用到的主要功能：</p>\n<ol>\n<li>面板使用</li>\n</ol>\n<p><img src=\"/images/video/抓包上方图.png\" alt=\"wireshark面板\"></p>\n<html><br><center>图二</center><br></html>\n\n<p>一般来说，通过面板就能看出交互的具体内容。如图二可以前三行列表可以看出TCP三次握手的交互流程。参考TCP三次握手流程</p>\n<p><img src=\"/images/video/tcp三次握手图.png\" alt=\"image\"></p>\n<ol>\n<li>数据详细区</li>\n</ol>\n<p><img src=\"/images/video/抓包下方图.png\" alt=\"wireshark下半部\"></p>\n<html><br><center>图三</center><br></html>\n\n\n<p>整个传输过程的传输信息，具体每一层有什么具体信息可以看下相应的资料。由上往下</p>\n<ol>\n<li>物理层</li>\n<li>数据链路层</li>\n<li>网络层（常用）</li>\n<li>传输层（常用）</li>\n<li>应用层（常用）</li>\n</ol>\n<ol>\n<li>追踪流</li>\n</ol>\n<p>展示更具体交互信息</p>\n<blockquote>\n<p>右键点击面板信息&gt;追踪流&gt;TCP流</p>\n</blockquote>\n<p><img src=\"/images/video/抓包协议追踪图.png\" alt=\"追踪流\"></p>\n<html><br><center>图四</center><br></html>\n\n<ol>\n<li>统计丢包率</li>\n</ol>\n<p>一般来说，我们也会去观察究竟数据的丢包率是多小，对于音视频的数据我们一般观察RTP包，特别是以UDP传输的时候。</p>\n<blockquote>\n<p>电话&gt;&gt;RTP&gt;&gt;RTP流</p>\n</blockquote>\n<p><img src=\"/images/video/抓包rtp统计包.png\" alt=\"RTP丢包率\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://zhuanlan.zhihu.com/p/82498482\" target=\"_blank\" rel=\"noopener\">Wireshark抓包使用指南</a></p>\n"},{"title":"书籍记录","date":"2018-01-25T04:00:00.000Z","_content":"\n### 1.鸟哥linux第三版基础篇（看完整本书基本上linux入门）\n\n### 2.鸟哥linux第四版基础篇\n\n### 3.Java多线程编程核心技术 (关于线程比较基础入门)\n\n### 4.redis入门指南2 (比较详细记录了redis使用)","source":"_posts/书籍记录.md","raw":"---\ntitle: 书籍记录\ndate: 2018-01-25 12:00:00\ncategories: \n- 笔记\n- 书籍\ntags:\n- 书籍篇\n---\n\n### 1.鸟哥linux第三版基础篇（看完整本书基本上linux入门）\n\n### 2.鸟哥linux第四版基础篇\n\n### 3.Java多线程编程核心技术 (关于线程比较基础入门)\n\n### 4.redis入门指南2 (比较详细记录了redis使用)","slug":"书籍记录","published":1,"updated":"2021-09-07T08:00:52.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhry0012d0tv2plskops","content":"<h3 id=\"1-鸟哥linux第三版基础篇（看完整本书基本上linux入门）\"><a href=\"#1-鸟哥linux第三版基础篇（看完整本书基本上linux入门）\" class=\"headerlink\" title=\"1.鸟哥linux第三版基础篇（看完整本书基本上linux入门）\"></a>1.鸟哥linux第三版基础篇（看完整本书基本上linux入门）</h3><h3 id=\"2-鸟哥linux第四版基础篇\"><a href=\"#2-鸟哥linux第四版基础篇\" class=\"headerlink\" title=\"2.鸟哥linux第四版基础篇\"></a>2.鸟哥linux第四版基础篇</h3><h3 id=\"3-Java多线程编程核心技术-关于线程比较基础入门\"><a href=\"#3-Java多线程编程核心技术-关于线程比较基础入门\" class=\"headerlink\" title=\"3.Java多线程编程核心技术 (关于线程比较基础入门)\"></a>3.Java多线程编程核心技术 (关于线程比较基础入门)</h3><h3 id=\"4-redis入门指南2-比较详细记录了redis使用\"><a href=\"#4-redis入门指南2-比较详细记录了redis使用\" class=\"headerlink\" title=\"4.redis入门指南2 (比较详细记录了redis使用)\"></a>4.redis入门指南2 (比较详细记录了redis使用)</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-鸟哥linux第三版基础篇（看完整本书基本上linux入门）\"><a href=\"#1-鸟哥linux第三版基础篇（看完整本书基本上linux入门）\" class=\"headerlink\" title=\"1.鸟哥linux第三版基础篇（看完整本书基本上linux入门）\"></a>1.鸟哥linux第三版基础篇（看完整本书基本上linux入门）</h3><h3 id=\"2-鸟哥linux第四版基础篇\"><a href=\"#2-鸟哥linux第四版基础篇\" class=\"headerlink\" title=\"2.鸟哥linux第四版基础篇\"></a>2.鸟哥linux第四版基础篇</h3><h3 id=\"3-Java多线程编程核心技术-关于线程比较基础入门\"><a href=\"#3-Java多线程编程核心技术-关于线程比较基础入门\" class=\"headerlink\" title=\"3.Java多线程编程核心技术 (关于线程比较基础入门)\"></a>3.Java多线程编程核心技术 (关于线程比较基础入门)</h3><h3 id=\"4-redis入门指南2-比较详细记录了redis使用\"><a href=\"#4-redis入门指南2-比较详细记录了redis使用\" class=\"headerlink\" title=\"4.redis入门指南2 (比较详细记录了redis使用)\"></a>4.redis入门指南2 (比较详细记录了redis使用)</h3>"},{"title":"st3使用配置","date":"2017-01-22T03:16:39.000Z","_content":"\n---\n该编文章主要是记录下使用ST3和在ST3编辑markdown\n---\n\n### 1. 安装ST3\n安装过程及其简单，直接go to anything 就可以了。\n\n### 2. 下载支持插件\n1. 下载package control插件(网上一堆信息，不做详细说明)\n主要参考：[https://www.cnblogs.com/luoshupeng/archive/2013/09/09/3310777.html/](https://www.cnblogs.com/luoshupeng/archive/2013/09/09/3310777.html/)\n2. 下载markdownEditing(编辑markdown,提供快捷键)\n*流程:ctrl+Shift+P->install package->下载markdownEditing插件->在multimarkdown setting user下设置*\n```\n{\n      \"enable_table_editor\": true,\n      \"highlight_line\": true,\n      \"line_numbers\": true,   // 显示行号\n      \"tab_size\": 4,          // tab宽度\n      \"wrap_width\": 300,\n      \"word_wrap\": true,      // 自动换行\n      \"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme\",\n      // \"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor.tmTheme\",\n      // \"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme\",\n      // \"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor-Yellow.tmTheme\",\n      \"mde.keep_centered\": true,// 可以保持你正在编辑的行始终处于屏幕的中间\n      \"extensions\":\n      [\n          \"mmd\",\n          \"md\"\n      ]\n }\n```\n3. 下载Markdown Preview或MarkdownLivePreview.(预览markdown)\n_markdown preview下载流程:ctrl+Shift+P->install package->输入插件名称markdown preview->key bindings插入下面代码_\n```\n{ \"keys\": [\"alt+m\"], \"command\": \"markdown_preview\", \"args\": {\"target\": \"browser\", \"parser\":\"markdown\"} },   \n```\n\n\n### 3. 记录st3常用的快捷键\n```java\nCtrl+← 向左单位性地移动光标，快速移动光标。\nCtrl+→ 向右单位性地移动光标，快速移动光标。\nshift+↑ 向上选中行。\nshift+↓ 向下选中行。\nCtrl+Shift+K 删除整行。\nCtrl+/ 注释单行。\nCtrl+Shift+/ 注释多行。\nCtrl+K+U 转换大写。\nCtrl+K+L 转换小写。\nCtrl+F 打开底部搜索框，查找关键字。\nCtrl+P 打开搜索框。提供：1、输入当前项目中的文件名，快速搜索文件，2、Ctrl+G功能，3、Ctrl+R功能，4、Ctrl+：功能\nCtrl+G 自动带：，输入数字跳转到该行代码\nCtrl+R 自动带@，查找文件中的函数名\nCtrl+： 自动带#，查找文件中的变量名、属性名等\nCtrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。\nEsc 退出搜索框，命令框等。\nAlt+Shift+1 窗口分屏1-4(水平),5（等分）,89（垂直）\nCtrl+K+B 开启/关闭侧边栏。\n```\n\n### 4. markdownEditing常用的快捷键\n```java\nCtrl+Win+V 选中的内容将自动转换为行内式超链接，链接到剪贴板中的内容\nCtrl+Win+R 选中的内容将自动转换为参考式超链接，链接到剪贴板中的内容\nCtrl+Alt+R 弹出提示框插入一个参考式超链接，在提示框中输入链接内容和定义参考ID[^3]\nCtrl+Win+K 插入一个标准的行内式超链接\nWin+Shift+K 插入一个标准的行内式图片（此快捷键可能与输入法有冲突）\nCtrl+1 至 Ctrl+6 插入一级至六级标题\nFN+Alt+i 选中的内容转换为斜体\nFN+Alt+b 选中的内容转换为粗体[^1]\nCtrl+Shift+6 自动插入一个脚注，并跳转到该脚注的定义中。\nAlt+Shift+F 查找没有定义的脚注并自动添加其定义链接\nAlt+Shift+G 查找没有定义的参考式超链接并自动添加其定义链接\nCtrl+Alt+S 脚注排序\nCtrl+Shift+. 缩进当前内容\nCtrl+Shift+, 提前当前内容\n```\n\n__PS__ 参考:\n1. 快捷键总结:[http://blog.csdn.net/u012771929/article/details/30030249](http://blog.csdn.net/u012771929/article/details/30030249)\n2. st3使用配置:[http://www.jianshu.com/p/62241c7ecec9](http://www.jianshu.com/p/62241c7ecec9)","source":"_posts/使用Sublime3.md","raw":"---\ntitle: st3使用配置\ndate: 2017-01-22 11:16:39\ncategories: \n- sublime3使用笔记\ntags:\n- 笔记\n---\n\n---\n该编文章主要是记录下使用ST3和在ST3编辑markdown\n---\n\n### 1. 安装ST3\n安装过程及其简单，直接go to anything 就可以了。\n\n### 2. 下载支持插件\n1. 下载package control插件(网上一堆信息，不做详细说明)\n主要参考：[https://www.cnblogs.com/luoshupeng/archive/2013/09/09/3310777.html/](https://www.cnblogs.com/luoshupeng/archive/2013/09/09/3310777.html/)\n2. 下载markdownEditing(编辑markdown,提供快捷键)\n*流程:ctrl+Shift+P->install package->下载markdownEditing插件->在multimarkdown setting user下设置*\n```\n{\n      \"enable_table_editor\": true,\n      \"highlight_line\": true,\n      \"line_numbers\": true,   // 显示行号\n      \"tab_size\": 4,          // tab宽度\n      \"wrap_width\": 300,\n      \"word_wrap\": true,      // 自动换行\n      \"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme\",\n      // \"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor.tmTheme\",\n      // \"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme\",\n      // \"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor-Yellow.tmTheme\",\n      \"mde.keep_centered\": true,// 可以保持你正在编辑的行始终处于屏幕的中间\n      \"extensions\":\n      [\n          \"mmd\",\n          \"md\"\n      ]\n }\n```\n3. 下载Markdown Preview或MarkdownLivePreview.(预览markdown)\n_markdown preview下载流程:ctrl+Shift+P->install package->输入插件名称markdown preview->key bindings插入下面代码_\n```\n{ \"keys\": [\"alt+m\"], \"command\": \"markdown_preview\", \"args\": {\"target\": \"browser\", \"parser\":\"markdown\"} },   \n```\n\n\n### 3. 记录st3常用的快捷键\n```java\nCtrl+← 向左单位性地移动光标，快速移动光标。\nCtrl+→ 向右单位性地移动光标，快速移动光标。\nshift+↑ 向上选中行。\nshift+↓ 向下选中行。\nCtrl+Shift+K 删除整行。\nCtrl+/ 注释单行。\nCtrl+Shift+/ 注释多行。\nCtrl+K+U 转换大写。\nCtrl+K+L 转换小写。\nCtrl+F 打开底部搜索框，查找关键字。\nCtrl+P 打开搜索框。提供：1、输入当前项目中的文件名，快速搜索文件，2、Ctrl+G功能，3、Ctrl+R功能，4、Ctrl+：功能\nCtrl+G 自动带：，输入数字跳转到该行代码\nCtrl+R 自动带@，查找文件中的函数名\nCtrl+： 自动带#，查找文件中的变量名、属性名等\nCtrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。\nEsc 退出搜索框，命令框等。\nAlt+Shift+1 窗口分屏1-4(水平),5（等分）,89（垂直）\nCtrl+K+B 开启/关闭侧边栏。\n```\n\n### 4. markdownEditing常用的快捷键\n```java\nCtrl+Win+V 选中的内容将自动转换为行内式超链接，链接到剪贴板中的内容\nCtrl+Win+R 选中的内容将自动转换为参考式超链接，链接到剪贴板中的内容\nCtrl+Alt+R 弹出提示框插入一个参考式超链接，在提示框中输入链接内容和定义参考ID[^3]\nCtrl+Win+K 插入一个标准的行内式超链接\nWin+Shift+K 插入一个标准的行内式图片（此快捷键可能与输入法有冲突）\nCtrl+1 至 Ctrl+6 插入一级至六级标题\nFN+Alt+i 选中的内容转换为斜体\nFN+Alt+b 选中的内容转换为粗体[^1]\nCtrl+Shift+6 自动插入一个脚注，并跳转到该脚注的定义中。\nAlt+Shift+F 查找没有定义的脚注并自动添加其定义链接\nAlt+Shift+G 查找没有定义的参考式超链接并自动添加其定义链接\nCtrl+Alt+S 脚注排序\nCtrl+Shift+. 缩进当前内容\nCtrl+Shift+, 提前当前内容\n```\n\n__PS__ 参考:\n1. 快捷键总结:[http://blog.csdn.net/u012771929/article/details/30030249](http://blog.csdn.net/u012771929/article/details/30030249)\n2. st3使用配置:[http://www.jianshu.com/p/62241c7ecec9](http://www.jianshu.com/p/62241c7ecec9)","slug":"使用Sublime3","published":1,"updated":"2021-09-07T08:00:52.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhs00017d0tvsavqk7aa","content":"<hr>\n<h2 id=\"该编文章主要是记录下使用ST3和在ST3编辑markdown\"><a href=\"#该编文章主要是记录下使用ST3和在ST3编辑markdown\" class=\"headerlink\" title=\"该编文章主要是记录下使用ST3和在ST3编辑markdown\"></a>该编文章主要是记录下使用ST3和在ST3编辑markdown</h2><h3 id=\"1-安装ST3\"><a href=\"#1-安装ST3\" class=\"headerlink\" title=\"1. 安装ST3\"></a>1. 安装ST3</h3><p>安装过程及其简单，直接go to anything 就可以了。</p>\n<h3 id=\"2-下载支持插件\"><a href=\"#2-下载支持插件\" class=\"headerlink\" title=\"2. 下载支持插件\"></a>2. 下载支持插件</h3><ol>\n<li>下载package control插件(网上一堆信息，不做详细说明)<br>主要参考：<a href=\"https://www.cnblogs.com/luoshupeng/archive/2013/09/09/3310777.html/\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/luoshupeng/archive/2013/09/09/3310777.html/</a></li>\n<li><p>下载markdownEditing(编辑markdown,提供快捷键)<br><em>流程:ctrl+Shift+P-&gt;install package-&gt;下载markdownEditing插件-&gt;在multimarkdown setting user下设置</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">      &quot;enable_table_editor&quot;: true,</span><br><span class=\"line\">      &quot;highlight_line&quot;: true,</span><br><span class=\"line\">      &quot;line_numbers&quot;: true,   // 显示行号</span><br><span class=\"line\">      &quot;tab_size&quot;: 4,          // tab宽度</span><br><span class=\"line\">      &quot;wrap_width&quot;: 300,</span><br><span class=\"line\">      &quot;word_wrap&quot;: true,      // 自动换行</span><br><span class=\"line\">      &quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme&quot;,</span><br><span class=\"line\">      // &quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor.tmTheme&quot;,</span><br><span class=\"line\">      // &quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme&quot;,</span><br><span class=\"line\">      // &quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor-Yellow.tmTheme&quot;,</span><br><span class=\"line\">      &quot;mde.keep_centered&quot;: true,// 可以保持你正在编辑的行始终处于屏幕的中间</span><br><span class=\"line\">      &quot;extensions&quot;:</span><br><span class=\"line\">      [</span><br><span class=\"line\">          &quot;mmd&quot;,</span><br><span class=\"line\">          &quot;md&quot;</span><br><span class=\"line\">      ]</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下载Markdown Preview或MarkdownLivePreview.(预览markdown)<br><em>markdown preview下载流程:ctrl+Shift+P-&gt;install package-&gt;输入插件名称markdown preview-&gt;key bindings插入下面代码</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123;&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;&#125; &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"3-记录st3常用的快捷键\"><a href=\"#3-记录st3常用的快捷键\" class=\"headerlink\" title=\"3. 记录st3常用的快捷键\"></a>3. 记录st3常用的快捷键</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ctrl+← 向左单位性地移动光标，快速移动光标。</span><br><span class=\"line\">Ctrl+→ 向右单位性地移动光标，快速移动光标。</span><br><span class=\"line\">shift+↑ 向上选中行。</span><br><span class=\"line\">shift+↓ 向下选中行。</span><br><span class=\"line\">Ctrl+Shift+K 删除整行。</span><br><span class=\"line\">Ctrl+/ 注释单行。</span><br><span class=\"line\">Ctrl+Shift+/ 注释多行。</span><br><span class=\"line\">Ctrl+K+U 转换大写。</span><br><span class=\"line\">Ctrl+K+L 转换小写。</span><br><span class=\"line\">Ctrl+F 打开底部搜索框，查找关键字。</span><br><span class=\"line\">Ctrl+P 打开搜索框。提供：<span class=\"number\">1</span>、输入当前项目中的文件名，快速搜索文件，<span class=\"number\">2</span>、Ctrl+G功能，<span class=\"number\">3</span>、Ctrl+R功能，<span class=\"number\">4</span>、Ctrl+：功能</span><br><span class=\"line\">Ctrl+G 自动带：，输入数字跳转到该行代码</span><br><span class=\"line\">Ctrl+R 自动带@，查找文件中的函数名</span><br><span class=\"line\">Ctrl+： 自动带#，查找文件中的变量名、属性名等</span><br><span class=\"line\">Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用<span class=\"keyword\">package</span>安装插件。</span><br><span class=\"line\">Esc 退出搜索框，命令框等。</span><br><span class=\"line\">Alt+Shift+<span class=\"number\">1</span> 窗口分屏<span class=\"number\">1</span>-<span class=\"number\">4</span>(水平),<span class=\"number\">5</span>（等分）,<span class=\"number\">89</span>（垂直）</span><br><span class=\"line\">Ctrl+K+B 开启/关闭侧边栏。</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-markdownEditing常用的快捷键\"><a href=\"#4-markdownEditing常用的快捷键\" class=\"headerlink\" title=\"4. markdownEditing常用的快捷键\"></a>4. markdownEditing常用的快捷键</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ctrl+Win+V 选中的内容将自动转换为行内式超链接，链接到剪贴板中的内容</span><br><span class=\"line\">Ctrl+Win+R 选中的内容将自动转换为参考式超链接，链接到剪贴板中的内容</span><br><span class=\"line\">Ctrl+Alt+R 弹出提示框插入一个参考式超链接，在提示框中输入链接内容和定义参考ID[^<span class=\"number\">3</span>]</span><br><span class=\"line\">Ctrl+Win+K 插入一个标准的行内式超链接</span><br><span class=\"line\">Win+Shift+K 插入一个标准的行内式图片（此快捷键可能与输入法有冲突）</span><br><span class=\"line\">Ctrl+<span class=\"number\">1</span> 至 Ctrl+<span class=\"number\">6</span> 插入一级至六级标题</span><br><span class=\"line\">FN+Alt+i 选中的内容转换为斜体</span><br><span class=\"line\">FN+Alt+b 选中的内容转换为粗体[^<span class=\"number\">1</span>]</span><br><span class=\"line\">Ctrl+Shift+<span class=\"number\">6</span> 自动插入一个脚注，并跳转到该脚注的定义中。</span><br><span class=\"line\">Alt+Shift+F 查找没有定义的脚注并自动添加其定义链接</span><br><span class=\"line\">Alt+Shift+G 查找没有定义的参考式超链接并自动添加其定义链接</span><br><span class=\"line\">Ctrl+Alt+S 脚注排序</span><br><span class=\"line\">Ctrl+Shift+. 缩进当前内容</span><br><span class=\"line\">Ctrl+Shift+, 提前当前内容</span><br></pre></td></tr></table></figure>\n<p><strong>PS</strong> 参考:</p>\n<ol>\n<li>快捷键总结:<a href=\"http://blog.csdn.net/u012771929/article/details/30030249\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u012771929/article/details/30030249</a></li>\n<li>st3使用配置:<a href=\"http://www.jianshu.com/p/62241c7ecec9\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/62241c7ecec9</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"该编文章主要是记录下使用ST3和在ST3编辑markdown\"><a href=\"#该编文章主要是记录下使用ST3和在ST3编辑markdown\" class=\"headerlink\" title=\"该编文章主要是记录下使用ST3和在ST3编辑markdown\"></a>该编文章主要是记录下使用ST3和在ST3编辑markdown</h2><h3 id=\"1-安装ST3\"><a href=\"#1-安装ST3\" class=\"headerlink\" title=\"1. 安装ST3\"></a>1. 安装ST3</h3><p>安装过程及其简单，直接go to anything 就可以了。</p>\n<h3 id=\"2-下载支持插件\"><a href=\"#2-下载支持插件\" class=\"headerlink\" title=\"2. 下载支持插件\"></a>2. 下载支持插件</h3><ol>\n<li>下载package control插件(网上一堆信息，不做详细说明)<br>主要参考：<a href=\"https://www.cnblogs.com/luoshupeng/archive/2013/09/09/3310777.html/\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/luoshupeng/archive/2013/09/09/3310777.html/</a></li>\n<li><p>下载markdownEditing(编辑markdown,提供快捷键)<br><em>流程:ctrl+Shift+P-&gt;install package-&gt;下载markdownEditing插件-&gt;在multimarkdown setting user下设置</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">      &quot;enable_table_editor&quot;: true,</span><br><span class=\"line\">      &quot;highlight_line&quot;: true,</span><br><span class=\"line\">      &quot;line_numbers&quot;: true,   // 显示行号</span><br><span class=\"line\">      &quot;tab_size&quot;: 4,          // tab宽度</span><br><span class=\"line\">      &quot;wrap_width&quot;: 300,</span><br><span class=\"line\">      &quot;word_wrap&quot;: true,      // 自动换行</span><br><span class=\"line\">      &quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme&quot;,</span><br><span class=\"line\">      // &quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor.tmTheme&quot;,</span><br><span class=\"line\">      // &quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme&quot;,</span><br><span class=\"line\">      // &quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor-Yellow.tmTheme&quot;,</span><br><span class=\"line\">      &quot;mde.keep_centered&quot;: true,// 可以保持你正在编辑的行始终处于屏幕的中间</span><br><span class=\"line\">      &quot;extensions&quot;:</span><br><span class=\"line\">      [</span><br><span class=\"line\">          &quot;mmd&quot;,</span><br><span class=\"line\">          &quot;md&quot;</span><br><span class=\"line\">      ]</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下载Markdown Preview或MarkdownLivePreview.(预览markdown)<br><em>markdown preview下载流程:ctrl+Shift+P-&gt;install package-&gt;输入插件名称markdown preview-&gt;key bindings插入下面代码</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123;&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;&#125; &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"3-记录st3常用的快捷键\"><a href=\"#3-记录st3常用的快捷键\" class=\"headerlink\" title=\"3. 记录st3常用的快捷键\"></a>3. 记录st3常用的快捷键</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ctrl+← 向左单位性地移动光标，快速移动光标。</span><br><span class=\"line\">Ctrl+→ 向右单位性地移动光标，快速移动光标。</span><br><span class=\"line\">shift+↑ 向上选中行。</span><br><span class=\"line\">shift+↓ 向下选中行。</span><br><span class=\"line\">Ctrl+Shift+K 删除整行。</span><br><span class=\"line\">Ctrl+/ 注释单行。</span><br><span class=\"line\">Ctrl+Shift+/ 注释多行。</span><br><span class=\"line\">Ctrl+K+U 转换大写。</span><br><span class=\"line\">Ctrl+K+L 转换小写。</span><br><span class=\"line\">Ctrl+F 打开底部搜索框，查找关键字。</span><br><span class=\"line\">Ctrl+P 打开搜索框。提供：<span class=\"number\">1</span>、输入当前项目中的文件名，快速搜索文件，<span class=\"number\">2</span>、Ctrl+G功能，<span class=\"number\">3</span>、Ctrl+R功能，<span class=\"number\">4</span>、Ctrl+：功能</span><br><span class=\"line\">Ctrl+G 自动带：，输入数字跳转到该行代码</span><br><span class=\"line\">Ctrl+R 自动带@，查找文件中的函数名</span><br><span class=\"line\">Ctrl+： 自动带#，查找文件中的变量名、属性名等</span><br><span class=\"line\">Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用<span class=\"keyword\">package</span>安装插件。</span><br><span class=\"line\">Esc 退出搜索框，命令框等。</span><br><span class=\"line\">Alt+Shift+<span class=\"number\">1</span> 窗口分屏<span class=\"number\">1</span>-<span class=\"number\">4</span>(水平),<span class=\"number\">5</span>（等分）,<span class=\"number\">89</span>（垂直）</span><br><span class=\"line\">Ctrl+K+B 开启/关闭侧边栏。</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-markdownEditing常用的快捷键\"><a href=\"#4-markdownEditing常用的快捷键\" class=\"headerlink\" title=\"4. markdownEditing常用的快捷键\"></a>4. markdownEditing常用的快捷键</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ctrl+Win+V 选中的内容将自动转换为行内式超链接，链接到剪贴板中的内容</span><br><span class=\"line\">Ctrl+Win+R 选中的内容将自动转换为参考式超链接，链接到剪贴板中的内容</span><br><span class=\"line\">Ctrl+Alt+R 弹出提示框插入一个参考式超链接，在提示框中输入链接内容和定义参考ID[^<span class=\"number\">3</span>]</span><br><span class=\"line\">Ctrl+Win+K 插入一个标准的行内式超链接</span><br><span class=\"line\">Win+Shift+K 插入一个标准的行内式图片（此快捷键可能与输入法有冲突）</span><br><span class=\"line\">Ctrl+<span class=\"number\">1</span> 至 Ctrl+<span class=\"number\">6</span> 插入一级至六级标题</span><br><span class=\"line\">FN+Alt+i 选中的内容转换为斜体</span><br><span class=\"line\">FN+Alt+b 选中的内容转换为粗体[^<span class=\"number\">1</span>]</span><br><span class=\"line\">Ctrl+Shift+<span class=\"number\">6</span> 自动插入一个脚注，并跳转到该脚注的定义中。</span><br><span class=\"line\">Alt+Shift+F 查找没有定义的脚注并自动添加其定义链接</span><br><span class=\"line\">Alt+Shift+G 查找没有定义的参考式超链接并自动添加其定义链接</span><br><span class=\"line\">Ctrl+Alt+S 脚注排序</span><br><span class=\"line\">Ctrl+Shift+. 缩进当前内容</span><br><span class=\"line\">Ctrl+Shift+, 提前当前内容</span><br></pre></td></tr></table></figure>\n<p><strong>PS</strong> 参考:</p>\n<ol>\n<li>快捷键总结:<a href=\"http://blog.csdn.net/u012771929/article/details/30030249\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u012771929/article/details/30030249</a></li>\n<li>st3使用配置:<a href=\"http://www.jianshu.com/p/62241c7ecec9\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/62241c7ecec9</a></li>\n</ol>\n"},{"title":"大数据总览（必看）","date":"2021-07-27T03:16:39.000Z","_content":"\n## 总览图\n\n![大数据总览图](/images/bdata/大数据总览.png)\n\n## 说明\n\n上图是在大数据开发组上将近一年多的开发经验累积的知识点，以便日后能快速预览。","source":"_posts/大数据总览.md","raw":"---\ntitle: 大数据总览（必看）\ndate: 2021-07-27 11:16:39\ncategories: \n- 大数据\ntags:\n- 大数据\n---\n\n## 总览图\n\n![大数据总览图](/images/bdata/大数据总览.png)\n\n## 说明\n\n上图是在大数据开发组上将近一年多的开发经验累积的知识点，以便日后能快速预览。","slug":"大数据总览","published":1,"updated":"2021-09-07T11:40:08.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhs2001ad0tvexm08ahw","content":"<h2 id=\"总览图\"><a href=\"#总览图\" class=\"headerlink\" title=\"总览图\"></a>总览图</h2><p><img src=\"/images/bdata/大数据总览.png\" alt=\"大数据总览图\"></p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>上图是在大数据开发组上将近一年多的开发经验累积的知识点，以便日后能快速预览。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"总览图\"><a href=\"#总览图\" class=\"headerlink\" title=\"总览图\"></a>总览图</h2><p><img src=\"/images/bdata/大数据总览.png\" alt=\"大数据总览图\"></p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>上图是在大数据开发组上将近一年多的开发经验累积的知识点，以便日后能快速预览。</p>\n"},{"title":"流媒体协议","date":"2021-07-25T03:16:39.000Z","_content":"\n# 目的\n总结我在流媒体项目中接触到且使用过的所有协议\n\n# 总体\n\n![image](/images/video/agreement.png)\n\n\n## TCP/UDP\n学习流媒体的协议，首当其冲就是学习TCP与UDP的协议，因为基本的协议都是基于这两种协议来传输\n\n## RTP与RTCP\n\n### 定义\nRTP实时流传输协议，是用于Internet上针对多媒体数据流的一种传输协议。RTP位于传输层，基于UDP之上。RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，服务质量由RTCP来提供。\n\nRTCP是实时传输控制协议，RTCP收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等，服务器可以利用这些信息动态的改变传输速率，甚至改变净荷的类型。RTCP消息也被封装为UDP数据报进行传输\n\n一般而言,目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个 给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的 UDP端口＋1），这样就构成一个UDP端口对。 RTP的发送过程如下，接收过程则相反。\n\n### 协议介绍\n\n#### RTP协议结构\n\n![RTP协议结构](/images/video/RTCP协议.png)\n\n\nRTP分组头部的各字段含义为：\n\nV：RTP版本号。为“10”。\n\nP：填充指示位。P为“1”时表示分组结尾含有1个或多个填充字节，其中这部分不属于有效载荷。\n\nX：扩展指示位。X为“1”时，则表示固定头部后还有一个扩展头部，这种情况较复杂，很少使用。\n\nCC：CSRC计数。指示固定头部后的CSRC的个数\n\nM：标志。\n\nPT：负载类型。表示RTP分组的负载类型。我们常用的有\n\nPayload Type | Codec\n---|---\n0 | PCM μ -Law\n8 | PCM-A Law\n9 | G..722 audio codec\n4 | G..723 audio codec\n15 | G..728 audio codec\n18 | G..729 audio codec\n34 | G..763 audio codec\n31 | G..761 audio codec\n\n序列号：序号顾名思义就是表示RTP分组的次序。初值为随机数，每发送一个增加1。可供接收方检测分组丢失和恢复分组次序。\n\n时间戳：表示RTP分组第一个字节的取样时刻。其初值为随机数，每个采用周期加1。如果每次传送20ms的数据，由于音频的采样频率为8000Hz，即每20ms有160次采样，则每传送20ms的数据，时戳增加160。\n\nSSRC：同步源标识(Synchronous Source)。表示信号的同步源，其值应随机选择，以保证同一个RTP会话中任意两个同步源的SSRC标识不同。\n\nCSRC：分信源(贡献源)标识(Contributing Source)。识别该数据包中的有效载荷的贡献源。换句话说，CSRC标识由混合器插入，其值就是组成复合信号的各个分信号的SSRC标识，用以标识各个组成分信号的信源。RTP分组的头部最多可以包含15个CSRC标识，其数目由CC字段指明。\n\n\n\n\n#### RTCP协议结构\n\n![RTCP](/images/video/RTP协议.jpg)\n\n```\n版本（V）：同RTP包头域。\n\n填充（P）：同RTP包头域。\n\n接收报告计数器（RC）：5比特，该SR包中的接收报告块的数目，可以为零。\n\n包类型（PT）：8比特，SR包是200。\n\n长度域（Length）：16比特，其中存放的是该SR包以32比特为单位的总长度减一。\n\n同步源（SSRC of sender）：SR包发送者的同步源标识符。与对应RTP包中的SSRC一样。\n\nNTP Timestamp（Network time protocol）SR包发送时的绝对时间值。NTP的作用是同步不同的RTP媒体流。\n\nRTP Timestamp：与NTP时间戳对应，与RTP数据包中的RTP时间戳具有相同的单位和随机初始值。\n\nSender’s packet count：从开始发送包到产生这个SR包这段时间里，发送者发送的RTP数据包的总数. SSRC改变时，这个域清零。\n\nSender`s octet count：从开始发送包到产生这个SR包这段时间里，发送者发送的净荷数据的总字节数（不包括头部和填充）。发送者改变其SSRC时，这个域要清零。\n\n同步源n的SSRC标识符：该报告块中包含的是从该源接收到的包的统计信息。\n\n丢失率（Fraction Lost）：表明从上一个SR或RR包发出以来从同步源n(SSRC_n)来的RTP数据包的丢失率。\n\n累计的包丢失数目：从开始接收到SSRC_n的包到发送SR,从SSRC_n传过来的RTP数据包的丢失总数。\n\n收到的扩展最大序列号：从SSRC_n收到的RTP数据包中最大的序列号，\n\n接收抖动（Interarrival jitter）：RTP数据包接受时间的统计方差估计\n\n上次SR时间戳（Last SR,LSR）：取最近从SSRC_n收到的SR包中的NTP时间戳的中间32比特。如果目前还没收到SR包，则该域清零。\n\n上次SR以来的延时（Delay since last SR,DLSR）：上次从SSRC_n收到SR包到发送本报告的延时。\n```\n\n\n根据所携带的控制信息不同RTCP信息包可分为RR（接收者报告包）、SR（源报告包）、SEDS（源描述包）、BYE（离开申明）和APP（特殊应用包）五类5类：\n\n\n类型 | 缩写表示 | 用途 | 描述\n---|---|---|---\n200 | SR（Sender Report）| 发送端报告 | 发送端报告包，用于发送和接收活动源的统计信息；\n201 | RR（Receiver Report）| 接收端报告 | 接收者报告包，用于接收非活动站的统计信息；\n202 | SDES（Source Description Items）| 源点描述 | 源描述包，用于报告和站点相关的信息，包括CNAME；\n203 | BYE | 结束传输 | 断开RTCP包，是站点离开系统的报告，表示结束；\n204 | APP | 特定应用 | 应用特定函数。\n\n\n## RTSP\n\n![image](/images/video/RTSP协议.png)\n\n### 定义\n实时串流协议（应用层）,TCP/IP协议体系中的一个应用层协议，RTSP位于RTP和RTCP之上，可以基于TCP或者UDP来完成数据传输。RTSP实时性比较，扩展性比较好（UDP,TCP传输数据）。rtsp流主要是控制流媒体的行为动作，提供了诸如暂停，快进等控制，而它本身并不传输流媒体数。\n### 协议介绍\n\n1. RTSP结构\n\n```\nrtsp://admin:a12345678@47.106.89.193:10000/h264/ch33/main/av_stream\n```\n\n结构：\nrtsp://user:pwd@host:port/abs_path/content_name\n\nuser:摄像头设备的登陆用户名\n\npwd:摄像头设备的登陆密码\n\nhost:摄像头有效的域名或是IP地址\n\nport:端口号，对于RTSP协议来说，缺省的端口号为554\n\nabs_path:媒体流资源标识\n\n2. 方法定义\n\n方法 | 方向 | 对象 | 要求 | 含义 \n:-:|-|-|-|-|-\nDESCRIBE | C->S | P，S | 推荐 | 检查演示或媒体对象的描述，也允许使用接收头指定用户理解的描述格式。DESCRIBE的答复-响应组成媒体RTSP初始阶段\nANNOUNCE | C->S,S->C | P，S | 可选 | 当从用户发往服务器时，ANNOUNCE将请求URL识别的演示或媒体对象描述发送给服务器；反之，ANNOUNCE实时更新连接描述。如新媒体流加入演示，整个演示描述再次发送，而不仅仅是附加组件，使组件能被删除\nGET_PARAMETER | C->S,S->C | P，S | 可选 | GET_PARAMETER请求检查URL指定的演示与媒体的参数值。没有实体体时，GET_PARAMETER也许能用来测试用户与服务器的连通情况\nOPTIONS | C->S,S->C | P，S | 要求 | 可在任意时刻发出OPTIONS请求，如用户打算尝试非标准请求，并不影响服务器状态\nPAUSE | C->S | P，S | 推荐 | PAUSE请求引起流发送临时中断。如请求URL命名一个流，仅回放和记录被停止；如请求URL命名一个演示或流组，演示或组中所有当前活动的流发送都停止。恢复回放或记录后，必须维持同步。在SETUP消息中连接头超时参数所指定时段期间被暂停后，尽管服务器可能关闭连接并释放资源，但服务器资源会被预订\nPLAY | C->S | P，S | 要求 | PLAY告诉服务器以SETUP指定的机制开始发送数据；直到一些SETUP请求被成功响应，客户端才可发布PLAY请求。PLAY请求将正常播放时间设置在所指定范围的起始处，发送流数据直到范围的结束处。PLAY请求可排成队列，服务器将PLAY请求排成队列，顺序执行\nRECORD | C->S | P，S | 可选 | 该方法根据演示描述初始化媒体数据记录范围，时标反映开始和结束时间；如没有给出时间范围，使用演示描述提供的开始和结束时间。如连接已经启动，立即开始记录，服务器数据请求URL或其他URL决定是否存储记录的数据；如服务器没有使用URL请求，响应应为201（创建），并包含描述请求状态和参考新资源的实体与位置头。支持现场演示记录的媒体服务器必须支持时钟范围格式，smpte格式没有意义\nREDIRECT | S->C | P，S | 可选 | 重定向请求通知客户端连接到另一服务器地址。它包含强制头地址，指示客户端发布URL请求；也可能包括参数范围，以指明重定向何时生效。若客户端要继续发送或接收URL媒体，客户端必须对当前连接发送TEARDOWN请求，而对指定主执新连接发送SETUP请求\nSETUP | C->S | S | 要求 | 对URL的SETUP请求指定用于流媒体的传输机制。客户端对正播放的流发布一个SETUP请求，以改变服务器允许的传输参数。如不允许这样做，响应错误为\"455 Method Not Valid In This State”。为了透过防火墙，客户端必须指明传输参数，即使对这些参数没有影响\nSET_PARAMETER | C->S,S->C | P，S | 可选 | 这个方法请求设置演示或URL指定流的参数值。请求仅应包含单个参数，允许客户端决定某个特殊请求为何失败。如请求包含多个参数，所有参数可成功设置，服务器必须只对该请求起作用。服务器必须允许参数可重复设置成同一值，但不让改变参数值。注意：媒体流传输参数必须用SETUP命令设置。将设置传输参数限制为SETUP有利于防火墙。将参数划分成规则排列形式，结果有更多有意义的错误指示\nTEARDOWN | C->S | S | 要求 | TEARDOWN请求停止给定URL流发送，释放相关资源。如URL是此演示URL，任何RTSP连接标识不再有效。除非全部传输参数是连接描述定义的，SETUP请求必须在连接可再次播放前发布\n\n\n\n3. 交互流程\n```\nC表示RTSP客户端,S表示RTSP服务端\n\n1. 第一步：查询服务器端可用方法\n1.C->S:OPTION request //询问S有哪些方法可用\n\n1.S->C:OPTION response //S回应信息的public头字段中包括提供的所有可用方法\n\n2. 第二步：得到媒体描述信息\n2.C->S:DESCRIBE request //要求得到S提供的媒体描述信息\n\n2.S->C:DESCRIBE response //S回应媒体描述信息，一般是sdp信息\n\n3. 第三步：建立RTSP会话\n3.C->S:SETUP request //通过Transport头字段列出可接受的传输选项，请求S建立会话\n\n3.S->C:SETUP response //S建立会话，通过Transport头字段返回选择的具体转输选项，并返回建立的Session ID;\n\n4. 第四步：请求开始传送数据\n4.C->S:PLAY request //C请求S开始发送数据\n\n4.S->C:PLAY response //S回应该请求的信息\n\n5. 第五步： 数据传送播放中\nS->C:发送流媒体数据 // 通过RTP协议传送数据\n\n6. 第六步：关闭会话，退出\n6.C->S:TEARDOWN request //C请求关闭会话\n\n6.S->C:TEARDOWN response //S回应该请求\n```\n\n\n\n4. RTSP与HTTP区别\n- RTSP中客户端和服务器都可以发出请求,HTTP只能客户端发起请求；\n- RTSP相比HTTP提供多种方法定义\n- RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据\n\n\n\n## SDP/SIP\n\n### 定义\nSIP与SDP这两个协议会在国标视频上会出现比较多。其中一般会与RTSP等协议共同\n\nSIP它是一个基于文本的应用层控制协议，独立于底层传输协议，用于建立、修改和终止IP网络上的双方或多方多媒体会话\n\nSDP（Session Description Protocol）是一个用来描述多媒体会话的应用层控制协议，它是一个基于文本的协议，用于会话建立过程中的媒体类型和编码方案的协商等\n\n### 协议介绍\n\n#### SIP介绍\n\n1. SIP 角色\n\n角色 | 作用\n---|---\n用户代理（UA） | 用户代理客户端（UAC）和用户代理服务器（UAS）组成，UAC负责发起呼叫，UAS负责接收呼叫并作出响应\n代理服务器（PS） | 通过它把来自用户代理客户端（UAC）的请求转发到用户代理服务端（UAS），并把UAS的响应消息转发回UAC\n注册服务器（register server） | 是具有接收注册请求、将请求中携带的信息进行保存并提供本域内位置服务的功能服务器\n重定向服务器（redirect server） | 负责规划SIP呼叫路由。它将获得的呼叫下一跳地址信息告诉呼叫方，以使呼叫方根据此地址直接向下一跳发出请求，此后重定向服务器退出呼叫过程。\n\n2. SIP请求\n```\n是客户端发给服务器激活一个SIP操作的消息，由一个方法名（Method）、一个请求URI（Request-URI）和一个协议版本 （SIP-Version）组成，三个部分之间以空格（SP）间隔。\n\nRequest-Line  =  Method + SP + Request-URI + SP + SIP-Version + CRLF\n\nRFC中定义了6中请求：\n\nINVITE：表明接收用户或服务被邀请加入一个会话；也可以使用这种方式来修改先前建立会话的特性；成功响应（200 OK）表明被叫方愿意参与会话；\n\nACK：确认UAC已经接收到了INVITE请求的最终响应（只与INVITE请求一起使用）；用于结束一个200 OK响应；若INVITE请求中不含有会话描述信息，ACK可以包含一个最终会话描述的消息体；\n\nOPTION：UA用此向UAS查询它的功能；\n\nBYE：用于终结一个先前建立的会话；\n\nCANCEL：使UAC和网络服务器取消一个正在进行的请求（如INVITE）；\n\nREGISTER：客户端注册其目前的位置信息；\n```\n\n\n3. SIP响应\n```\n服务器向客户端发送SIP响应，指明客户端先前发送给服务器的SIP请求的状态；由一个协议版本（SIP-Version），一个状态码（Status-Code）和一个原因说明（Reason-Phrase）组成，类似于请求消息，三个部分之间也以空格字符（SP）间隔。\n\nStatus-Line := SIP-Version + SP + Status-Code + SP + Reason-Phrase + CRLF\n\n状态码是一个100～699之间的3位正整数（具体参见后面附录），它表示对于一个请求消息的响应结果；原因说明是一串可以显示的字符，用于对响应的状态码进行简短说明。\n\n1xx：临时响应 （Provisional）；之前的请求消息已经收到，并准备接着处理后面的请求消息。\n\n2xx：成功响应 （Success）； 操作成功，请求消息已被收到并且成功地处理。\n\n3xx：重定向响应 （Redirection）； 服务器向客户端返回其它可能的位置，客户端应当根据响应中包含的地址信息向另一个服务器重发请求消息。\n\n4xx： 客户端错误 （Client Error）； 请求由于客户端的错误而失败，客户端可以根据响应状态码修改并重发刚才的请求消息。\n\n5xx：服务器错误 （Server Error） ；请求由于服务器的错误而失败，客户端可以向另一个服务器重发请求消息。\n\n6xx：全局错误（Global Failure）； 请求失败，客户端不应该再向任何服务器重发该请求消息。\n```\n\n4. 标题头\n```\n遵从HTTP标题头（RFC2616）定义的同样格式：每个标题头由字段名，紧跟着冒号(:)和字段组成。\n\n主要标题头（详情参见\n\nSIP常见头域（header）说明\n\nFrom：定义请求发起者（通常是发送者AOR），包含SIP或SIP URI和一个可选的显示名字；\n\nTo：定义了请求的接收者（通常是接收者AOR），包含SIP或SIP URI和一个可选的显示名字；因重定向和转移，SIP请求不一定发送给‘希望的’接收者；\n\nCall-ID：定义了一系列的SIP消息，对所有由对话中的UA发送的所有SIP请求和响应，Call-ID必须唯一；\n\nCseq：由一个整数值和一个方式名称组成，在一个对话中标识和序列SIP请求，也区分重传和新消息；\n\nVia：定义请求路径和响应要发送的地址；\n\nContact：定义US希望接收新SIP请求的SIP或SIPS URI（实际地址）；\n\nAllow：列出产生SIP消息的UA所支持的功能集合；\n\nSupported：列出所有UA支持的SIP扩展（RFC3262）；\n\nRequire：包含远端UA必须支持的SIP扩展；\n\nContent-Type：请求或响应的消息体类型；\n\nContent-Length：请求或响应的消息体的大小（十进制）；\n```\n\n#### SDP协议\n\nSDP协议内容(具体可参考国标规范文档)\n```\n1 v=:Version ，表示协议的版本号\n2 o=: Origin,表示源。值域中各项的含义依次是username(用户名)，sess-id(会话ID)，sess-version(会话版本号)，nettype(网络类型)，addrtype(地址类型)，unucast-address(单播地址)。\n3 s=:Session Name,表示本sdp所描述的session的名称\n4 c=:Connection Data 链接数据。其中值域中以空格分配的两个字段分贝是网络类型和网络地址，以后的RTP流就会发到该地址上。\n5 b=:Badwidth type，带宽类型\n6 t=:Timing ,起止时间，0表示无限\n7 m=:audio Media Type,媒体类型。audio表示音频，50452表示音频端口号，RTP/AVR是传输协议；后面是支持的Codec类型，与RTP流中的PayloadType(载荷类型)相对应，在这里分别是8,0,98和101,8和0分别代表PCMA和PCMU，他们属于静态编码，大于95的编码都属于动态编码，需要在后面使用“a=rtpmap”进行说明。\n8 a=: Attributes,属性。 它用于描述上面的音频的属性。如本例中98代表8000hz的ILBC编码，101代表RFC2833dtmf事件。a=sendrecv表示该媒体流可用于收和发，其他的还有sendonly(仅收)，recvonly(仅发)和inactive(不收不发)\n9 v=:Video，视频。\n```\n\n#### 点播流程\n\n为了更加熟悉SIP的流程，截取点播流程的流程图。可以看出，SIP传输过程当中都会有SDP的使用。\n\n![SIP点播流程](/images/video/wps2.png)\n\n\n## RTMP/HTTP-HLS/HTTP-FLV\n\nRTMP、HTTP-HLS与HTTP-FLV目前市面上比较常用的流媒体协议，都能基于浏览器来观看。\n\n- RTMP：实时消息传送协议，基于FLASH播放器的私有协议，默认使用端口 1935。RTMP一般被切割一个个块（chunk）的形式基于TCP协议上传输的明文协议。市面上的摄像头基本都会支持RTMP的形式，而且RTMP一般延时在 1-3s 之间相对延时较低，不过目前来说谷歌禁用了FLASH，可能对RTMP支持可能有所减弱\n\n- HTTP-HLS：HTTP Live Streaming，苹果公司基于HTTP的流媒体传输协议。工作原理是在服务端将视频流切片成ts小文件形式，通过m3u8索引文件访问ts文件。不过HLS的延迟在10s以上，且文件比较碎片化比较难以保存，但是有利有弊，正因为有ts文件落地，可支持回放等功能。\n- HTTP-FLV：Flash Video，主要是将音视频数据封装成FLV格式，然后通过 HTTP 协议传输给客户端。像B站都是使用该协议进行PC页面播放。FLV延迟比较低。\n\n- ws-flv：ws-flv直播技术基本与http-flv一致，无非是传输介质换成了websocket协议，除了解除了http-flv不能同时打开过多同域名下的直播窗口的限制，其他技术特性、参数基本与http-flv一致。目前看，ws-flv既适合视频监控(可以同时打开多路监控视频)也适合视频直播行业，是rtmp很高的升级替代方案。\n- webrtc：webrtc是谷歌主导的视频通话技术标准，目前各大主流浏览器都兼容该标准。通过该技术，用户可以在浏览器上实现无插件的视频通话，该技术也可以用于实现低延时的视频直播。目前业界也有很多基于webrtc的应用和产品，但是很多局限于视频聊天等低延时交互式场景，在视频监控领域，目前还尚未流行。而且该技术栈目前还在持续更新，技术难点太多，要与视频监控领域融合还需时日。\n\n### 协议介绍\n\n#### RTMP\n\n![RTMP](/images/video/hls-message.png)\n\n\n具体可参考：[RTMP协议详解](https://www.jianshu.com/p/d511d59b185c)\n\n\n#### HLS\n\n[HLS协议详解](https://www.jianshu.com/p/d511d59b185c)\n\n以下简单介绍下m3u8的相关内容\n\n![m3u8](/images/video/hls.png)\n\n```\nEXTM3U：每个M3U文件第一行必须是这个tag，请标示作用\n\nEXT-X-MEDIA-SEQUENCE:7\n每一个media URI 在 PlayList中只有唯一的序号，相邻之间序号+1, 一个media URI并不是必须要包含的，如果没有，默认为0\n\nEXTINF:\nduration 指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效，title是下载资源的url\n\nEXT-X-TARGETDURATION\n指定最大的媒体段时间长（秒）。所以#EXTINF中指定的时间长度必须小于或是等于这个最大值。这个tag在整个PlayList文件中只能出现一 次（在嵌套的情况下，一般有真正ts url的m3u8才会出现该tag）\n\nEXT-X-KEY\n表示怎么对media segments进行解码。其作用范围是下次该tag出现前的所有media URI，属性为NONE 或者 AES-128。NONE表示 URI以及IV（Initialization Vector）属性必须不存在， AES-128(Advanced EncryptionStandard)表示URI必须存在，IV可以不存在。\n对于AES-128的情况，keytag和URI属性共同表示了一个key文件，通过URI可以获得这个key，如果没有IV（Initialization Vector）,则使用序列号作为IV进行编解码，将序列号的高位赋到16个字节的buffer中，左边补0；如果有IV，则将改值当成16个字节的16进制数。\n\nEXT-X-PROGRAM-DATE-TIME\n将一个绝对时间或是日期和一个媒体段中的第一个sample相关联，只对下一个meida URI有效，格式如#EXT-X-PROGRAM-DATE-TIME:\nFor example: #EXT-X-PROGRAM-DATE-TIME:2010-02-19T14:54:23.031+08:00\n\nEXT-X-ALLOW-CACHE\n是否允许做cache，这个可以在PlayList文件中任意地方出现，并且最多出现一次，作用效果是所有的媒体段。格式如下：#EXT-X-ALLOW-CACHE:\n\nEXT-X-PLAYLIST-TYPE\n提供关于PlayList的可变性的信息， 这个对整个PlayList文件有效，是可选的，格式如下：#EXT-X-PLAYLIST-TYPE:：如果是VOD，则服务器不能改变PlayList 文件；如果是EVENT，则服务器不能改变或是删除PlayList文件中的任何部分，但是可以向该文件中增加新的一行内容。\n\nEXT-X-ENDLIST\n表示PlayList的末尾了，它可以在PlayList中任意位置出现，但是只能出现一个，格式如下：#EXT-X-ENDLIST\n\nEXT-X-MEDIA\n被用来在PlayList中表示相同内容的不用语种/译文的版本，比如可以通过使用3个这种tag表示3中不用语音的音频，或者用2个这个tag表示不同角度的video在PlayLists中。这个标签是独立存在的，属性包含：\nURI：如果没有，则表示这个tag描述的可选择版本在主PlayList的EXT-X-STREAM-INF中存在;\nTYPE:AUDIO and VIDEO;\nGROUP-ID:具有相同ID的MEDIAtag，组成一组样式；\nLANGUAGE：确定使用的主要语言\nNAME：人类可读的语言的翻译\nDEFAULT：YES或是NO，默认是No，如果是YES，则客户端会以这种选项来播放，除非用户自己进行选择。\nAUTOSELECT：YES或是NO，默认是No，如果是YES，则客户端会根据当前播放环境来进行选择（用户没有根据自己偏好进行选择的前提下）。\n\nEXT-X-STREAM-INF\n指定一个包含多媒体信息的 media URI 作为PlayList，一般做M3U8的嵌套使用，它只对紧跟后面的URI有效，格式如下：#EXT-X-STREAM-INF:有以下属性：\nBANDWIDTH：带宽，必须有。\nPROGRAM-ID：该值是一个十进制整数，惟一地标识一个在PlayList文件范围内的特定的描述。一个PlayList 文件中可能包含多个有相同ID的此tag。\nCODECS：不是必须的。\nRESOLUTION：分辨率。\nAUDIO：这个值必须和AUDIO类别的“EXT-X-MEDIA”标签中“GROUP-ID”属性值相匹配。\nVIDEO：同上\n```\n\n\n#### FLV\n\n[FLV协议详解](https://zhuanlan.zhihu.com/p/287220)\n\n\n### 性能对比\n\n![协议性能对比](/images/video/协议性能对比.png)\n\n\n## PES/TS/ES流\n\nPES、TS、ES流都是用于封装视频、音频数据的数据流。\n\nES流（Elementary Stream）：基本码流，不分段的音频、视频或其他信息的连续码流。\n\nPES流：把基本流ES分割成段，并加上相应头文件打包成形的打包基本码流。\n\nPS流（Program Stream）：节目流，将具有共同时间基准的一个或多个PES组合（复合）而成的单一数据流（用于播放或编辑系统，如m2p）。\n\nTS流（Transport Stream）：传输流，将具有共同时间基准或独立时间基准的一个或多个PES组合（复合）而成的单一数据流（用于数据传输）。\n\n## 总结\n上面列了很多我在项目中所有用到过的协议，每种协议都有不同的封装格式以及各自不同属性，个人觉得对于开发者或者使用者来说不一定每种协议都要面面俱到，平常大概知道他们具体作用性能和普遍的属性之类就可以，到真正使用的时候再去深入了解，反而会更高效。以下，我总结下这段时间来对这几个协议的了解：\n    ![协议](/images/video/zlm.png)\n\n\n根据上图可以看出，一般来说推流的方式可能会议国标方式或者接入海康、大华等厂商的摄像头来直接推流到流媒体，而从流媒体转码成flv,hls等不同协议供客户端来拉流访问。\n\n参考\n\n1. [关于RTSP/RTP/RTCP](https://zhuanlan.zhihu.com/p/72917813)\n\n1. [会话初始协议SIP与SDP简介](https://cloud.tencent.com/developer/news/387488)\n\n1. [RTMP、HTTP-FLV、HLS，你了解常见的三大直播协议吗\n](https://zhuanlan.zhihu.com/p/48100533)","source":"_posts/流媒体协议.md","raw":"---\ntitle: 流媒体协议\ndate: 2021-07-25 11:16:39\ncategories: \n- 视频\ntags:\n- 视频\n---\n\n# 目的\n总结我在流媒体项目中接触到且使用过的所有协议\n\n# 总体\n\n![image](/images/video/agreement.png)\n\n\n## TCP/UDP\n学习流媒体的协议，首当其冲就是学习TCP与UDP的协议，因为基本的协议都是基于这两种协议来传输\n\n## RTP与RTCP\n\n### 定义\nRTP实时流传输协议，是用于Internet上针对多媒体数据流的一种传输协议。RTP位于传输层，基于UDP之上。RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，服务质量由RTCP来提供。\n\nRTCP是实时传输控制协议，RTCP收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等，服务器可以利用这些信息动态的改变传输速率，甚至改变净荷的类型。RTCP消息也被封装为UDP数据报进行传输\n\n一般而言,目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个 给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的 UDP端口＋1），这样就构成一个UDP端口对。 RTP的发送过程如下，接收过程则相反。\n\n### 协议介绍\n\n#### RTP协议结构\n\n![RTP协议结构](/images/video/RTCP协议.png)\n\n\nRTP分组头部的各字段含义为：\n\nV：RTP版本号。为“10”。\n\nP：填充指示位。P为“1”时表示分组结尾含有1个或多个填充字节，其中这部分不属于有效载荷。\n\nX：扩展指示位。X为“1”时，则表示固定头部后还有一个扩展头部，这种情况较复杂，很少使用。\n\nCC：CSRC计数。指示固定头部后的CSRC的个数\n\nM：标志。\n\nPT：负载类型。表示RTP分组的负载类型。我们常用的有\n\nPayload Type | Codec\n---|---\n0 | PCM μ -Law\n8 | PCM-A Law\n9 | G..722 audio codec\n4 | G..723 audio codec\n15 | G..728 audio codec\n18 | G..729 audio codec\n34 | G..763 audio codec\n31 | G..761 audio codec\n\n序列号：序号顾名思义就是表示RTP分组的次序。初值为随机数，每发送一个增加1。可供接收方检测分组丢失和恢复分组次序。\n\n时间戳：表示RTP分组第一个字节的取样时刻。其初值为随机数，每个采用周期加1。如果每次传送20ms的数据，由于音频的采样频率为8000Hz，即每20ms有160次采样，则每传送20ms的数据，时戳增加160。\n\nSSRC：同步源标识(Synchronous Source)。表示信号的同步源，其值应随机选择，以保证同一个RTP会话中任意两个同步源的SSRC标识不同。\n\nCSRC：分信源(贡献源)标识(Contributing Source)。识别该数据包中的有效载荷的贡献源。换句话说，CSRC标识由混合器插入，其值就是组成复合信号的各个分信号的SSRC标识，用以标识各个组成分信号的信源。RTP分组的头部最多可以包含15个CSRC标识，其数目由CC字段指明。\n\n\n\n\n#### RTCP协议结构\n\n![RTCP](/images/video/RTP协议.jpg)\n\n```\n版本（V）：同RTP包头域。\n\n填充（P）：同RTP包头域。\n\n接收报告计数器（RC）：5比特，该SR包中的接收报告块的数目，可以为零。\n\n包类型（PT）：8比特，SR包是200。\n\n长度域（Length）：16比特，其中存放的是该SR包以32比特为单位的总长度减一。\n\n同步源（SSRC of sender）：SR包发送者的同步源标识符。与对应RTP包中的SSRC一样。\n\nNTP Timestamp（Network time protocol）SR包发送时的绝对时间值。NTP的作用是同步不同的RTP媒体流。\n\nRTP Timestamp：与NTP时间戳对应，与RTP数据包中的RTP时间戳具有相同的单位和随机初始值。\n\nSender’s packet count：从开始发送包到产生这个SR包这段时间里，发送者发送的RTP数据包的总数. SSRC改变时，这个域清零。\n\nSender`s octet count：从开始发送包到产生这个SR包这段时间里，发送者发送的净荷数据的总字节数（不包括头部和填充）。发送者改变其SSRC时，这个域要清零。\n\n同步源n的SSRC标识符：该报告块中包含的是从该源接收到的包的统计信息。\n\n丢失率（Fraction Lost）：表明从上一个SR或RR包发出以来从同步源n(SSRC_n)来的RTP数据包的丢失率。\n\n累计的包丢失数目：从开始接收到SSRC_n的包到发送SR,从SSRC_n传过来的RTP数据包的丢失总数。\n\n收到的扩展最大序列号：从SSRC_n收到的RTP数据包中最大的序列号，\n\n接收抖动（Interarrival jitter）：RTP数据包接受时间的统计方差估计\n\n上次SR时间戳（Last SR,LSR）：取最近从SSRC_n收到的SR包中的NTP时间戳的中间32比特。如果目前还没收到SR包，则该域清零。\n\n上次SR以来的延时（Delay since last SR,DLSR）：上次从SSRC_n收到SR包到发送本报告的延时。\n```\n\n\n根据所携带的控制信息不同RTCP信息包可分为RR（接收者报告包）、SR（源报告包）、SEDS（源描述包）、BYE（离开申明）和APP（特殊应用包）五类5类：\n\n\n类型 | 缩写表示 | 用途 | 描述\n---|---|---|---\n200 | SR（Sender Report）| 发送端报告 | 发送端报告包，用于发送和接收活动源的统计信息；\n201 | RR（Receiver Report）| 接收端报告 | 接收者报告包，用于接收非活动站的统计信息；\n202 | SDES（Source Description Items）| 源点描述 | 源描述包，用于报告和站点相关的信息，包括CNAME；\n203 | BYE | 结束传输 | 断开RTCP包，是站点离开系统的报告，表示结束；\n204 | APP | 特定应用 | 应用特定函数。\n\n\n## RTSP\n\n![image](/images/video/RTSP协议.png)\n\n### 定义\n实时串流协议（应用层）,TCP/IP协议体系中的一个应用层协议，RTSP位于RTP和RTCP之上，可以基于TCP或者UDP来完成数据传输。RTSP实时性比较，扩展性比较好（UDP,TCP传输数据）。rtsp流主要是控制流媒体的行为动作，提供了诸如暂停，快进等控制，而它本身并不传输流媒体数。\n### 协议介绍\n\n1. RTSP结构\n\n```\nrtsp://admin:a12345678@47.106.89.193:10000/h264/ch33/main/av_stream\n```\n\n结构：\nrtsp://user:pwd@host:port/abs_path/content_name\n\nuser:摄像头设备的登陆用户名\n\npwd:摄像头设备的登陆密码\n\nhost:摄像头有效的域名或是IP地址\n\nport:端口号，对于RTSP协议来说，缺省的端口号为554\n\nabs_path:媒体流资源标识\n\n2. 方法定义\n\n方法 | 方向 | 对象 | 要求 | 含义 \n:-:|-|-|-|-|-\nDESCRIBE | C->S | P，S | 推荐 | 检查演示或媒体对象的描述，也允许使用接收头指定用户理解的描述格式。DESCRIBE的答复-响应组成媒体RTSP初始阶段\nANNOUNCE | C->S,S->C | P，S | 可选 | 当从用户发往服务器时，ANNOUNCE将请求URL识别的演示或媒体对象描述发送给服务器；反之，ANNOUNCE实时更新连接描述。如新媒体流加入演示，整个演示描述再次发送，而不仅仅是附加组件，使组件能被删除\nGET_PARAMETER | C->S,S->C | P，S | 可选 | GET_PARAMETER请求检查URL指定的演示与媒体的参数值。没有实体体时，GET_PARAMETER也许能用来测试用户与服务器的连通情况\nOPTIONS | C->S,S->C | P，S | 要求 | 可在任意时刻发出OPTIONS请求，如用户打算尝试非标准请求，并不影响服务器状态\nPAUSE | C->S | P，S | 推荐 | PAUSE请求引起流发送临时中断。如请求URL命名一个流，仅回放和记录被停止；如请求URL命名一个演示或流组，演示或组中所有当前活动的流发送都停止。恢复回放或记录后，必须维持同步。在SETUP消息中连接头超时参数所指定时段期间被暂停后，尽管服务器可能关闭连接并释放资源，但服务器资源会被预订\nPLAY | C->S | P，S | 要求 | PLAY告诉服务器以SETUP指定的机制开始发送数据；直到一些SETUP请求被成功响应，客户端才可发布PLAY请求。PLAY请求将正常播放时间设置在所指定范围的起始处，发送流数据直到范围的结束处。PLAY请求可排成队列，服务器将PLAY请求排成队列，顺序执行\nRECORD | C->S | P，S | 可选 | 该方法根据演示描述初始化媒体数据记录范围，时标反映开始和结束时间；如没有给出时间范围，使用演示描述提供的开始和结束时间。如连接已经启动，立即开始记录，服务器数据请求URL或其他URL决定是否存储记录的数据；如服务器没有使用URL请求，响应应为201（创建），并包含描述请求状态和参考新资源的实体与位置头。支持现场演示记录的媒体服务器必须支持时钟范围格式，smpte格式没有意义\nREDIRECT | S->C | P，S | 可选 | 重定向请求通知客户端连接到另一服务器地址。它包含强制头地址，指示客户端发布URL请求；也可能包括参数范围，以指明重定向何时生效。若客户端要继续发送或接收URL媒体，客户端必须对当前连接发送TEARDOWN请求，而对指定主执新连接发送SETUP请求\nSETUP | C->S | S | 要求 | 对URL的SETUP请求指定用于流媒体的传输机制。客户端对正播放的流发布一个SETUP请求，以改变服务器允许的传输参数。如不允许这样做，响应错误为\"455 Method Not Valid In This State”。为了透过防火墙，客户端必须指明传输参数，即使对这些参数没有影响\nSET_PARAMETER | C->S,S->C | P，S | 可选 | 这个方法请求设置演示或URL指定流的参数值。请求仅应包含单个参数，允许客户端决定某个特殊请求为何失败。如请求包含多个参数，所有参数可成功设置，服务器必须只对该请求起作用。服务器必须允许参数可重复设置成同一值，但不让改变参数值。注意：媒体流传输参数必须用SETUP命令设置。将设置传输参数限制为SETUP有利于防火墙。将参数划分成规则排列形式，结果有更多有意义的错误指示\nTEARDOWN | C->S | S | 要求 | TEARDOWN请求停止给定URL流发送，释放相关资源。如URL是此演示URL，任何RTSP连接标识不再有效。除非全部传输参数是连接描述定义的，SETUP请求必须在连接可再次播放前发布\n\n\n\n3. 交互流程\n```\nC表示RTSP客户端,S表示RTSP服务端\n\n1. 第一步：查询服务器端可用方法\n1.C->S:OPTION request //询问S有哪些方法可用\n\n1.S->C:OPTION response //S回应信息的public头字段中包括提供的所有可用方法\n\n2. 第二步：得到媒体描述信息\n2.C->S:DESCRIBE request //要求得到S提供的媒体描述信息\n\n2.S->C:DESCRIBE response //S回应媒体描述信息，一般是sdp信息\n\n3. 第三步：建立RTSP会话\n3.C->S:SETUP request //通过Transport头字段列出可接受的传输选项，请求S建立会话\n\n3.S->C:SETUP response //S建立会话，通过Transport头字段返回选择的具体转输选项，并返回建立的Session ID;\n\n4. 第四步：请求开始传送数据\n4.C->S:PLAY request //C请求S开始发送数据\n\n4.S->C:PLAY response //S回应该请求的信息\n\n5. 第五步： 数据传送播放中\nS->C:发送流媒体数据 // 通过RTP协议传送数据\n\n6. 第六步：关闭会话，退出\n6.C->S:TEARDOWN request //C请求关闭会话\n\n6.S->C:TEARDOWN response //S回应该请求\n```\n\n\n\n4. RTSP与HTTP区别\n- RTSP中客户端和服务器都可以发出请求,HTTP只能客户端发起请求；\n- RTSP相比HTTP提供多种方法定义\n- RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据\n\n\n\n## SDP/SIP\n\n### 定义\nSIP与SDP这两个协议会在国标视频上会出现比较多。其中一般会与RTSP等协议共同\n\nSIP它是一个基于文本的应用层控制协议，独立于底层传输协议，用于建立、修改和终止IP网络上的双方或多方多媒体会话\n\nSDP（Session Description Protocol）是一个用来描述多媒体会话的应用层控制协议，它是一个基于文本的协议，用于会话建立过程中的媒体类型和编码方案的协商等\n\n### 协议介绍\n\n#### SIP介绍\n\n1. SIP 角色\n\n角色 | 作用\n---|---\n用户代理（UA） | 用户代理客户端（UAC）和用户代理服务器（UAS）组成，UAC负责发起呼叫，UAS负责接收呼叫并作出响应\n代理服务器（PS） | 通过它把来自用户代理客户端（UAC）的请求转发到用户代理服务端（UAS），并把UAS的响应消息转发回UAC\n注册服务器（register server） | 是具有接收注册请求、将请求中携带的信息进行保存并提供本域内位置服务的功能服务器\n重定向服务器（redirect server） | 负责规划SIP呼叫路由。它将获得的呼叫下一跳地址信息告诉呼叫方，以使呼叫方根据此地址直接向下一跳发出请求，此后重定向服务器退出呼叫过程。\n\n2. SIP请求\n```\n是客户端发给服务器激活一个SIP操作的消息，由一个方法名（Method）、一个请求URI（Request-URI）和一个协议版本 （SIP-Version）组成，三个部分之间以空格（SP）间隔。\n\nRequest-Line  =  Method + SP + Request-URI + SP + SIP-Version + CRLF\n\nRFC中定义了6中请求：\n\nINVITE：表明接收用户或服务被邀请加入一个会话；也可以使用这种方式来修改先前建立会话的特性；成功响应（200 OK）表明被叫方愿意参与会话；\n\nACK：确认UAC已经接收到了INVITE请求的最终响应（只与INVITE请求一起使用）；用于结束一个200 OK响应；若INVITE请求中不含有会话描述信息，ACK可以包含一个最终会话描述的消息体；\n\nOPTION：UA用此向UAS查询它的功能；\n\nBYE：用于终结一个先前建立的会话；\n\nCANCEL：使UAC和网络服务器取消一个正在进行的请求（如INVITE）；\n\nREGISTER：客户端注册其目前的位置信息；\n```\n\n\n3. SIP响应\n```\n服务器向客户端发送SIP响应，指明客户端先前发送给服务器的SIP请求的状态；由一个协议版本（SIP-Version），一个状态码（Status-Code）和一个原因说明（Reason-Phrase）组成，类似于请求消息，三个部分之间也以空格字符（SP）间隔。\n\nStatus-Line := SIP-Version + SP + Status-Code + SP + Reason-Phrase + CRLF\n\n状态码是一个100～699之间的3位正整数（具体参见后面附录），它表示对于一个请求消息的响应结果；原因说明是一串可以显示的字符，用于对响应的状态码进行简短说明。\n\n1xx：临时响应 （Provisional）；之前的请求消息已经收到，并准备接着处理后面的请求消息。\n\n2xx：成功响应 （Success）； 操作成功，请求消息已被收到并且成功地处理。\n\n3xx：重定向响应 （Redirection）； 服务器向客户端返回其它可能的位置，客户端应当根据响应中包含的地址信息向另一个服务器重发请求消息。\n\n4xx： 客户端错误 （Client Error）； 请求由于客户端的错误而失败，客户端可以根据响应状态码修改并重发刚才的请求消息。\n\n5xx：服务器错误 （Server Error） ；请求由于服务器的错误而失败，客户端可以向另一个服务器重发请求消息。\n\n6xx：全局错误（Global Failure）； 请求失败，客户端不应该再向任何服务器重发该请求消息。\n```\n\n4. 标题头\n```\n遵从HTTP标题头（RFC2616）定义的同样格式：每个标题头由字段名，紧跟着冒号(:)和字段组成。\n\n主要标题头（详情参见\n\nSIP常见头域（header）说明\n\nFrom：定义请求发起者（通常是发送者AOR），包含SIP或SIP URI和一个可选的显示名字；\n\nTo：定义了请求的接收者（通常是接收者AOR），包含SIP或SIP URI和一个可选的显示名字；因重定向和转移，SIP请求不一定发送给‘希望的’接收者；\n\nCall-ID：定义了一系列的SIP消息，对所有由对话中的UA发送的所有SIP请求和响应，Call-ID必须唯一；\n\nCseq：由一个整数值和一个方式名称组成，在一个对话中标识和序列SIP请求，也区分重传和新消息；\n\nVia：定义请求路径和响应要发送的地址；\n\nContact：定义US希望接收新SIP请求的SIP或SIPS URI（实际地址）；\n\nAllow：列出产生SIP消息的UA所支持的功能集合；\n\nSupported：列出所有UA支持的SIP扩展（RFC3262）；\n\nRequire：包含远端UA必须支持的SIP扩展；\n\nContent-Type：请求或响应的消息体类型；\n\nContent-Length：请求或响应的消息体的大小（十进制）；\n```\n\n#### SDP协议\n\nSDP协议内容(具体可参考国标规范文档)\n```\n1 v=:Version ，表示协议的版本号\n2 o=: Origin,表示源。值域中各项的含义依次是username(用户名)，sess-id(会话ID)，sess-version(会话版本号)，nettype(网络类型)，addrtype(地址类型)，unucast-address(单播地址)。\n3 s=:Session Name,表示本sdp所描述的session的名称\n4 c=:Connection Data 链接数据。其中值域中以空格分配的两个字段分贝是网络类型和网络地址，以后的RTP流就会发到该地址上。\n5 b=:Badwidth type，带宽类型\n6 t=:Timing ,起止时间，0表示无限\n7 m=:audio Media Type,媒体类型。audio表示音频，50452表示音频端口号，RTP/AVR是传输协议；后面是支持的Codec类型，与RTP流中的PayloadType(载荷类型)相对应，在这里分别是8,0,98和101,8和0分别代表PCMA和PCMU，他们属于静态编码，大于95的编码都属于动态编码，需要在后面使用“a=rtpmap”进行说明。\n8 a=: Attributes,属性。 它用于描述上面的音频的属性。如本例中98代表8000hz的ILBC编码，101代表RFC2833dtmf事件。a=sendrecv表示该媒体流可用于收和发，其他的还有sendonly(仅收)，recvonly(仅发)和inactive(不收不发)\n9 v=:Video，视频。\n```\n\n#### 点播流程\n\n为了更加熟悉SIP的流程，截取点播流程的流程图。可以看出，SIP传输过程当中都会有SDP的使用。\n\n![SIP点播流程](/images/video/wps2.png)\n\n\n## RTMP/HTTP-HLS/HTTP-FLV\n\nRTMP、HTTP-HLS与HTTP-FLV目前市面上比较常用的流媒体协议，都能基于浏览器来观看。\n\n- RTMP：实时消息传送协议，基于FLASH播放器的私有协议，默认使用端口 1935。RTMP一般被切割一个个块（chunk）的形式基于TCP协议上传输的明文协议。市面上的摄像头基本都会支持RTMP的形式，而且RTMP一般延时在 1-3s 之间相对延时较低，不过目前来说谷歌禁用了FLASH，可能对RTMP支持可能有所减弱\n\n- HTTP-HLS：HTTP Live Streaming，苹果公司基于HTTP的流媒体传输协议。工作原理是在服务端将视频流切片成ts小文件形式，通过m3u8索引文件访问ts文件。不过HLS的延迟在10s以上，且文件比较碎片化比较难以保存，但是有利有弊，正因为有ts文件落地，可支持回放等功能。\n- HTTP-FLV：Flash Video，主要是将音视频数据封装成FLV格式，然后通过 HTTP 协议传输给客户端。像B站都是使用该协议进行PC页面播放。FLV延迟比较低。\n\n- ws-flv：ws-flv直播技术基本与http-flv一致，无非是传输介质换成了websocket协议，除了解除了http-flv不能同时打开过多同域名下的直播窗口的限制，其他技术特性、参数基本与http-flv一致。目前看，ws-flv既适合视频监控(可以同时打开多路监控视频)也适合视频直播行业，是rtmp很高的升级替代方案。\n- webrtc：webrtc是谷歌主导的视频通话技术标准，目前各大主流浏览器都兼容该标准。通过该技术，用户可以在浏览器上实现无插件的视频通话，该技术也可以用于实现低延时的视频直播。目前业界也有很多基于webrtc的应用和产品，但是很多局限于视频聊天等低延时交互式场景，在视频监控领域，目前还尚未流行。而且该技术栈目前还在持续更新，技术难点太多，要与视频监控领域融合还需时日。\n\n### 协议介绍\n\n#### RTMP\n\n![RTMP](/images/video/hls-message.png)\n\n\n具体可参考：[RTMP协议详解](https://www.jianshu.com/p/d511d59b185c)\n\n\n#### HLS\n\n[HLS协议详解](https://www.jianshu.com/p/d511d59b185c)\n\n以下简单介绍下m3u8的相关内容\n\n![m3u8](/images/video/hls.png)\n\n```\nEXTM3U：每个M3U文件第一行必须是这个tag，请标示作用\n\nEXT-X-MEDIA-SEQUENCE:7\n每一个media URI 在 PlayList中只有唯一的序号，相邻之间序号+1, 一个media URI并不是必须要包含的，如果没有，默认为0\n\nEXTINF:\nduration 指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效，title是下载资源的url\n\nEXT-X-TARGETDURATION\n指定最大的媒体段时间长（秒）。所以#EXTINF中指定的时间长度必须小于或是等于这个最大值。这个tag在整个PlayList文件中只能出现一 次（在嵌套的情况下，一般有真正ts url的m3u8才会出现该tag）\n\nEXT-X-KEY\n表示怎么对media segments进行解码。其作用范围是下次该tag出现前的所有media URI，属性为NONE 或者 AES-128。NONE表示 URI以及IV（Initialization Vector）属性必须不存在， AES-128(Advanced EncryptionStandard)表示URI必须存在，IV可以不存在。\n对于AES-128的情况，keytag和URI属性共同表示了一个key文件，通过URI可以获得这个key，如果没有IV（Initialization Vector）,则使用序列号作为IV进行编解码，将序列号的高位赋到16个字节的buffer中，左边补0；如果有IV，则将改值当成16个字节的16进制数。\n\nEXT-X-PROGRAM-DATE-TIME\n将一个绝对时间或是日期和一个媒体段中的第一个sample相关联，只对下一个meida URI有效，格式如#EXT-X-PROGRAM-DATE-TIME:\nFor example: #EXT-X-PROGRAM-DATE-TIME:2010-02-19T14:54:23.031+08:00\n\nEXT-X-ALLOW-CACHE\n是否允许做cache，这个可以在PlayList文件中任意地方出现，并且最多出现一次，作用效果是所有的媒体段。格式如下：#EXT-X-ALLOW-CACHE:\n\nEXT-X-PLAYLIST-TYPE\n提供关于PlayList的可变性的信息， 这个对整个PlayList文件有效，是可选的，格式如下：#EXT-X-PLAYLIST-TYPE:：如果是VOD，则服务器不能改变PlayList 文件；如果是EVENT，则服务器不能改变或是删除PlayList文件中的任何部分，但是可以向该文件中增加新的一行内容。\n\nEXT-X-ENDLIST\n表示PlayList的末尾了，它可以在PlayList中任意位置出现，但是只能出现一个，格式如下：#EXT-X-ENDLIST\n\nEXT-X-MEDIA\n被用来在PlayList中表示相同内容的不用语种/译文的版本，比如可以通过使用3个这种tag表示3中不用语音的音频，或者用2个这个tag表示不同角度的video在PlayLists中。这个标签是独立存在的，属性包含：\nURI：如果没有，则表示这个tag描述的可选择版本在主PlayList的EXT-X-STREAM-INF中存在;\nTYPE:AUDIO and VIDEO;\nGROUP-ID:具有相同ID的MEDIAtag，组成一组样式；\nLANGUAGE：确定使用的主要语言\nNAME：人类可读的语言的翻译\nDEFAULT：YES或是NO，默认是No，如果是YES，则客户端会以这种选项来播放，除非用户自己进行选择。\nAUTOSELECT：YES或是NO，默认是No，如果是YES，则客户端会根据当前播放环境来进行选择（用户没有根据自己偏好进行选择的前提下）。\n\nEXT-X-STREAM-INF\n指定一个包含多媒体信息的 media URI 作为PlayList，一般做M3U8的嵌套使用，它只对紧跟后面的URI有效，格式如下：#EXT-X-STREAM-INF:有以下属性：\nBANDWIDTH：带宽，必须有。\nPROGRAM-ID：该值是一个十进制整数，惟一地标识一个在PlayList文件范围内的特定的描述。一个PlayList 文件中可能包含多个有相同ID的此tag。\nCODECS：不是必须的。\nRESOLUTION：分辨率。\nAUDIO：这个值必须和AUDIO类别的“EXT-X-MEDIA”标签中“GROUP-ID”属性值相匹配。\nVIDEO：同上\n```\n\n\n#### FLV\n\n[FLV协议详解](https://zhuanlan.zhihu.com/p/287220)\n\n\n### 性能对比\n\n![协议性能对比](/images/video/协议性能对比.png)\n\n\n## PES/TS/ES流\n\nPES、TS、ES流都是用于封装视频、音频数据的数据流。\n\nES流（Elementary Stream）：基本码流，不分段的音频、视频或其他信息的连续码流。\n\nPES流：把基本流ES分割成段，并加上相应头文件打包成形的打包基本码流。\n\nPS流（Program Stream）：节目流，将具有共同时间基准的一个或多个PES组合（复合）而成的单一数据流（用于播放或编辑系统，如m2p）。\n\nTS流（Transport Stream）：传输流，将具有共同时间基准或独立时间基准的一个或多个PES组合（复合）而成的单一数据流（用于数据传输）。\n\n## 总结\n上面列了很多我在项目中所有用到过的协议，每种协议都有不同的封装格式以及各自不同属性，个人觉得对于开发者或者使用者来说不一定每种协议都要面面俱到，平常大概知道他们具体作用性能和普遍的属性之类就可以，到真正使用的时候再去深入了解，反而会更高效。以下，我总结下这段时间来对这几个协议的了解：\n    ![协议](/images/video/zlm.png)\n\n\n根据上图可以看出，一般来说推流的方式可能会议国标方式或者接入海康、大华等厂商的摄像头来直接推流到流媒体，而从流媒体转码成flv,hls等不同协议供客户端来拉流访问。\n\n参考\n\n1. [关于RTSP/RTP/RTCP](https://zhuanlan.zhihu.com/p/72917813)\n\n1. [会话初始协议SIP与SDP简介](https://cloud.tencent.com/developer/news/387488)\n\n1. [RTMP、HTTP-FLV、HLS，你了解常见的三大直播协议吗\n](https://zhuanlan.zhihu.com/p/48100533)","slug":"流媒体协议","published":1,"updated":"2021-09-07T08:00:52.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhs4001ed0tvg15ivsvz","content":"<h1 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h1><p>总结我在流媒体项目中接触到且使用过的所有协议</p>\n<h1 id=\"总体\"><a href=\"#总体\" class=\"headerlink\" title=\"总体\"></a>总体</h1><p><img src=\"/images/video/agreement.png\" alt=\"image\"></p>\n<h2 id=\"TCP-UDP\"><a href=\"#TCP-UDP\" class=\"headerlink\" title=\"TCP/UDP\"></a>TCP/UDP</h2><p>学习流媒体的协议，首当其冲就是学习TCP与UDP的协议，因为基本的协议都是基于这两种协议来传输</p>\n<h2 id=\"RTP与RTCP\"><a href=\"#RTP与RTCP\" class=\"headerlink\" title=\"RTP与RTCP\"></a>RTP与RTCP</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>RTP实时流传输协议，是用于Internet上针对多媒体数据流的一种传输协议。RTP位于传输层，基于UDP之上。RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，服务质量由RTCP来提供。</p>\n<p>RTCP是实时传输控制协议，RTCP收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等，服务器可以利用这些信息动态的改变传输速率，甚至改变净荷的类型。RTCP消息也被封装为UDP数据报进行传输</p>\n<p>一般而言,目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个 给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的 UDP端口＋1），这样就构成一个UDP端口对。 RTP的发送过程如下，接收过程则相反。</p>\n<h3 id=\"协议介绍\"><a href=\"#协议介绍\" class=\"headerlink\" title=\"协议介绍\"></a>协议介绍</h3><h4 id=\"RTP协议结构\"><a href=\"#RTP协议结构\" class=\"headerlink\" title=\"RTP协议结构\"></a>RTP协议结构</h4><p><img src=\"/images/video/RTCP协议.png\" alt=\"RTP协议结构\"></p>\n<p>RTP分组头部的各字段含义为：</p>\n<p>V：RTP版本号。为“10”。</p>\n<p>P：填充指示位。P为“1”时表示分组结尾含有1个或多个填充字节，其中这部分不属于有效载荷。</p>\n<p>X：扩展指示位。X为“1”时，则表示固定头部后还有一个扩展头部，这种情况较复杂，很少使用。</p>\n<p>CC：CSRC计数。指示固定头部后的CSRC的个数</p>\n<p>M：标志。</p>\n<p>PT：负载类型。表示RTP分组的负载类型。我们常用的有</p>\n<table>\n<thead>\n<tr>\n<th>Payload Type</th>\n<th>Codec</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>PCM μ -Law</td>\n</tr>\n<tr>\n<td>8</td>\n<td>PCM-A Law</td>\n</tr>\n<tr>\n<td>9</td>\n<td>G..722 audio codec</td>\n</tr>\n<tr>\n<td>4</td>\n<td>G..723 audio codec</td>\n</tr>\n<tr>\n<td>15</td>\n<td>G..728 audio codec</td>\n</tr>\n<tr>\n<td>18</td>\n<td>G..729 audio codec</td>\n</tr>\n<tr>\n<td>34</td>\n<td>G..763 audio codec</td>\n</tr>\n<tr>\n<td>31</td>\n<td>G..761 audio codec</td>\n</tr>\n</tbody>\n</table>\n<p>序列号：序号顾名思义就是表示RTP分组的次序。初值为随机数，每发送一个增加1。可供接收方检测分组丢失和恢复分组次序。</p>\n<p>时间戳：表示RTP分组第一个字节的取样时刻。其初值为随机数，每个采用周期加1。如果每次传送20ms的数据，由于音频的采样频率为8000Hz，即每20ms有160次采样，则每传送20ms的数据，时戳增加160。</p>\n<p>SSRC：同步源标识(Synchronous Source)。表示信号的同步源，其值应随机选择，以保证同一个RTP会话中任意两个同步源的SSRC标识不同。</p>\n<p>CSRC：分信源(贡献源)标识(Contributing Source)。识别该数据包中的有效载荷的贡献源。换句话说，CSRC标识由混合器插入，其值就是组成复合信号的各个分信号的SSRC标识，用以标识各个组成分信号的信源。RTP分组的头部最多可以包含15个CSRC标识，其数目由CC字段指明。</p>\n<h4 id=\"RTCP协议结构\"><a href=\"#RTCP协议结构\" class=\"headerlink\" title=\"RTCP协议结构\"></a>RTCP协议结构</h4><p><img src=\"/images/video/RTP协议.jpg\" alt=\"RTCP\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">版本（V）：同RTP包头域。</span><br><span class=\"line\"></span><br><span class=\"line\">填充（P）：同RTP包头域。</span><br><span class=\"line\"></span><br><span class=\"line\">接收报告计数器（RC）：5比特，该SR包中的接收报告块的数目，可以为零。</span><br><span class=\"line\"></span><br><span class=\"line\">包类型（PT）：8比特，SR包是200。</span><br><span class=\"line\"></span><br><span class=\"line\">长度域（Length）：16比特，其中存放的是该SR包以32比特为单位的总长度减一。</span><br><span class=\"line\"></span><br><span class=\"line\">同步源（SSRC of sender）：SR包发送者的同步源标识符。与对应RTP包中的SSRC一样。</span><br><span class=\"line\"></span><br><span class=\"line\">NTP Timestamp（Network time protocol）SR包发送时的绝对时间值。NTP的作用是同步不同的RTP媒体流。</span><br><span class=\"line\"></span><br><span class=\"line\">RTP Timestamp：与NTP时间戳对应，与RTP数据包中的RTP时间戳具有相同的单位和随机初始值。</span><br><span class=\"line\"></span><br><span class=\"line\">Sender’s packet count：从开始发送包到产生这个SR包这段时间里，发送者发送的RTP数据包的总数. SSRC改变时，这个域清零。</span><br><span class=\"line\"></span><br><span class=\"line\">Sender`s octet count：从开始发送包到产生这个SR包这段时间里，发送者发送的净荷数据的总字节数（不包括头部和填充）。发送者改变其SSRC时，这个域要清零。</span><br><span class=\"line\"></span><br><span class=\"line\">同步源n的SSRC标识符：该报告块中包含的是从该源接收到的包的统计信息。</span><br><span class=\"line\"></span><br><span class=\"line\">丢失率（Fraction Lost）：表明从上一个SR或RR包发出以来从同步源n(SSRC_n)来的RTP数据包的丢失率。</span><br><span class=\"line\"></span><br><span class=\"line\">累计的包丢失数目：从开始接收到SSRC_n的包到发送SR,从SSRC_n传过来的RTP数据包的丢失总数。</span><br><span class=\"line\"></span><br><span class=\"line\">收到的扩展最大序列号：从SSRC_n收到的RTP数据包中最大的序列号，</span><br><span class=\"line\"></span><br><span class=\"line\">接收抖动（Interarrival jitter）：RTP数据包接受时间的统计方差估计</span><br><span class=\"line\"></span><br><span class=\"line\">上次SR时间戳（Last SR,LSR）：取最近从SSRC_n收到的SR包中的NTP时间戳的中间32比特。如果目前还没收到SR包，则该域清零。</span><br><span class=\"line\"></span><br><span class=\"line\">上次SR以来的延时（Delay since last SR,DLSR）：上次从SSRC_n收到SR包到发送本报告的延时。</span><br></pre></td></tr></table></figure>\n<p>根据所携带的控制信息不同RTCP信息包可分为RR（接收者报告包）、SR（源报告包）、SEDS（源描述包）、BYE（离开申明）和APP（特殊应用包）五类5类：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>缩写表示</th>\n<th>用途</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>SR（Sender Report）</td>\n<td>发送端报告</td>\n<td>发送端报告包，用于发送和接收活动源的统计信息；</td>\n</tr>\n<tr>\n<td>201</td>\n<td>RR（Receiver Report）</td>\n<td>接收端报告</td>\n<td>接收者报告包，用于接收非活动站的统计信息；</td>\n</tr>\n<tr>\n<td>202</td>\n<td>SDES（Source Description Items）</td>\n<td>源点描述</td>\n<td>源描述包，用于报告和站点相关的信息，包括CNAME；</td>\n</tr>\n<tr>\n<td>203</td>\n<td>BYE</td>\n<td>结束传输</td>\n<td>断开RTCP包，是站点离开系统的报告，表示结束；</td>\n</tr>\n<tr>\n<td>204</td>\n<td>APP</td>\n<td>特定应用</td>\n<td>应用特定函数。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"RTSP\"><a href=\"#RTSP\" class=\"headerlink\" title=\"RTSP\"></a>RTSP</h2><p><img src=\"/images/video/RTSP协议.png\" alt=\"image\"></p>\n<h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>实时串流协议（应用层）,TCP/IP协议体系中的一个应用层协议，RTSP位于RTP和RTCP之上，可以基于TCP或者UDP来完成数据传输。RTSP实时性比较，扩展性比较好（UDP,TCP传输数据）。rtsp流主要是控制流媒体的行为动作，提供了诸如暂停，快进等控制，而它本身并不传输流媒体数。</p>\n<h3 id=\"协议介绍-1\"><a href=\"#协议介绍-1\" class=\"headerlink\" title=\"协议介绍\"></a>协议介绍</h3><ol>\n<li>RTSP结构</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtsp://admin:a12345678@47.106.89.193:10000/h264/ch33/main/av_stream</span><br></pre></td></tr></table></figure>\n<p>结构：<br>rtsp://user:pwd@host:port/abs_path/content_name</p>\n<p>user:摄像头设备的登陆用户名</p>\n<p>pwd:摄像头设备的登陆密码</p>\n<p>host:摄像头有效的域名或是IP地址</p>\n<p>port:端口号，对于RTSP协议来说，缺省的端口号为554</p>\n<p>abs_path:媒体流资源标识</p>\n<ol>\n<li>方法定义</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法</th>\n<th>方向</th>\n<th>对象</th>\n<th>要求</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">DESCRIBE</td>\n<td>C-&gt;S</td>\n<td>P，S</td>\n<td>推荐</td>\n<td>检查演示或媒体对象的描述，也允许使用接收头指定用户理解的描述格式。DESCRIBE的答复-响应组成媒体RTSP初始阶段</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ANNOUNCE</td>\n<td>C-&gt;S,S-&gt;C</td>\n<td>P，S</td>\n<td>可选</td>\n<td>当从用户发往服务器时，ANNOUNCE将请求URL识别的演示或媒体对象描述发送给服务器；反之，ANNOUNCE实时更新连接描述。如新媒体流加入演示，整个演示描述再次发送，而不仅仅是附加组件，使组件能被删除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GET_PARAMETER</td>\n<td>C-&gt;S,S-&gt;C</td>\n<td>P，S</td>\n<td>可选</td>\n<td>GET_PARAMETER请求检查URL指定的演示与媒体的参数值。没有实体体时，GET_PARAMETER也许能用来测试用户与服务器的连通情况</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">OPTIONS</td>\n<td>C-&gt;S,S-&gt;C</td>\n<td>P，S</td>\n<td>要求</td>\n<td>可在任意时刻发出OPTIONS请求，如用户打算尝试非标准请求，并不影响服务器状态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PAUSE</td>\n<td>C-&gt;S</td>\n<td>P，S</td>\n<td>推荐</td>\n<td>PAUSE请求引起流发送临时中断。如请求URL命名一个流，仅回放和记录被停止；如请求URL命名一个演示或流组，演示或组中所有当前活动的流发送都停止。恢复回放或记录后，必须维持同步。在SETUP消息中连接头超时参数所指定时段期间被暂停后，尽管服务器可能关闭连接并释放资源，但服务器资源会被预订</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PLAY</td>\n<td>C-&gt;S</td>\n<td>P，S</td>\n<td>要求</td>\n<td>PLAY告诉服务器以SETUP指定的机制开始发送数据；直到一些SETUP请求被成功响应，客户端才可发布PLAY请求。PLAY请求将正常播放时间设置在所指定范围的起始处，发送流数据直到范围的结束处。PLAY请求可排成队列，服务器将PLAY请求排成队列，顺序执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RECORD</td>\n<td>C-&gt;S</td>\n<td>P，S</td>\n<td>可选</td>\n<td>该方法根据演示描述初始化媒体数据记录范围，时标反映开始和结束时间；如没有给出时间范围，使用演示描述提供的开始和结束时间。如连接已经启动，立即开始记录，服务器数据请求URL或其他URL决定是否存储记录的数据；如服务器没有使用URL请求，响应应为201（创建），并包含描述请求状态和参考新资源的实体与位置头。支持现场演示记录的媒体服务器必须支持时钟范围格式，smpte格式没有意义</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">REDIRECT</td>\n<td>S-&gt;C</td>\n<td>P，S</td>\n<td>可选</td>\n<td>重定向请求通知客户端连接到另一服务器地址。它包含强制头地址，指示客户端发布URL请求；也可能包括参数范围，以指明重定向何时生效。若客户端要继续发送或接收URL媒体，客户端必须对当前连接发送TEARDOWN请求，而对指定主执新连接发送SETUP请求</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SETUP</td>\n<td>C-&gt;S</td>\n<td>S</td>\n<td>要求</td>\n<td>对URL的SETUP请求指定用于流媒体的传输机制。客户端对正播放的流发布一个SETUP请求，以改变服务器允许的传输参数。如不允许这样做，响应错误为”455 Method Not Valid In This State”。为了透过防火墙，客户端必须指明传输参数，即使对这些参数没有影响</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SET_PARAMETER</td>\n<td>C-&gt;S,S-&gt;C</td>\n<td>P，S</td>\n<td>可选</td>\n<td>这个方法请求设置演示或URL指定流的参数值。请求仅应包含单个参数，允许客户端决定某个特殊请求为何失败。如请求包含多个参数，所有参数可成功设置，服务器必须只对该请求起作用。服务器必须允许参数可重复设置成同一值，但不让改变参数值。注意：媒体流传输参数必须用SETUP命令设置。将设置传输参数限制为SETUP有利于防火墙。将参数划分成规则排列形式，结果有更多有意义的错误指示</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TEARDOWN</td>\n<td>C-&gt;S</td>\n<td>S</td>\n<td>要求</td>\n<td>TEARDOWN请求停止给定URL流发送，释放相关资源。如URL是此演示URL，任何RTSP连接标识不再有效。除非全部传输参数是连接描述定义的，SETUP请求必须在连接可再次播放前发布</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>交互流程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C表示RTSP客户端,S表示RTSP服务端</span><br><span class=\"line\"></span><br><span class=\"line\">1. 第一步：查询服务器端可用方法</span><br><span class=\"line\">1.C-&gt;S:OPTION request //询问S有哪些方法可用</span><br><span class=\"line\"></span><br><span class=\"line\">1.S-&gt;C:OPTION response //S回应信息的public头字段中包括提供的所有可用方法</span><br><span class=\"line\"></span><br><span class=\"line\">2. 第二步：得到媒体描述信息</span><br><span class=\"line\">2.C-&gt;S:DESCRIBE request //要求得到S提供的媒体描述信息</span><br><span class=\"line\"></span><br><span class=\"line\">2.S-&gt;C:DESCRIBE response //S回应媒体描述信息，一般是sdp信息</span><br><span class=\"line\"></span><br><span class=\"line\">3. 第三步：建立RTSP会话</span><br><span class=\"line\">3.C-&gt;S:SETUP request //通过Transport头字段列出可接受的传输选项，请求S建立会话</span><br><span class=\"line\"></span><br><span class=\"line\">3.S-&gt;C:SETUP response //S建立会话，通过Transport头字段返回选择的具体转输选项，并返回建立的Session ID;</span><br><span class=\"line\"></span><br><span class=\"line\">4. 第四步：请求开始传送数据</span><br><span class=\"line\">4.C-&gt;S:PLAY request //C请求S开始发送数据</span><br><span class=\"line\"></span><br><span class=\"line\">4.S-&gt;C:PLAY response //S回应该请求的信息</span><br><span class=\"line\"></span><br><span class=\"line\">5. 第五步： 数据传送播放中</span><br><span class=\"line\">S-&gt;C:发送流媒体数据 // 通过RTP协议传送数据</span><br><span class=\"line\"></span><br><span class=\"line\">6. 第六步：关闭会话，退出</span><br><span class=\"line\">6.C-&gt;S:TEARDOWN request //C请求关闭会话</span><br><span class=\"line\"></span><br><span class=\"line\">6.S-&gt;C:TEARDOWN response //S回应该请求</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>RTSP与HTTP区别</p>\n</li>\n</ol>\n<ul>\n<li>RTSP中客户端和服务器都可以发出请求,HTTP只能客户端发起请求；</li>\n<li>RTSP相比HTTP提供多种方法定义</li>\n<li>RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据</li>\n</ul>\n<h2 id=\"SDP-SIP\"><a href=\"#SDP-SIP\" class=\"headerlink\" title=\"SDP/SIP\"></a>SDP/SIP</h2><h3 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>SIP与SDP这两个协议会在国标视频上会出现比较多。其中一般会与RTSP等协议共同</p>\n<p>SIP它是一个基于文本的应用层控制协议，独立于底层传输协议，用于建立、修改和终止IP网络上的双方或多方多媒体会话</p>\n<p>SDP（Session Description Protocol）是一个用来描述多媒体会话的应用层控制协议，它是一个基于文本的协议，用于会话建立过程中的媒体类型和编码方案的协商等</p>\n<h3 id=\"协议介绍-2\"><a href=\"#协议介绍-2\" class=\"headerlink\" title=\"协议介绍\"></a>协议介绍</h3><h4 id=\"SIP介绍\"><a href=\"#SIP介绍\" class=\"headerlink\" title=\"SIP介绍\"></a>SIP介绍</h4><ol>\n<li>SIP 角色</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>角色</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用户代理（UA）</td>\n<td>用户代理客户端（UAC）和用户代理服务器（UAS）组成，UAC负责发起呼叫，UAS负责接收呼叫并作出响应</td>\n</tr>\n<tr>\n<td>代理服务器（PS）</td>\n<td>通过它把来自用户代理客户端（UAC）的请求转发到用户代理服务端（UAS），并把UAS的响应消息转发回UAC</td>\n</tr>\n<tr>\n<td>注册服务器（register server）</td>\n<td>是具有接收注册请求、将请求中携带的信息进行保存并提供本域内位置服务的功能服务器</td>\n</tr>\n<tr>\n<td>重定向服务器（redirect server）</td>\n<td>负责规划SIP呼叫路由。它将获得的呼叫下一跳地址信息告诉呼叫方，以使呼叫方根据此地址直接向下一跳发出请求，此后重定向服务器退出呼叫过程。</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>SIP请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是客户端发给服务器激活一个SIP操作的消息，由一个方法名（Method）、一个请求URI（Request-URI）和一个协议版本 （SIP-Version）组成，三个部分之间以空格（SP）间隔。</span><br><span class=\"line\"></span><br><span class=\"line\">Request-Line  =  Method + SP + Request-URI + SP + SIP-Version + CRLF</span><br><span class=\"line\"></span><br><span class=\"line\">RFC中定义了6中请求：</span><br><span class=\"line\"></span><br><span class=\"line\">INVITE：表明接收用户或服务被邀请加入一个会话；也可以使用这种方式来修改先前建立会话的特性；成功响应（200 OK）表明被叫方愿意参与会话；</span><br><span class=\"line\"></span><br><span class=\"line\">ACK：确认UAC已经接收到了INVITE请求的最终响应（只与INVITE请求一起使用）；用于结束一个200 OK响应；若INVITE请求中不含有会话描述信息，ACK可以包含一个最终会话描述的消息体；</span><br><span class=\"line\"></span><br><span class=\"line\">OPTION：UA用此向UAS查询它的功能；</span><br><span class=\"line\"></span><br><span class=\"line\">BYE：用于终结一个先前建立的会话；</span><br><span class=\"line\"></span><br><span class=\"line\">CANCEL：使UAC和网络服务器取消一个正在进行的请求（如INVITE）；</span><br><span class=\"line\"></span><br><span class=\"line\">REGISTER：客户端注册其目前的位置信息；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SIP响应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器向客户端发送SIP响应，指明客户端先前发送给服务器的SIP请求的状态；由一个协议版本（SIP-Version），一个状态码（Status-Code）和一个原因说明（Reason-Phrase）组成，类似于请求消息，三个部分之间也以空格字符（SP）间隔。</span><br><span class=\"line\"></span><br><span class=\"line\">Status-Line := SIP-Version + SP + Status-Code + SP + Reason-Phrase + CRLF</span><br><span class=\"line\"></span><br><span class=\"line\">状态码是一个100～699之间的3位正整数（具体参见后面附录），它表示对于一个请求消息的响应结果；原因说明是一串可以显示的字符，用于对响应的状态码进行简短说明。</span><br><span class=\"line\"></span><br><span class=\"line\">1xx：临时响应 （Provisional）；之前的请求消息已经收到，并准备接着处理后面的请求消息。</span><br><span class=\"line\"></span><br><span class=\"line\">2xx：成功响应 （Success）； 操作成功，请求消息已被收到并且成功地处理。</span><br><span class=\"line\"></span><br><span class=\"line\">3xx：重定向响应 （Redirection）； 服务器向客户端返回其它可能的位置，客户端应当根据响应中包含的地址信息向另一个服务器重发请求消息。</span><br><span class=\"line\"></span><br><span class=\"line\">4xx： 客户端错误 （Client Error）； 请求由于客户端的错误而失败，客户端可以根据响应状态码修改并重发刚才的请求消息。</span><br><span class=\"line\"></span><br><span class=\"line\">5xx：服务器错误 （Server Error） ；请求由于服务器的错误而失败，客户端可以向另一个服务器重发请求消息。</span><br><span class=\"line\"></span><br><span class=\"line\">6xx：全局错误（Global Failure）； 请求失败，客户端不应该再向任何服务器重发该请求消息。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>标题头</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">遵从HTTP标题头（RFC2616）定义的同样格式：每个标题头由字段名，紧跟着冒号(:)和字段组成。</span><br><span class=\"line\"></span><br><span class=\"line\">主要标题头（详情参见</span><br><span class=\"line\"></span><br><span class=\"line\">SIP常见头域（header）说明</span><br><span class=\"line\"></span><br><span class=\"line\">From：定义请求发起者（通常是发送者AOR），包含SIP或SIP URI和一个可选的显示名字；</span><br><span class=\"line\"></span><br><span class=\"line\">To：定义了请求的接收者（通常是接收者AOR），包含SIP或SIP URI和一个可选的显示名字；因重定向和转移，SIP请求不一定发送给‘希望的’接收者；</span><br><span class=\"line\"></span><br><span class=\"line\">Call-ID：定义了一系列的SIP消息，对所有由对话中的UA发送的所有SIP请求和响应，Call-ID必须唯一；</span><br><span class=\"line\"></span><br><span class=\"line\">Cseq：由一个整数值和一个方式名称组成，在一个对话中标识和序列SIP请求，也区分重传和新消息；</span><br><span class=\"line\"></span><br><span class=\"line\">Via：定义请求路径和响应要发送的地址；</span><br><span class=\"line\"></span><br><span class=\"line\">Contact：定义US希望接收新SIP请求的SIP或SIPS URI（实际地址）；</span><br><span class=\"line\"></span><br><span class=\"line\">Allow：列出产生SIP消息的UA所支持的功能集合；</span><br><span class=\"line\"></span><br><span class=\"line\">Supported：列出所有UA支持的SIP扩展（RFC3262）；</span><br><span class=\"line\"></span><br><span class=\"line\">Require：包含远端UA必须支持的SIP扩展；</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Type：请求或响应的消息体类型；</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Length：请求或响应的消息体的大小（十进制）；</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"SDP协议\"><a href=\"#SDP协议\" class=\"headerlink\" title=\"SDP协议\"></a>SDP协议</h4><p>SDP协议内容(具体可参考国标规范文档)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 v=:Version ，表示协议的版本号</span><br><span class=\"line\">2 o=: Origin,表示源。值域中各项的含义依次是username(用户名)，sess-id(会话ID)，sess-version(会话版本号)，nettype(网络类型)，addrtype(地址类型)，unucast-address(单播地址)。</span><br><span class=\"line\">3 s=:Session Name,表示本sdp所描述的session的名称</span><br><span class=\"line\">4 c=:Connection Data 链接数据。其中值域中以空格分配的两个字段分贝是网络类型和网络地址，以后的RTP流就会发到该地址上。</span><br><span class=\"line\">5 b=:Badwidth type，带宽类型</span><br><span class=\"line\">6 t=:Timing ,起止时间，0表示无限</span><br><span class=\"line\">7 m=:audio Media Type,媒体类型。audio表示音频，50452表示音频端口号，RTP/AVR是传输协议；后面是支持的Codec类型，与RTP流中的PayloadType(载荷类型)相对应，在这里分别是8,0,98和101,8和0分别代表PCMA和PCMU，他们属于静态编码，大于95的编码都属于动态编码，需要在后面使用“a=rtpmap”进行说明。</span><br><span class=\"line\">8 a=: Attributes,属性。 它用于描述上面的音频的属性。如本例中98代表8000hz的ILBC编码，101代表RFC2833dtmf事件。a=sendrecv表示该媒体流可用于收和发，其他的还有sendonly(仅收)，recvonly(仅发)和inactive(不收不发)</span><br><span class=\"line\">9 v=:Video，视频。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"点播流程\"><a href=\"#点播流程\" class=\"headerlink\" title=\"点播流程\"></a>点播流程</h4><p>为了更加熟悉SIP的流程，截取点播流程的流程图。可以看出，SIP传输过程当中都会有SDP的使用。</p>\n<p><img src=\"/images/video/wps2.png\" alt=\"SIP点播流程\"></p>\n<h2 id=\"RTMP-HTTP-HLS-HTTP-FLV\"><a href=\"#RTMP-HTTP-HLS-HTTP-FLV\" class=\"headerlink\" title=\"RTMP/HTTP-HLS/HTTP-FLV\"></a>RTMP/HTTP-HLS/HTTP-FLV</h2><p>RTMP、HTTP-HLS与HTTP-FLV目前市面上比较常用的流媒体协议，都能基于浏览器来观看。</p>\n<ul>\n<li><p>RTMP：实时消息传送协议，基于FLASH播放器的私有协议，默认使用端口 1935。RTMP一般被切割一个个块（chunk）的形式基于TCP协议上传输的明文协议。市面上的摄像头基本都会支持RTMP的形式，而且RTMP一般延时在 1-3s 之间相对延时较低，不过目前来说谷歌禁用了FLASH，可能对RTMP支持可能有所减弱</p>\n</li>\n<li><p>HTTP-HLS：HTTP Live Streaming，苹果公司基于HTTP的流媒体传输协议。工作原理是在服务端将视频流切片成ts小文件形式，通过m3u8索引文件访问ts文件。不过HLS的延迟在10s以上，且文件比较碎片化比较难以保存，但是有利有弊，正因为有ts文件落地，可支持回放等功能。</p>\n</li>\n<li><p>HTTP-FLV：Flash Video，主要是将音视频数据封装成FLV格式，然后通过 HTTP 协议传输给客户端。像B站都是使用该协议进行PC页面播放。FLV延迟比较低。</p>\n</li>\n<li><p>ws-flv：ws-flv直播技术基本与http-flv一致，无非是传输介质换成了websocket协议，除了解除了http-flv不能同时打开过多同域名下的直播窗口的限制，其他技术特性、参数基本与http-flv一致。目前看，ws-flv既适合视频监控(可以同时打开多路监控视频)也适合视频直播行业，是rtmp很高的升级替代方案。</p>\n</li>\n<li>webrtc：webrtc是谷歌主导的视频通话技术标准，目前各大主流浏览器都兼容该标准。通过该技术，用户可以在浏览器上实现无插件的视频通话，该技术也可以用于实现低延时的视频直播。目前业界也有很多基于webrtc的应用和产品，但是很多局限于视频聊天等低延时交互式场景，在视频监控领域，目前还尚未流行。而且该技术栈目前还在持续更新，技术难点太多，要与视频监控领域融合还需时日。</li>\n</ul>\n<h3 id=\"协议介绍-3\"><a href=\"#协议介绍-3\" class=\"headerlink\" title=\"协议介绍\"></a>协议介绍</h3><h4 id=\"RTMP\"><a href=\"#RTMP\" class=\"headerlink\" title=\"RTMP\"></a>RTMP</h4><p><img src=\"/images/video/hls-message.png\" alt=\"RTMP\"></p>\n<p>具体可参考：<a href=\"https://www.jianshu.com/p/d511d59b185c\" target=\"_blank\" rel=\"noopener\">RTMP协议详解</a></p>\n<h4 id=\"HLS\"><a href=\"#HLS\" class=\"headerlink\" title=\"HLS\"></a>HLS</h4><p><a href=\"https://www.jianshu.com/p/d511d59b185c\" target=\"_blank\" rel=\"noopener\">HLS协议详解</a></p>\n<p>以下简单介绍下m3u8的相关内容</p>\n<p><img src=\"/images/video/hls.png\" alt=\"m3u8\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXTM3U：每个M3U文件第一行必须是这个tag，请标示作用</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-MEDIA-SEQUENCE:7</span><br><span class=\"line\">每一个media URI 在 PlayList中只有唯一的序号，相邻之间序号+1, 一个media URI并不是必须要包含的，如果没有，默认为0</span><br><span class=\"line\"></span><br><span class=\"line\">EXTINF:</span><br><span class=\"line\">duration 指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效，title是下载资源的url</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-TARGETDURATION</span><br><span class=\"line\">指定最大的媒体段时间长（秒）。所以#EXTINF中指定的时间长度必须小于或是等于这个最大值。这个tag在整个PlayList文件中只能出现一 次（在嵌套的情况下，一般有真正ts url的m3u8才会出现该tag）</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-KEY</span><br><span class=\"line\">表示怎么对media segments进行解码。其作用范围是下次该tag出现前的所有media URI，属性为NONE 或者 AES-128。NONE表示 URI以及IV（Initialization Vector）属性必须不存在， AES-128(Advanced EncryptionStandard)表示URI必须存在，IV可以不存在。</span><br><span class=\"line\">对于AES-128的情况，keytag和URI属性共同表示了一个key文件，通过URI可以获得这个key，如果没有IV（Initialization Vector）,则使用序列号作为IV进行编解码，将序列号的高位赋到16个字节的buffer中，左边补0；如果有IV，则将改值当成16个字节的16进制数。</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-PROGRAM-DATE-TIME</span><br><span class=\"line\">将一个绝对时间或是日期和一个媒体段中的第一个sample相关联，只对下一个meida URI有效，格式如#EXT-X-PROGRAM-DATE-TIME:</span><br><span class=\"line\">For example: #EXT-X-PROGRAM-DATE-TIME:2010-02-19T14:54:23.031+08:00</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-ALLOW-CACHE</span><br><span class=\"line\">是否允许做cache，这个可以在PlayList文件中任意地方出现，并且最多出现一次，作用效果是所有的媒体段。格式如下：#EXT-X-ALLOW-CACHE:</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-PLAYLIST-TYPE</span><br><span class=\"line\">提供关于PlayList的可变性的信息， 这个对整个PlayList文件有效，是可选的，格式如下：#EXT-X-PLAYLIST-TYPE:：如果是VOD，则服务器不能改变PlayList 文件；如果是EVENT，则服务器不能改变或是删除PlayList文件中的任何部分，但是可以向该文件中增加新的一行内容。</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-ENDLIST</span><br><span class=\"line\">表示PlayList的末尾了，它可以在PlayList中任意位置出现，但是只能出现一个，格式如下：#EXT-X-ENDLIST</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-MEDIA</span><br><span class=\"line\">被用来在PlayList中表示相同内容的不用语种/译文的版本，比如可以通过使用3个这种tag表示3中不用语音的音频，或者用2个这个tag表示不同角度的video在PlayLists中。这个标签是独立存在的，属性包含：</span><br><span class=\"line\">URI：如果没有，则表示这个tag描述的可选择版本在主PlayList的EXT-X-STREAM-INF中存在;</span><br><span class=\"line\">TYPE:AUDIO and VIDEO;</span><br><span class=\"line\">GROUP-ID:具有相同ID的MEDIAtag，组成一组样式；</span><br><span class=\"line\">LANGUAGE：确定使用的主要语言</span><br><span class=\"line\">NAME：人类可读的语言的翻译</span><br><span class=\"line\">DEFAULT：YES或是NO，默认是No，如果是YES，则客户端会以这种选项来播放，除非用户自己进行选择。</span><br><span class=\"line\">AUTOSELECT：YES或是NO，默认是No，如果是YES，则客户端会根据当前播放环境来进行选择（用户没有根据自己偏好进行选择的前提下）。</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-STREAM-INF</span><br><span class=\"line\">指定一个包含多媒体信息的 media URI 作为PlayList，一般做M3U8的嵌套使用，它只对紧跟后面的URI有效，格式如下：#EXT-X-STREAM-INF:有以下属性：</span><br><span class=\"line\">BANDWIDTH：带宽，必须有。</span><br><span class=\"line\">PROGRAM-ID：该值是一个十进制整数，惟一地标识一个在PlayList文件范围内的特定的描述。一个PlayList 文件中可能包含多个有相同ID的此tag。</span><br><span class=\"line\">CODECS：不是必须的。</span><br><span class=\"line\">RESOLUTION：分辨率。</span><br><span class=\"line\">AUDIO：这个值必须和AUDIO类别的“EXT-X-MEDIA”标签中“GROUP-ID”属性值相匹配。</span><br><span class=\"line\">VIDEO：同上</span><br></pre></td></tr></table></figure>\n<h4 id=\"FLV\"><a href=\"#FLV\" class=\"headerlink\" title=\"FLV\"></a>FLV</h4><p><a href=\"https://zhuanlan.zhihu.com/p/287220\" target=\"_blank\" rel=\"noopener\">FLV协议详解</a></p>\n<h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a>性能对比</h3><p><img src=\"/images/video/协议性能对比.png\" alt=\"协议性能对比\"></p>\n<h2 id=\"PES-TS-ES流\"><a href=\"#PES-TS-ES流\" class=\"headerlink\" title=\"PES/TS/ES流\"></a>PES/TS/ES流</h2><p>PES、TS、ES流都是用于封装视频、音频数据的数据流。</p>\n<p>ES流（Elementary Stream）：基本码流，不分段的音频、视频或其他信息的连续码流。</p>\n<p>PES流：把基本流ES分割成段，并加上相应头文件打包成形的打包基本码流。</p>\n<p>PS流（Program Stream）：节目流，将具有共同时间基准的一个或多个PES组合（复合）而成的单一数据流（用于播放或编辑系统，如m2p）。</p>\n<p>TS流（Transport Stream）：传输流，将具有共同时间基准或独立时间基准的一个或多个PES组合（复合）而成的单一数据流（用于数据传输）。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面列了很多我在项目中所有用到过的协议，每种协议都有不同的封装格式以及各自不同属性，个人觉得对于开发者或者使用者来说不一定每种协议都要面面俱到，平常大概知道他们具体作用性能和普遍的属性之类就可以，到真正使用的时候再去深入了解，反而会更高效。以下，我总结下这段时间来对这几个协议的了解：<br>    <img src=\"/images/video/zlm.png\" alt=\"协议\"></p>\n<p>根据上图可以看出，一般来说推流的方式可能会议国标方式或者接入海康、大华等厂商的摄像头来直接推流到流媒体，而从流媒体转码成flv,hls等不同协议供客户端来拉流访问。</p>\n<p>参考</p>\n<ol>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/72917813\" target=\"_blank\" rel=\"noopener\">关于RTSP/RTP/RTCP</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/news/387488\" target=\"_blank\" rel=\"noopener\">会话初始协议SIP与SDP简介</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/48100533\" target=\"_blank\" rel=\"noopener\">RTMP、HTTP-FLV、HLS，你了解常见的三大直播协议吗\n</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h1><p>总结我在流媒体项目中接触到且使用过的所有协议</p>\n<h1 id=\"总体\"><a href=\"#总体\" class=\"headerlink\" title=\"总体\"></a>总体</h1><p><img src=\"/images/video/agreement.png\" alt=\"image\"></p>\n<h2 id=\"TCP-UDP\"><a href=\"#TCP-UDP\" class=\"headerlink\" title=\"TCP/UDP\"></a>TCP/UDP</h2><p>学习流媒体的协议，首当其冲就是学习TCP与UDP的协议，因为基本的协议都是基于这两种协议来传输</p>\n<h2 id=\"RTP与RTCP\"><a href=\"#RTP与RTCP\" class=\"headerlink\" title=\"RTP与RTCP\"></a>RTP与RTCP</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>RTP实时流传输协议，是用于Internet上针对多媒体数据流的一种传输协议。RTP位于传输层，基于UDP之上。RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，服务质量由RTCP来提供。</p>\n<p>RTCP是实时传输控制协议，RTCP收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等，服务器可以利用这些信息动态的改变传输速率，甚至改变净荷的类型。RTCP消息也被封装为UDP数据报进行传输</p>\n<p>一般而言,目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个 给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的 UDP端口＋1），这样就构成一个UDP端口对。 RTP的发送过程如下，接收过程则相反。</p>\n<h3 id=\"协议介绍\"><a href=\"#协议介绍\" class=\"headerlink\" title=\"协议介绍\"></a>协议介绍</h3><h4 id=\"RTP协议结构\"><a href=\"#RTP协议结构\" class=\"headerlink\" title=\"RTP协议结构\"></a>RTP协议结构</h4><p><img src=\"/images/video/RTCP协议.png\" alt=\"RTP协议结构\"></p>\n<p>RTP分组头部的各字段含义为：</p>\n<p>V：RTP版本号。为“10”。</p>\n<p>P：填充指示位。P为“1”时表示分组结尾含有1个或多个填充字节，其中这部分不属于有效载荷。</p>\n<p>X：扩展指示位。X为“1”时，则表示固定头部后还有一个扩展头部，这种情况较复杂，很少使用。</p>\n<p>CC：CSRC计数。指示固定头部后的CSRC的个数</p>\n<p>M：标志。</p>\n<p>PT：负载类型。表示RTP分组的负载类型。我们常用的有</p>\n<table>\n<thead>\n<tr>\n<th>Payload Type</th>\n<th>Codec</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>PCM μ -Law</td>\n</tr>\n<tr>\n<td>8</td>\n<td>PCM-A Law</td>\n</tr>\n<tr>\n<td>9</td>\n<td>G..722 audio codec</td>\n</tr>\n<tr>\n<td>4</td>\n<td>G..723 audio codec</td>\n</tr>\n<tr>\n<td>15</td>\n<td>G..728 audio codec</td>\n</tr>\n<tr>\n<td>18</td>\n<td>G..729 audio codec</td>\n</tr>\n<tr>\n<td>34</td>\n<td>G..763 audio codec</td>\n</tr>\n<tr>\n<td>31</td>\n<td>G..761 audio codec</td>\n</tr>\n</tbody>\n</table>\n<p>序列号：序号顾名思义就是表示RTP分组的次序。初值为随机数，每发送一个增加1。可供接收方检测分组丢失和恢复分组次序。</p>\n<p>时间戳：表示RTP分组第一个字节的取样时刻。其初值为随机数，每个采用周期加1。如果每次传送20ms的数据，由于音频的采样频率为8000Hz，即每20ms有160次采样，则每传送20ms的数据，时戳增加160。</p>\n<p>SSRC：同步源标识(Synchronous Source)。表示信号的同步源，其值应随机选择，以保证同一个RTP会话中任意两个同步源的SSRC标识不同。</p>\n<p>CSRC：分信源(贡献源)标识(Contributing Source)。识别该数据包中的有效载荷的贡献源。换句话说，CSRC标识由混合器插入，其值就是组成复合信号的各个分信号的SSRC标识，用以标识各个组成分信号的信源。RTP分组的头部最多可以包含15个CSRC标识，其数目由CC字段指明。</p>\n<h4 id=\"RTCP协议结构\"><a href=\"#RTCP协议结构\" class=\"headerlink\" title=\"RTCP协议结构\"></a>RTCP协议结构</h4><p><img src=\"/images/video/RTP协议.jpg\" alt=\"RTCP\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">版本（V）：同RTP包头域。</span><br><span class=\"line\"></span><br><span class=\"line\">填充（P）：同RTP包头域。</span><br><span class=\"line\"></span><br><span class=\"line\">接收报告计数器（RC）：5比特，该SR包中的接收报告块的数目，可以为零。</span><br><span class=\"line\"></span><br><span class=\"line\">包类型（PT）：8比特，SR包是200。</span><br><span class=\"line\"></span><br><span class=\"line\">长度域（Length）：16比特，其中存放的是该SR包以32比特为单位的总长度减一。</span><br><span class=\"line\"></span><br><span class=\"line\">同步源（SSRC of sender）：SR包发送者的同步源标识符。与对应RTP包中的SSRC一样。</span><br><span class=\"line\"></span><br><span class=\"line\">NTP Timestamp（Network time protocol）SR包发送时的绝对时间值。NTP的作用是同步不同的RTP媒体流。</span><br><span class=\"line\"></span><br><span class=\"line\">RTP Timestamp：与NTP时间戳对应，与RTP数据包中的RTP时间戳具有相同的单位和随机初始值。</span><br><span class=\"line\"></span><br><span class=\"line\">Sender’s packet count：从开始发送包到产生这个SR包这段时间里，发送者发送的RTP数据包的总数. SSRC改变时，这个域清零。</span><br><span class=\"line\"></span><br><span class=\"line\">Sender`s octet count：从开始发送包到产生这个SR包这段时间里，发送者发送的净荷数据的总字节数（不包括头部和填充）。发送者改变其SSRC时，这个域要清零。</span><br><span class=\"line\"></span><br><span class=\"line\">同步源n的SSRC标识符：该报告块中包含的是从该源接收到的包的统计信息。</span><br><span class=\"line\"></span><br><span class=\"line\">丢失率（Fraction Lost）：表明从上一个SR或RR包发出以来从同步源n(SSRC_n)来的RTP数据包的丢失率。</span><br><span class=\"line\"></span><br><span class=\"line\">累计的包丢失数目：从开始接收到SSRC_n的包到发送SR,从SSRC_n传过来的RTP数据包的丢失总数。</span><br><span class=\"line\"></span><br><span class=\"line\">收到的扩展最大序列号：从SSRC_n收到的RTP数据包中最大的序列号，</span><br><span class=\"line\"></span><br><span class=\"line\">接收抖动（Interarrival jitter）：RTP数据包接受时间的统计方差估计</span><br><span class=\"line\"></span><br><span class=\"line\">上次SR时间戳（Last SR,LSR）：取最近从SSRC_n收到的SR包中的NTP时间戳的中间32比特。如果目前还没收到SR包，则该域清零。</span><br><span class=\"line\"></span><br><span class=\"line\">上次SR以来的延时（Delay since last SR,DLSR）：上次从SSRC_n收到SR包到发送本报告的延时。</span><br></pre></td></tr></table></figure>\n<p>根据所携带的控制信息不同RTCP信息包可分为RR（接收者报告包）、SR（源报告包）、SEDS（源描述包）、BYE（离开申明）和APP（特殊应用包）五类5类：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>缩写表示</th>\n<th>用途</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>SR（Sender Report）</td>\n<td>发送端报告</td>\n<td>发送端报告包，用于发送和接收活动源的统计信息；</td>\n</tr>\n<tr>\n<td>201</td>\n<td>RR（Receiver Report）</td>\n<td>接收端报告</td>\n<td>接收者报告包，用于接收非活动站的统计信息；</td>\n</tr>\n<tr>\n<td>202</td>\n<td>SDES（Source Description Items）</td>\n<td>源点描述</td>\n<td>源描述包，用于报告和站点相关的信息，包括CNAME；</td>\n</tr>\n<tr>\n<td>203</td>\n<td>BYE</td>\n<td>结束传输</td>\n<td>断开RTCP包，是站点离开系统的报告，表示结束；</td>\n</tr>\n<tr>\n<td>204</td>\n<td>APP</td>\n<td>特定应用</td>\n<td>应用特定函数。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"RTSP\"><a href=\"#RTSP\" class=\"headerlink\" title=\"RTSP\"></a>RTSP</h2><p><img src=\"/images/video/RTSP协议.png\" alt=\"image\"></p>\n<h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>实时串流协议（应用层）,TCP/IP协议体系中的一个应用层协议，RTSP位于RTP和RTCP之上，可以基于TCP或者UDP来完成数据传输。RTSP实时性比较，扩展性比较好（UDP,TCP传输数据）。rtsp流主要是控制流媒体的行为动作，提供了诸如暂停，快进等控制，而它本身并不传输流媒体数。</p>\n<h3 id=\"协议介绍-1\"><a href=\"#协议介绍-1\" class=\"headerlink\" title=\"协议介绍\"></a>协议介绍</h3><ol>\n<li>RTSP结构</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtsp://admin:a12345678@47.106.89.193:10000/h264/ch33/main/av_stream</span><br></pre></td></tr></table></figure>\n<p>结构：<br>rtsp://user:pwd@host:port/abs_path/content_name</p>\n<p>user:摄像头设备的登陆用户名</p>\n<p>pwd:摄像头设备的登陆密码</p>\n<p>host:摄像头有效的域名或是IP地址</p>\n<p>port:端口号，对于RTSP协议来说，缺省的端口号为554</p>\n<p>abs_path:媒体流资源标识</p>\n<ol>\n<li>方法定义</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法</th>\n<th>方向</th>\n<th>对象</th>\n<th>要求</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">DESCRIBE</td>\n<td>C-&gt;S</td>\n<td>P，S</td>\n<td>推荐</td>\n<td>检查演示或媒体对象的描述，也允许使用接收头指定用户理解的描述格式。DESCRIBE的答复-响应组成媒体RTSP初始阶段</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ANNOUNCE</td>\n<td>C-&gt;S,S-&gt;C</td>\n<td>P，S</td>\n<td>可选</td>\n<td>当从用户发往服务器时，ANNOUNCE将请求URL识别的演示或媒体对象描述发送给服务器；反之，ANNOUNCE实时更新连接描述。如新媒体流加入演示，整个演示描述再次发送，而不仅仅是附加组件，使组件能被删除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GET_PARAMETER</td>\n<td>C-&gt;S,S-&gt;C</td>\n<td>P，S</td>\n<td>可选</td>\n<td>GET_PARAMETER请求检查URL指定的演示与媒体的参数值。没有实体体时，GET_PARAMETER也许能用来测试用户与服务器的连通情况</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">OPTIONS</td>\n<td>C-&gt;S,S-&gt;C</td>\n<td>P，S</td>\n<td>要求</td>\n<td>可在任意时刻发出OPTIONS请求，如用户打算尝试非标准请求，并不影响服务器状态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PAUSE</td>\n<td>C-&gt;S</td>\n<td>P，S</td>\n<td>推荐</td>\n<td>PAUSE请求引起流发送临时中断。如请求URL命名一个流，仅回放和记录被停止；如请求URL命名一个演示或流组，演示或组中所有当前活动的流发送都停止。恢复回放或记录后，必须维持同步。在SETUP消息中连接头超时参数所指定时段期间被暂停后，尽管服务器可能关闭连接并释放资源，但服务器资源会被预订</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PLAY</td>\n<td>C-&gt;S</td>\n<td>P，S</td>\n<td>要求</td>\n<td>PLAY告诉服务器以SETUP指定的机制开始发送数据；直到一些SETUP请求被成功响应，客户端才可发布PLAY请求。PLAY请求将正常播放时间设置在所指定范围的起始处，发送流数据直到范围的结束处。PLAY请求可排成队列，服务器将PLAY请求排成队列，顺序执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RECORD</td>\n<td>C-&gt;S</td>\n<td>P，S</td>\n<td>可选</td>\n<td>该方法根据演示描述初始化媒体数据记录范围，时标反映开始和结束时间；如没有给出时间范围，使用演示描述提供的开始和结束时间。如连接已经启动，立即开始记录，服务器数据请求URL或其他URL决定是否存储记录的数据；如服务器没有使用URL请求，响应应为201（创建），并包含描述请求状态和参考新资源的实体与位置头。支持现场演示记录的媒体服务器必须支持时钟范围格式，smpte格式没有意义</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">REDIRECT</td>\n<td>S-&gt;C</td>\n<td>P，S</td>\n<td>可选</td>\n<td>重定向请求通知客户端连接到另一服务器地址。它包含强制头地址，指示客户端发布URL请求；也可能包括参数范围，以指明重定向何时生效。若客户端要继续发送或接收URL媒体，客户端必须对当前连接发送TEARDOWN请求，而对指定主执新连接发送SETUP请求</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SETUP</td>\n<td>C-&gt;S</td>\n<td>S</td>\n<td>要求</td>\n<td>对URL的SETUP请求指定用于流媒体的传输机制。客户端对正播放的流发布一个SETUP请求，以改变服务器允许的传输参数。如不允许这样做，响应错误为”455 Method Not Valid In This State”。为了透过防火墙，客户端必须指明传输参数，即使对这些参数没有影响</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SET_PARAMETER</td>\n<td>C-&gt;S,S-&gt;C</td>\n<td>P，S</td>\n<td>可选</td>\n<td>这个方法请求设置演示或URL指定流的参数值。请求仅应包含单个参数，允许客户端决定某个特殊请求为何失败。如请求包含多个参数，所有参数可成功设置，服务器必须只对该请求起作用。服务器必须允许参数可重复设置成同一值，但不让改变参数值。注意：媒体流传输参数必须用SETUP命令设置。将设置传输参数限制为SETUP有利于防火墙。将参数划分成规则排列形式，结果有更多有意义的错误指示</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TEARDOWN</td>\n<td>C-&gt;S</td>\n<td>S</td>\n<td>要求</td>\n<td>TEARDOWN请求停止给定URL流发送，释放相关资源。如URL是此演示URL，任何RTSP连接标识不再有效。除非全部传输参数是连接描述定义的，SETUP请求必须在连接可再次播放前发布</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>交互流程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C表示RTSP客户端,S表示RTSP服务端</span><br><span class=\"line\"></span><br><span class=\"line\">1. 第一步：查询服务器端可用方法</span><br><span class=\"line\">1.C-&gt;S:OPTION request //询问S有哪些方法可用</span><br><span class=\"line\"></span><br><span class=\"line\">1.S-&gt;C:OPTION response //S回应信息的public头字段中包括提供的所有可用方法</span><br><span class=\"line\"></span><br><span class=\"line\">2. 第二步：得到媒体描述信息</span><br><span class=\"line\">2.C-&gt;S:DESCRIBE request //要求得到S提供的媒体描述信息</span><br><span class=\"line\"></span><br><span class=\"line\">2.S-&gt;C:DESCRIBE response //S回应媒体描述信息，一般是sdp信息</span><br><span class=\"line\"></span><br><span class=\"line\">3. 第三步：建立RTSP会话</span><br><span class=\"line\">3.C-&gt;S:SETUP request //通过Transport头字段列出可接受的传输选项，请求S建立会话</span><br><span class=\"line\"></span><br><span class=\"line\">3.S-&gt;C:SETUP response //S建立会话，通过Transport头字段返回选择的具体转输选项，并返回建立的Session ID;</span><br><span class=\"line\"></span><br><span class=\"line\">4. 第四步：请求开始传送数据</span><br><span class=\"line\">4.C-&gt;S:PLAY request //C请求S开始发送数据</span><br><span class=\"line\"></span><br><span class=\"line\">4.S-&gt;C:PLAY response //S回应该请求的信息</span><br><span class=\"line\"></span><br><span class=\"line\">5. 第五步： 数据传送播放中</span><br><span class=\"line\">S-&gt;C:发送流媒体数据 // 通过RTP协议传送数据</span><br><span class=\"line\"></span><br><span class=\"line\">6. 第六步：关闭会话，退出</span><br><span class=\"line\">6.C-&gt;S:TEARDOWN request //C请求关闭会话</span><br><span class=\"line\"></span><br><span class=\"line\">6.S-&gt;C:TEARDOWN response //S回应该请求</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>RTSP与HTTP区别</p>\n</li>\n</ol>\n<ul>\n<li>RTSP中客户端和服务器都可以发出请求,HTTP只能客户端发起请求；</li>\n<li>RTSP相比HTTP提供多种方法定义</li>\n<li>RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据</li>\n</ul>\n<h2 id=\"SDP-SIP\"><a href=\"#SDP-SIP\" class=\"headerlink\" title=\"SDP/SIP\"></a>SDP/SIP</h2><h3 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>SIP与SDP这两个协议会在国标视频上会出现比较多。其中一般会与RTSP等协议共同</p>\n<p>SIP它是一个基于文本的应用层控制协议，独立于底层传输协议，用于建立、修改和终止IP网络上的双方或多方多媒体会话</p>\n<p>SDP（Session Description Protocol）是一个用来描述多媒体会话的应用层控制协议，它是一个基于文本的协议，用于会话建立过程中的媒体类型和编码方案的协商等</p>\n<h3 id=\"协议介绍-2\"><a href=\"#协议介绍-2\" class=\"headerlink\" title=\"协议介绍\"></a>协议介绍</h3><h4 id=\"SIP介绍\"><a href=\"#SIP介绍\" class=\"headerlink\" title=\"SIP介绍\"></a>SIP介绍</h4><ol>\n<li>SIP 角色</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>角色</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用户代理（UA）</td>\n<td>用户代理客户端（UAC）和用户代理服务器（UAS）组成，UAC负责发起呼叫，UAS负责接收呼叫并作出响应</td>\n</tr>\n<tr>\n<td>代理服务器（PS）</td>\n<td>通过它把来自用户代理客户端（UAC）的请求转发到用户代理服务端（UAS），并把UAS的响应消息转发回UAC</td>\n</tr>\n<tr>\n<td>注册服务器（register server）</td>\n<td>是具有接收注册请求、将请求中携带的信息进行保存并提供本域内位置服务的功能服务器</td>\n</tr>\n<tr>\n<td>重定向服务器（redirect server）</td>\n<td>负责规划SIP呼叫路由。它将获得的呼叫下一跳地址信息告诉呼叫方，以使呼叫方根据此地址直接向下一跳发出请求，此后重定向服务器退出呼叫过程。</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>SIP请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是客户端发给服务器激活一个SIP操作的消息，由一个方法名（Method）、一个请求URI（Request-URI）和一个协议版本 （SIP-Version）组成，三个部分之间以空格（SP）间隔。</span><br><span class=\"line\"></span><br><span class=\"line\">Request-Line  =  Method + SP + Request-URI + SP + SIP-Version + CRLF</span><br><span class=\"line\"></span><br><span class=\"line\">RFC中定义了6中请求：</span><br><span class=\"line\"></span><br><span class=\"line\">INVITE：表明接收用户或服务被邀请加入一个会话；也可以使用这种方式来修改先前建立会话的特性；成功响应（200 OK）表明被叫方愿意参与会话；</span><br><span class=\"line\"></span><br><span class=\"line\">ACK：确认UAC已经接收到了INVITE请求的最终响应（只与INVITE请求一起使用）；用于结束一个200 OK响应；若INVITE请求中不含有会话描述信息，ACK可以包含一个最终会话描述的消息体；</span><br><span class=\"line\"></span><br><span class=\"line\">OPTION：UA用此向UAS查询它的功能；</span><br><span class=\"line\"></span><br><span class=\"line\">BYE：用于终结一个先前建立的会话；</span><br><span class=\"line\"></span><br><span class=\"line\">CANCEL：使UAC和网络服务器取消一个正在进行的请求（如INVITE）；</span><br><span class=\"line\"></span><br><span class=\"line\">REGISTER：客户端注册其目前的位置信息；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SIP响应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器向客户端发送SIP响应，指明客户端先前发送给服务器的SIP请求的状态；由一个协议版本（SIP-Version），一个状态码（Status-Code）和一个原因说明（Reason-Phrase）组成，类似于请求消息，三个部分之间也以空格字符（SP）间隔。</span><br><span class=\"line\"></span><br><span class=\"line\">Status-Line := SIP-Version + SP + Status-Code + SP + Reason-Phrase + CRLF</span><br><span class=\"line\"></span><br><span class=\"line\">状态码是一个100～699之间的3位正整数（具体参见后面附录），它表示对于一个请求消息的响应结果；原因说明是一串可以显示的字符，用于对响应的状态码进行简短说明。</span><br><span class=\"line\"></span><br><span class=\"line\">1xx：临时响应 （Provisional）；之前的请求消息已经收到，并准备接着处理后面的请求消息。</span><br><span class=\"line\"></span><br><span class=\"line\">2xx：成功响应 （Success）； 操作成功，请求消息已被收到并且成功地处理。</span><br><span class=\"line\"></span><br><span class=\"line\">3xx：重定向响应 （Redirection）； 服务器向客户端返回其它可能的位置，客户端应当根据响应中包含的地址信息向另一个服务器重发请求消息。</span><br><span class=\"line\"></span><br><span class=\"line\">4xx： 客户端错误 （Client Error）； 请求由于客户端的错误而失败，客户端可以根据响应状态码修改并重发刚才的请求消息。</span><br><span class=\"line\"></span><br><span class=\"line\">5xx：服务器错误 （Server Error） ；请求由于服务器的错误而失败，客户端可以向另一个服务器重发请求消息。</span><br><span class=\"line\"></span><br><span class=\"line\">6xx：全局错误（Global Failure）； 请求失败，客户端不应该再向任何服务器重发该请求消息。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>标题头</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">遵从HTTP标题头（RFC2616）定义的同样格式：每个标题头由字段名，紧跟着冒号(:)和字段组成。</span><br><span class=\"line\"></span><br><span class=\"line\">主要标题头（详情参见</span><br><span class=\"line\"></span><br><span class=\"line\">SIP常见头域（header）说明</span><br><span class=\"line\"></span><br><span class=\"line\">From：定义请求发起者（通常是发送者AOR），包含SIP或SIP URI和一个可选的显示名字；</span><br><span class=\"line\"></span><br><span class=\"line\">To：定义了请求的接收者（通常是接收者AOR），包含SIP或SIP URI和一个可选的显示名字；因重定向和转移，SIP请求不一定发送给‘希望的’接收者；</span><br><span class=\"line\"></span><br><span class=\"line\">Call-ID：定义了一系列的SIP消息，对所有由对话中的UA发送的所有SIP请求和响应，Call-ID必须唯一；</span><br><span class=\"line\"></span><br><span class=\"line\">Cseq：由一个整数值和一个方式名称组成，在一个对话中标识和序列SIP请求，也区分重传和新消息；</span><br><span class=\"line\"></span><br><span class=\"line\">Via：定义请求路径和响应要发送的地址；</span><br><span class=\"line\"></span><br><span class=\"line\">Contact：定义US希望接收新SIP请求的SIP或SIPS URI（实际地址）；</span><br><span class=\"line\"></span><br><span class=\"line\">Allow：列出产生SIP消息的UA所支持的功能集合；</span><br><span class=\"line\"></span><br><span class=\"line\">Supported：列出所有UA支持的SIP扩展（RFC3262）；</span><br><span class=\"line\"></span><br><span class=\"line\">Require：包含远端UA必须支持的SIP扩展；</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Type：请求或响应的消息体类型；</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Length：请求或响应的消息体的大小（十进制）；</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"SDP协议\"><a href=\"#SDP协议\" class=\"headerlink\" title=\"SDP协议\"></a>SDP协议</h4><p>SDP协议内容(具体可参考国标规范文档)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 v=:Version ，表示协议的版本号</span><br><span class=\"line\">2 o=: Origin,表示源。值域中各项的含义依次是username(用户名)，sess-id(会话ID)，sess-version(会话版本号)，nettype(网络类型)，addrtype(地址类型)，unucast-address(单播地址)。</span><br><span class=\"line\">3 s=:Session Name,表示本sdp所描述的session的名称</span><br><span class=\"line\">4 c=:Connection Data 链接数据。其中值域中以空格分配的两个字段分贝是网络类型和网络地址，以后的RTP流就会发到该地址上。</span><br><span class=\"line\">5 b=:Badwidth type，带宽类型</span><br><span class=\"line\">6 t=:Timing ,起止时间，0表示无限</span><br><span class=\"line\">7 m=:audio Media Type,媒体类型。audio表示音频，50452表示音频端口号，RTP/AVR是传输协议；后面是支持的Codec类型，与RTP流中的PayloadType(载荷类型)相对应，在这里分别是8,0,98和101,8和0分别代表PCMA和PCMU，他们属于静态编码，大于95的编码都属于动态编码，需要在后面使用“a=rtpmap”进行说明。</span><br><span class=\"line\">8 a=: Attributes,属性。 它用于描述上面的音频的属性。如本例中98代表8000hz的ILBC编码，101代表RFC2833dtmf事件。a=sendrecv表示该媒体流可用于收和发，其他的还有sendonly(仅收)，recvonly(仅发)和inactive(不收不发)</span><br><span class=\"line\">9 v=:Video，视频。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"点播流程\"><a href=\"#点播流程\" class=\"headerlink\" title=\"点播流程\"></a>点播流程</h4><p>为了更加熟悉SIP的流程，截取点播流程的流程图。可以看出，SIP传输过程当中都会有SDP的使用。</p>\n<p><img src=\"/images/video/wps2.png\" alt=\"SIP点播流程\"></p>\n<h2 id=\"RTMP-HTTP-HLS-HTTP-FLV\"><a href=\"#RTMP-HTTP-HLS-HTTP-FLV\" class=\"headerlink\" title=\"RTMP/HTTP-HLS/HTTP-FLV\"></a>RTMP/HTTP-HLS/HTTP-FLV</h2><p>RTMP、HTTP-HLS与HTTP-FLV目前市面上比较常用的流媒体协议，都能基于浏览器来观看。</p>\n<ul>\n<li><p>RTMP：实时消息传送协议，基于FLASH播放器的私有协议，默认使用端口 1935。RTMP一般被切割一个个块（chunk）的形式基于TCP协议上传输的明文协议。市面上的摄像头基本都会支持RTMP的形式，而且RTMP一般延时在 1-3s 之间相对延时较低，不过目前来说谷歌禁用了FLASH，可能对RTMP支持可能有所减弱</p>\n</li>\n<li><p>HTTP-HLS：HTTP Live Streaming，苹果公司基于HTTP的流媒体传输协议。工作原理是在服务端将视频流切片成ts小文件形式，通过m3u8索引文件访问ts文件。不过HLS的延迟在10s以上，且文件比较碎片化比较难以保存，但是有利有弊，正因为有ts文件落地，可支持回放等功能。</p>\n</li>\n<li><p>HTTP-FLV：Flash Video，主要是将音视频数据封装成FLV格式，然后通过 HTTP 协议传输给客户端。像B站都是使用该协议进行PC页面播放。FLV延迟比较低。</p>\n</li>\n<li><p>ws-flv：ws-flv直播技术基本与http-flv一致，无非是传输介质换成了websocket协议，除了解除了http-flv不能同时打开过多同域名下的直播窗口的限制，其他技术特性、参数基本与http-flv一致。目前看，ws-flv既适合视频监控(可以同时打开多路监控视频)也适合视频直播行业，是rtmp很高的升级替代方案。</p>\n</li>\n<li>webrtc：webrtc是谷歌主导的视频通话技术标准，目前各大主流浏览器都兼容该标准。通过该技术，用户可以在浏览器上实现无插件的视频通话，该技术也可以用于实现低延时的视频直播。目前业界也有很多基于webrtc的应用和产品，但是很多局限于视频聊天等低延时交互式场景，在视频监控领域，目前还尚未流行。而且该技术栈目前还在持续更新，技术难点太多，要与视频监控领域融合还需时日。</li>\n</ul>\n<h3 id=\"协议介绍-3\"><a href=\"#协议介绍-3\" class=\"headerlink\" title=\"协议介绍\"></a>协议介绍</h3><h4 id=\"RTMP\"><a href=\"#RTMP\" class=\"headerlink\" title=\"RTMP\"></a>RTMP</h4><p><img src=\"/images/video/hls-message.png\" alt=\"RTMP\"></p>\n<p>具体可参考：<a href=\"https://www.jianshu.com/p/d511d59b185c\" target=\"_blank\" rel=\"noopener\">RTMP协议详解</a></p>\n<h4 id=\"HLS\"><a href=\"#HLS\" class=\"headerlink\" title=\"HLS\"></a>HLS</h4><p><a href=\"https://www.jianshu.com/p/d511d59b185c\" target=\"_blank\" rel=\"noopener\">HLS协议详解</a></p>\n<p>以下简单介绍下m3u8的相关内容</p>\n<p><img src=\"/images/video/hls.png\" alt=\"m3u8\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXTM3U：每个M3U文件第一行必须是这个tag，请标示作用</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-MEDIA-SEQUENCE:7</span><br><span class=\"line\">每一个media URI 在 PlayList中只有唯一的序号，相邻之间序号+1, 一个media URI并不是必须要包含的，如果没有，默认为0</span><br><span class=\"line\"></span><br><span class=\"line\">EXTINF:</span><br><span class=\"line\">duration 指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效，title是下载资源的url</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-TARGETDURATION</span><br><span class=\"line\">指定最大的媒体段时间长（秒）。所以#EXTINF中指定的时间长度必须小于或是等于这个最大值。这个tag在整个PlayList文件中只能出现一 次（在嵌套的情况下，一般有真正ts url的m3u8才会出现该tag）</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-KEY</span><br><span class=\"line\">表示怎么对media segments进行解码。其作用范围是下次该tag出现前的所有media URI，属性为NONE 或者 AES-128。NONE表示 URI以及IV（Initialization Vector）属性必须不存在， AES-128(Advanced EncryptionStandard)表示URI必须存在，IV可以不存在。</span><br><span class=\"line\">对于AES-128的情况，keytag和URI属性共同表示了一个key文件，通过URI可以获得这个key，如果没有IV（Initialization Vector）,则使用序列号作为IV进行编解码，将序列号的高位赋到16个字节的buffer中，左边补0；如果有IV，则将改值当成16个字节的16进制数。</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-PROGRAM-DATE-TIME</span><br><span class=\"line\">将一个绝对时间或是日期和一个媒体段中的第一个sample相关联，只对下一个meida URI有效，格式如#EXT-X-PROGRAM-DATE-TIME:</span><br><span class=\"line\">For example: #EXT-X-PROGRAM-DATE-TIME:2010-02-19T14:54:23.031+08:00</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-ALLOW-CACHE</span><br><span class=\"line\">是否允许做cache，这个可以在PlayList文件中任意地方出现，并且最多出现一次，作用效果是所有的媒体段。格式如下：#EXT-X-ALLOW-CACHE:</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-PLAYLIST-TYPE</span><br><span class=\"line\">提供关于PlayList的可变性的信息， 这个对整个PlayList文件有效，是可选的，格式如下：#EXT-X-PLAYLIST-TYPE:：如果是VOD，则服务器不能改变PlayList 文件；如果是EVENT，则服务器不能改变或是删除PlayList文件中的任何部分，但是可以向该文件中增加新的一行内容。</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-ENDLIST</span><br><span class=\"line\">表示PlayList的末尾了，它可以在PlayList中任意位置出现，但是只能出现一个，格式如下：#EXT-X-ENDLIST</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-MEDIA</span><br><span class=\"line\">被用来在PlayList中表示相同内容的不用语种/译文的版本，比如可以通过使用3个这种tag表示3中不用语音的音频，或者用2个这个tag表示不同角度的video在PlayLists中。这个标签是独立存在的，属性包含：</span><br><span class=\"line\">URI：如果没有，则表示这个tag描述的可选择版本在主PlayList的EXT-X-STREAM-INF中存在;</span><br><span class=\"line\">TYPE:AUDIO and VIDEO;</span><br><span class=\"line\">GROUP-ID:具有相同ID的MEDIAtag，组成一组样式；</span><br><span class=\"line\">LANGUAGE：确定使用的主要语言</span><br><span class=\"line\">NAME：人类可读的语言的翻译</span><br><span class=\"line\">DEFAULT：YES或是NO，默认是No，如果是YES，则客户端会以这种选项来播放，除非用户自己进行选择。</span><br><span class=\"line\">AUTOSELECT：YES或是NO，默认是No，如果是YES，则客户端会根据当前播放环境来进行选择（用户没有根据自己偏好进行选择的前提下）。</span><br><span class=\"line\"></span><br><span class=\"line\">EXT-X-STREAM-INF</span><br><span class=\"line\">指定一个包含多媒体信息的 media URI 作为PlayList，一般做M3U8的嵌套使用，它只对紧跟后面的URI有效，格式如下：#EXT-X-STREAM-INF:有以下属性：</span><br><span class=\"line\">BANDWIDTH：带宽，必须有。</span><br><span class=\"line\">PROGRAM-ID：该值是一个十进制整数，惟一地标识一个在PlayList文件范围内的特定的描述。一个PlayList 文件中可能包含多个有相同ID的此tag。</span><br><span class=\"line\">CODECS：不是必须的。</span><br><span class=\"line\">RESOLUTION：分辨率。</span><br><span class=\"line\">AUDIO：这个值必须和AUDIO类别的“EXT-X-MEDIA”标签中“GROUP-ID”属性值相匹配。</span><br><span class=\"line\">VIDEO：同上</span><br></pre></td></tr></table></figure>\n<h4 id=\"FLV\"><a href=\"#FLV\" class=\"headerlink\" title=\"FLV\"></a>FLV</h4><p><a href=\"https://zhuanlan.zhihu.com/p/287220\" target=\"_blank\" rel=\"noopener\">FLV协议详解</a></p>\n<h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a>性能对比</h3><p><img src=\"/images/video/协议性能对比.png\" alt=\"协议性能对比\"></p>\n<h2 id=\"PES-TS-ES流\"><a href=\"#PES-TS-ES流\" class=\"headerlink\" title=\"PES/TS/ES流\"></a>PES/TS/ES流</h2><p>PES、TS、ES流都是用于封装视频、音频数据的数据流。</p>\n<p>ES流（Elementary Stream）：基本码流，不分段的音频、视频或其他信息的连续码流。</p>\n<p>PES流：把基本流ES分割成段，并加上相应头文件打包成形的打包基本码流。</p>\n<p>PS流（Program Stream）：节目流，将具有共同时间基准的一个或多个PES组合（复合）而成的单一数据流（用于播放或编辑系统，如m2p）。</p>\n<p>TS流（Transport Stream）：传输流，将具有共同时间基准或独立时间基准的一个或多个PES组合（复合）而成的单一数据流（用于数据传输）。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面列了很多我在项目中所有用到过的协议，每种协议都有不同的封装格式以及各自不同属性，个人觉得对于开发者或者使用者来说不一定每种协议都要面面俱到，平常大概知道他们具体作用性能和普遍的属性之类就可以，到真正使用的时候再去深入了解，反而会更高效。以下，我总结下这段时间来对这几个协议的了解：<br>    <img src=\"/images/video/zlm.png\" alt=\"协议\"></p>\n<p>根据上图可以看出，一般来说推流的方式可能会议国标方式或者接入海康、大华等厂商的摄像头来直接推流到流媒体，而从流媒体转码成flv,hls等不同协议供客户端来拉流访问。</p>\n<p>参考</p>\n<ol>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/72917813\" target=\"_blank\" rel=\"noopener\">关于RTSP/RTP/RTCP</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/news/387488\" target=\"_blank\" rel=\"noopener\">会话初始协议SIP与SDP简介</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/48100533\" target=\"_blank\" rel=\"noopener\">RTMP、HTTP-FLV、HLS，你了解常见的三大直播协议吗\n</a></p>\n</li>\n</ol>\n"},{"title":"流媒体基础知识点","date":"2021-07-26T03:16:39.000Z","_content":"\n# 目的\n\n学习流媒体之前，应该要首先知道流媒体相关基础知识点，这样能够更好地掌握流媒体\n\n## 概念\n流媒体是什么？按照我个人理解就是将音视频数据转化成能够在互联网进行播放的一种流式技术。\n\n## 知识点\n\n### 文件格式\n\n操作系统的扩展名，常用的视频保存格式有：mp4、avi、mpg等\n\n### 封装格式\n\n封装格式（Format），也称多媒体容器（Multimedia Container），是将已编码压缩好的视频轨道、音频轨道和元数据（视频基本信息如标题、字幕等）按照一定的格式规范，打包放到一个文件中，形成特定文件格式的视频文件。\n\n### 编解码\n\n硬编解码：通过硬件实现编解码，减轻CPU计算的负担，如GPU等\n\n软编解码：如 H264、H265、MPEG-4等编解码算法，更消耗CPU\n\n\n### 编码格式\n\n视频编码方式将视频数据进行压缩或者解压。一般来说压缩技术都会有损数据的\n\n视频编码格式：\n1. H.26X系列：\n    -   H261：主要在老的视频会议和视频电话产品中使用。\n    -   H263：主要用在视频会议、视频电话和网络视频上。\n    -   H264：视频压缩技术，比较普及和广发使用，在媒体项目中也是会经常接触，目前市面上多数的流媒体服务都支持H264编码的视频\n    -   H265：高效视频压缩技术，同比H264来说压缩效率提高了50%（同画面质量的情况下），而且还支持4K/8K的视频效果，未来会是趋势。但是目前市面上普遍的播放器支持度并不高，flv协议则不支持H265的格式编码的视频。\n1. MPEG系列\n    - MPEG-1第二部分：主要使用在VCD上，有些在线视频也使用这种格式，该编解码器的质量大致上和原有的VHS录像带相当。\n    - MPEG-2第二部分：等同于H.262，使用在DVD、SVCD和大多数数字视频广播系统和有线分布系统（Cable Distribution Systems）中。\n    - MPEG-4第二部分：可以使用在网络传输、广播和媒体存储上，比起MPEG-2和第一版的H.263，它的压缩性能有所提高。\n    -   MPEG-4第十部分：技术上和ITU-TH.264是相同的标准，二者合作，诞生了H.264/AVC标准，ITU-T将其命名为H.264，而ISO/IEC称它为MPEG-4高级视频编码（Advanced Video Coding，AVC）。\n1. AVS：我国自主知识产权的信源编码标准\n\n音频编码格式：\n1. AAC：ACC是MPEG-4中的音频标准（常见）\n1. AMR\n1. PCM\n1. ogg(ogg vorbis音频)\n1. AC3(DVD 专用音频编码)\n1. DTS(DVD 专用音频编码)\n1. APE(monkey’s 音频)\n1. AU(sun 格式)\n1. WMA\n\n\n音频编码方案之间音质比较（AAC，MP3，WMA等）结果： AAC+ > MP3PRO > AAC> RealAudio > WMA > MP3\n\n### 转码\n\n视频转码（Video Transcoding）是指将已经压缩编码的视频码流转换成另一个视频码流\n\n### 转封装\n\n转封装指的是将视频或音频的封装格式进行转换，如将AVI的视频转换为MP4，其间并不会进行音视频的编码和解码工作，而是直接将视频和音频压缩码流从一种封装格式文件中获取出来然后打包成另一种封装格式的文件。相比转码，转封装有两大特点：\n\n    处理速度极快。音视频编解码过程十分复杂，占据了转码的绝大部分时间。转封装不需要进行编码和解码，节约了大量的处理时间。\n\n    音视频质量无损。没有解码（解压缩）和编码（压缩）过程，所以不会有音视频的压缩损伤。\n转封装后的文件与原始文件的分辨率、码率等几乎一致，故播放时也称其为“原画”。\n\n### 码流与码率\n码率（Bitrate）是指视频文件在单位时间内使用的数据流量，也叫码流或码流率，是视频编码中画面质量控制最重要的部分。量度单位为“比特每秒”（bit/s或bps），常使用Kbps（每秒多少千个比特）或Mbps。一般来说同样分辨率下，视频文件的码率越大，压缩比就越小，画面质量就越高。码率越大，说明单位时间内取样率越大，数据流精度就越高，处理出来的文件就越接近原始文件，图像质量越好，画质越清晰，要求播放设备的解码能力也越高。\n\n    当然，码率越大，文件体积也越大，其计算公式是文件体积=时间X码率/8。例如，网络上常见的一部60分钟的码率为1Mbps的720P的视频文件，其体积就大概为3600秒×1Mb/8=450MB。\n    \n### 分辨率\n\n视频分辨率是指视频成像产品所成图像的大小或尺寸。分辨率决定了视频画面细节的精细程度。通常情况下，视频的分辨率越高，所包含的像素就越多，画面就越清晰。\n\n480P : 640 x 480 个像素点\n\n720P : 1280 x 720 个像素点\n\n1080P : 1920 x 1080 个像素点\n\n    分辨率是决定码率的主要因素，不同的分辨率要采用不同的码率。总体而言，视频的分辨率越高，所要求的码率也越大，但并不总是如此，不同分辨率都有合理的码率选择范围。\n    所谓“合理的范围”指的是，如果低于这个范围，视频画面质量会很差；如果高于这个范围，画面提升有限甚至几乎无提升，且浪费网络流量和存储空间。 \n\n\n### 帧率\n帧率（Frame Rate）是单位时间内视频显示帧数的量度单位，也就是每秒钟刷新的图片的帧数，量度单位为“每秒显示帧数”（Frame Per Second，FPS）或“赫兹”\n\n关于帧率有如下几个基础数据：\n\n- 帧率越高，cpu消耗就高\n- 秀场视频直播，一般帧率20fps\n- 普通视频直播，一般帧率15fps\n\n\n### GOP（关键帧间隔）\n\nGOP（Group of Pictures）是一组以 MPEG 编码的影片或视讯串流内部的连续图像，以 I 帧开头，到下一个 I 帧结束\n\n\n- I 帧(Intra Coded Picture)：又称帧内编码帧，为关键帧，是一种自带全部信息的独立帧，无需参考其他图像便可独立进行解码，可以简单理解为一张静态画面。视频序列中的第一个帧始终都是I 帧，每个 GOP 由I 帧开始。\n- P 帧(Predictive Coded Picture)：又称帧间预测编码帧，需要参考前面的I帧才能进行编码。表示的是当前帧画面与前一帧（前一帧可能是I帧也可能是P帧）的差别。解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。与I帧相比，P帧通常占用更少的数据位，但不足是，由于P帧对前面的P和I参考帧有着复杂的依赖性，因此对传输错误非常敏感\n- B 帧(Bidirectionally Predictive Coded Pictures)：又称双向预测编码帧，也就是B帧记录的是本帧与前后帧的差别。也就是说要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是对解码性能要求较高。\n\nGOP值表示关键帧的间隔(即两个关键帧之间的帧数)，也就是两个IDR帧之间的距离，一个帧组的最大帧数。一般而言，每一秒视频至少需要使用 1 个关键帧。增加关键帧个数可改善视频质量，但会同时增加带宽和网络负载。GOP值（帧数）除以帧率即为时间间隔，如阿里云视频点播默认的GOP值为250帧，帧率为25fps，则时间间隔为10秒。\n\nGOP值需要控制在合理范围，以平衡视频质量、文件大小（网络带宽）和seek效果（拖动、快进的响应速度）等：\n\n```\n1.加大GOP值有利于减小视频文件大小，但也不宜设置过大，太大则会导致GOP后部帧的画面失真，影响视频质量。\n\n2.GOP值也是影响视频seek响应速度的关键因素，seek时播放器需要定位到离指定位置最近的前一个关键帧，如果GOP太大意味着距离指定位置可能越远（需要解码的预测帧就越多）、seek响应的时间（缓冲时间）也越长。\n\n3.由于P、B帧的复杂度大于I帧，GOP值过大，过多的P、B帧会影响编码效率，使编码效率降低。\n\n4.但如果设置过小的GOP值，则需要提高视频的输出码率，以确保画面质量不会降低，故会增加网络带宽。\n```\n\n### IDR 帧对齐\nIDR帧（Instantaneous Decoding Refresh Picture），即时解码刷新帧，是 I 帧的一种。与普通 I 帧的区别在于，一个 IDR 帧之后的所有帧都不能引用该 IDR 帧之前的帧的内容；相反，对于普通的 I 帧，其后的 P 帧和 B 帧可以引用该普通 I 帧之前的其他 I 帧。在编码和解码中为了方便，将首个I帧和其他I帧区别开，称为IDR，这样就方便控制编码和解码流程\n\n### 图像存储格式yuv\n\nYUV格式，与我们熟知的RGB类似，YUV也是一种颜色编码方法。YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。\n\nYUV与RGB相比：\nYUV是利用一个亮度（Y）、两个色差(U,V)来代替传统的RGB三原色来压缩图像。传统的RGB三原色使用红绿蓝三原色表示一个像素，每种原色占用一个字节（8bit），因此一个像素用RGB表示则需要8 * 3=24bit。\n\n\n\n## 总结\n\n1.码率与分辨率有关系，分辨率决定码率的主要因素，跟帧率没关，帧率关系着画面流畅度和cpu消耗\n\n2.I帧可以看作一张完整的画面，P帧需要与缓存之前画面生成图像，而B帧则就需要记录前后画面画面生成图像。一般来说网络上的电影都会使用B帧，因为压缩率高，带宽消耗相对比较低。压缩率一般是 I帧（7）< P帧（20） < B帧（50）\n\n3.一般来说，硬编码相比一般性能高，效率高，但移植和实现都比较困难，而软编码则实现简单，但性能相比就低一点。\n\n> PS:\n在项目遇到过一次坑就是关于视频YUV的问题，由于海康和大华的颜色编码不是相同，海康设备使用了YV12格式，而大华使用了YUV420格式，但是程序统一使用了YUV420，因此海康的画面出现了色差问题。\n\n# 参考\n[音视频&流媒体的原理以及基础入门知识\n](https://zhuanlan.zhihu.com/p/232291020)\n\n[基础概念](https://help.aliyun.com/document_detail/99380.html?spm=a2c4g.11186623.6.553.28b0c149c65swI)","source":"_posts/流媒体基础知识点.md","raw":"---\ntitle: 流媒体基础知识点\ndate: 2021-07-26 11:16:39\ncategories: \n- 视频\ntags:\n- 视频\n---\n\n# 目的\n\n学习流媒体之前，应该要首先知道流媒体相关基础知识点，这样能够更好地掌握流媒体\n\n## 概念\n流媒体是什么？按照我个人理解就是将音视频数据转化成能够在互联网进行播放的一种流式技术。\n\n## 知识点\n\n### 文件格式\n\n操作系统的扩展名，常用的视频保存格式有：mp4、avi、mpg等\n\n### 封装格式\n\n封装格式（Format），也称多媒体容器（Multimedia Container），是将已编码压缩好的视频轨道、音频轨道和元数据（视频基本信息如标题、字幕等）按照一定的格式规范，打包放到一个文件中，形成特定文件格式的视频文件。\n\n### 编解码\n\n硬编解码：通过硬件实现编解码，减轻CPU计算的负担，如GPU等\n\n软编解码：如 H264、H265、MPEG-4等编解码算法，更消耗CPU\n\n\n### 编码格式\n\n视频编码方式将视频数据进行压缩或者解压。一般来说压缩技术都会有损数据的\n\n视频编码格式：\n1. H.26X系列：\n    -   H261：主要在老的视频会议和视频电话产品中使用。\n    -   H263：主要用在视频会议、视频电话和网络视频上。\n    -   H264：视频压缩技术，比较普及和广发使用，在媒体项目中也是会经常接触，目前市面上多数的流媒体服务都支持H264编码的视频\n    -   H265：高效视频压缩技术，同比H264来说压缩效率提高了50%（同画面质量的情况下），而且还支持4K/8K的视频效果，未来会是趋势。但是目前市面上普遍的播放器支持度并不高，flv协议则不支持H265的格式编码的视频。\n1. MPEG系列\n    - MPEG-1第二部分：主要使用在VCD上，有些在线视频也使用这种格式，该编解码器的质量大致上和原有的VHS录像带相当。\n    - MPEG-2第二部分：等同于H.262，使用在DVD、SVCD和大多数数字视频广播系统和有线分布系统（Cable Distribution Systems）中。\n    - MPEG-4第二部分：可以使用在网络传输、广播和媒体存储上，比起MPEG-2和第一版的H.263，它的压缩性能有所提高。\n    -   MPEG-4第十部分：技术上和ITU-TH.264是相同的标准，二者合作，诞生了H.264/AVC标准，ITU-T将其命名为H.264，而ISO/IEC称它为MPEG-4高级视频编码（Advanced Video Coding，AVC）。\n1. AVS：我国自主知识产权的信源编码标准\n\n音频编码格式：\n1. AAC：ACC是MPEG-4中的音频标准（常见）\n1. AMR\n1. PCM\n1. ogg(ogg vorbis音频)\n1. AC3(DVD 专用音频编码)\n1. DTS(DVD 专用音频编码)\n1. APE(monkey’s 音频)\n1. AU(sun 格式)\n1. WMA\n\n\n音频编码方案之间音质比较（AAC，MP3，WMA等）结果： AAC+ > MP3PRO > AAC> RealAudio > WMA > MP3\n\n### 转码\n\n视频转码（Video Transcoding）是指将已经压缩编码的视频码流转换成另一个视频码流\n\n### 转封装\n\n转封装指的是将视频或音频的封装格式进行转换，如将AVI的视频转换为MP4，其间并不会进行音视频的编码和解码工作，而是直接将视频和音频压缩码流从一种封装格式文件中获取出来然后打包成另一种封装格式的文件。相比转码，转封装有两大特点：\n\n    处理速度极快。音视频编解码过程十分复杂，占据了转码的绝大部分时间。转封装不需要进行编码和解码，节约了大量的处理时间。\n\n    音视频质量无损。没有解码（解压缩）和编码（压缩）过程，所以不会有音视频的压缩损伤。\n转封装后的文件与原始文件的分辨率、码率等几乎一致，故播放时也称其为“原画”。\n\n### 码流与码率\n码率（Bitrate）是指视频文件在单位时间内使用的数据流量，也叫码流或码流率，是视频编码中画面质量控制最重要的部分。量度单位为“比特每秒”（bit/s或bps），常使用Kbps（每秒多少千个比特）或Mbps。一般来说同样分辨率下，视频文件的码率越大，压缩比就越小，画面质量就越高。码率越大，说明单位时间内取样率越大，数据流精度就越高，处理出来的文件就越接近原始文件，图像质量越好，画质越清晰，要求播放设备的解码能力也越高。\n\n    当然，码率越大，文件体积也越大，其计算公式是文件体积=时间X码率/8。例如，网络上常见的一部60分钟的码率为1Mbps的720P的视频文件，其体积就大概为3600秒×1Mb/8=450MB。\n    \n### 分辨率\n\n视频分辨率是指视频成像产品所成图像的大小或尺寸。分辨率决定了视频画面细节的精细程度。通常情况下，视频的分辨率越高，所包含的像素就越多，画面就越清晰。\n\n480P : 640 x 480 个像素点\n\n720P : 1280 x 720 个像素点\n\n1080P : 1920 x 1080 个像素点\n\n    分辨率是决定码率的主要因素，不同的分辨率要采用不同的码率。总体而言，视频的分辨率越高，所要求的码率也越大，但并不总是如此，不同分辨率都有合理的码率选择范围。\n    所谓“合理的范围”指的是，如果低于这个范围，视频画面质量会很差；如果高于这个范围，画面提升有限甚至几乎无提升，且浪费网络流量和存储空间。 \n\n\n### 帧率\n帧率（Frame Rate）是单位时间内视频显示帧数的量度单位，也就是每秒钟刷新的图片的帧数，量度单位为“每秒显示帧数”（Frame Per Second，FPS）或“赫兹”\n\n关于帧率有如下几个基础数据：\n\n- 帧率越高，cpu消耗就高\n- 秀场视频直播，一般帧率20fps\n- 普通视频直播，一般帧率15fps\n\n\n### GOP（关键帧间隔）\n\nGOP（Group of Pictures）是一组以 MPEG 编码的影片或视讯串流内部的连续图像，以 I 帧开头，到下一个 I 帧结束\n\n\n- I 帧(Intra Coded Picture)：又称帧内编码帧，为关键帧，是一种自带全部信息的独立帧，无需参考其他图像便可独立进行解码，可以简单理解为一张静态画面。视频序列中的第一个帧始终都是I 帧，每个 GOP 由I 帧开始。\n- P 帧(Predictive Coded Picture)：又称帧间预测编码帧，需要参考前面的I帧才能进行编码。表示的是当前帧画面与前一帧（前一帧可能是I帧也可能是P帧）的差别。解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。与I帧相比，P帧通常占用更少的数据位，但不足是，由于P帧对前面的P和I参考帧有着复杂的依赖性，因此对传输错误非常敏感\n- B 帧(Bidirectionally Predictive Coded Pictures)：又称双向预测编码帧，也就是B帧记录的是本帧与前后帧的差别。也就是说要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是对解码性能要求较高。\n\nGOP值表示关键帧的间隔(即两个关键帧之间的帧数)，也就是两个IDR帧之间的距离，一个帧组的最大帧数。一般而言，每一秒视频至少需要使用 1 个关键帧。增加关键帧个数可改善视频质量，但会同时增加带宽和网络负载。GOP值（帧数）除以帧率即为时间间隔，如阿里云视频点播默认的GOP值为250帧，帧率为25fps，则时间间隔为10秒。\n\nGOP值需要控制在合理范围，以平衡视频质量、文件大小（网络带宽）和seek效果（拖动、快进的响应速度）等：\n\n```\n1.加大GOP值有利于减小视频文件大小，但也不宜设置过大，太大则会导致GOP后部帧的画面失真，影响视频质量。\n\n2.GOP值也是影响视频seek响应速度的关键因素，seek时播放器需要定位到离指定位置最近的前一个关键帧，如果GOP太大意味着距离指定位置可能越远（需要解码的预测帧就越多）、seek响应的时间（缓冲时间）也越长。\n\n3.由于P、B帧的复杂度大于I帧，GOP值过大，过多的P、B帧会影响编码效率，使编码效率降低。\n\n4.但如果设置过小的GOP值，则需要提高视频的输出码率，以确保画面质量不会降低，故会增加网络带宽。\n```\n\n### IDR 帧对齐\nIDR帧（Instantaneous Decoding Refresh Picture），即时解码刷新帧，是 I 帧的一种。与普通 I 帧的区别在于，一个 IDR 帧之后的所有帧都不能引用该 IDR 帧之前的帧的内容；相反，对于普通的 I 帧，其后的 P 帧和 B 帧可以引用该普通 I 帧之前的其他 I 帧。在编码和解码中为了方便，将首个I帧和其他I帧区别开，称为IDR，这样就方便控制编码和解码流程\n\n### 图像存储格式yuv\n\nYUV格式，与我们熟知的RGB类似，YUV也是一种颜色编码方法。YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。\n\nYUV与RGB相比：\nYUV是利用一个亮度（Y）、两个色差(U,V)来代替传统的RGB三原色来压缩图像。传统的RGB三原色使用红绿蓝三原色表示一个像素，每种原色占用一个字节（8bit），因此一个像素用RGB表示则需要8 * 3=24bit。\n\n\n\n## 总结\n\n1.码率与分辨率有关系，分辨率决定码率的主要因素，跟帧率没关，帧率关系着画面流畅度和cpu消耗\n\n2.I帧可以看作一张完整的画面，P帧需要与缓存之前画面生成图像，而B帧则就需要记录前后画面画面生成图像。一般来说网络上的电影都会使用B帧，因为压缩率高，带宽消耗相对比较低。压缩率一般是 I帧（7）< P帧（20） < B帧（50）\n\n3.一般来说，硬编码相比一般性能高，效率高，但移植和实现都比较困难，而软编码则实现简单，但性能相比就低一点。\n\n> PS:\n在项目遇到过一次坑就是关于视频YUV的问题，由于海康和大华的颜色编码不是相同，海康设备使用了YV12格式，而大华使用了YUV420格式，但是程序统一使用了YUV420，因此海康的画面出现了色差问题。\n\n# 参考\n[音视频&流媒体的原理以及基础入门知识\n](https://zhuanlan.zhihu.com/p/232291020)\n\n[基础概念](https://help.aliyun.com/document_detail/99380.html?spm=a2c4g.11186623.6.553.28b0c149c65swI)","slug":"流媒体基础知识点","published":1,"updated":"2021-09-07T08:00:52.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhs7001id0tv14jtco0p","content":"<h1 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h1><p>学习流媒体之前，应该要首先知道流媒体相关基础知识点，这样能够更好地掌握流媒体</p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>流媒体是什么？按照我个人理解就是将音视频数据转化成能够在互联网进行播放的一种流式技术。</p>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><h3 id=\"文件格式\"><a href=\"#文件格式\" class=\"headerlink\" title=\"文件格式\"></a>文件格式</h3><p>操作系统的扩展名，常用的视频保存格式有：mp4、avi、mpg等</p>\n<h3 id=\"封装格式\"><a href=\"#封装格式\" class=\"headerlink\" title=\"封装格式\"></a>封装格式</h3><p>封装格式（Format），也称多媒体容器（Multimedia Container），是将已编码压缩好的视频轨道、音频轨道和元数据（视频基本信息如标题、字幕等）按照一定的格式规范，打包放到一个文件中，形成特定文件格式的视频文件。</p>\n<h3 id=\"编解码\"><a href=\"#编解码\" class=\"headerlink\" title=\"编解码\"></a>编解码</h3><p>硬编解码：通过硬件实现编解码，减轻CPU计算的负担，如GPU等</p>\n<p>软编解码：如 H264、H265、MPEG-4等编解码算法，更消耗CPU</p>\n<h3 id=\"编码格式\"><a href=\"#编码格式\" class=\"headerlink\" title=\"编码格式\"></a>编码格式</h3><p>视频编码方式将视频数据进行压缩或者解压。一般来说压缩技术都会有损数据的</p>\n<p>视频编码格式：</p>\n<ol>\n<li>H.26X系列：<ul>\n<li>H261：主要在老的视频会议和视频电话产品中使用。</li>\n<li>H263：主要用在视频会议、视频电话和网络视频上。</li>\n<li>H264：视频压缩技术，比较普及和广发使用，在媒体项目中也是会经常接触，目前市面上多数的流媒体服务都支持H264编码的视频</li>\n<li>H265：高效视频压缩技术，同比H264来说压缩效率提高了50%（同画面质量的情况下），而且还支持4K/8K的视频效果，未来会是趋势。但是目前市面上普遍的播放器支持度并不高，flv协议则不支持H265的格式编码的视频。</li>\n</ul>\n</li>\n<li>MPEG系列<ul>\n<li>MPEG-1第二部分：主要使用在VCD上，有些在线视频也使用这种格式，该编解码器的质量大致上和原有的VHS录像带相当。</li>\n<li>MPEG-2第二部分：等同于H.262，使用在DVD、SVCD和大多数数字视频广播系统和有线分布系统（Cable Distribution Systems）中。</li>\n<li>MPEG-4第二部分：可以使用在网络传输、广播和媒体存储上，比起MPEG-2和第一版的H.263，它的压缩性能有所提高。</li>\n<li>MPEG-4第十部分：技术上和ITU-TH.264是相同的标准，二者合作，诞生了H.264/AVC标准，ITU-T将其命名为H.264，而ISO/IEC称它为MPEG-4高级视频编码（Advanced Video Coding，AVC）。</li>\n</ul>\n</li>\n<li>AVS：我国自主知识产权的信源编码标准</li>\n</ol>\n<p>音频编码格式：</p>\n<ol>\n<li>AAC：ACC是MPEG-4中的音频标准（常见）</li>\n<li>AMR</li>\n<li>PCM</li>\n<li>ogg(ogg vorbis音频)</li>\n<li>AC3(DVD 专用音频编码)</li>\n<li>DTS(DVD 专用音频编码)</li>\n<li>APE(monkey’s 音频)</li>\n<li>AU(sun 格式)</li>\n<li>WMA</li>\n</ol>\n<p>音频编码方案之间音质比较（AAC，MP3，WMA等）结果： AAC+ &gt; MP3PRO &gt; AAC&gt; RealAudio &gt; WMA &gt; MP3</p>\n<h3 id=\"转码\"><a href=\"#转码\" class=\"headerlink\" title=\"转码\"></a>转码</h3><p>视频转码（Video Transcoding）是指将已经压缩编码的视频码流转换成另一个视频码流</p>\n<h3 id=\"转封装\"><a href=\"#转封装\" class=\"headerlink\" title=\"转封装\"></a>转封装</h3><p>转封装指的是将视频或音频的封装格式进行转换，如将AVI的视频转换为MP4，其间并不会进行音视频的编码和解码工作，而是直接将视频和音频压缩码流从一种封装格式文件中获取出来然后打包成另一种封装格式的文件。相比转码，转封装有两大特点：</p>\n<pre><code>处理速度极快。音视频编解码过程十分复杂，占据了转码的绝大部分时间。转封装不需要进行编码和解码，节约了大量的处理时间。\n\n音视频质量无损。没有解码（解压缩）和编码（压缩）过程，所以不会有音视频的压缩损伤。\n</code></pre><p>转封装后的文件与原始文件的分辨率、码率等几乎一致，故播放时也称其为“原画”。</p>\n<h3 id=\"码流与码率\"><a href=\"#码流与码率\" class=\"headerlink\" title=\"码流与码率\"></a>码流与码率</h3><p>码率（Bitrate）是指视频文件在单位时间内使用的数据流量，也叫码流或码流率，是视频编码中画面质量控制最重要的部分。量度单位为“比特每秒”（bit/s或bps），常使用Kbps（每秒多少千个比特）或Mbps。一般来说同样分辨率下，视频文件的码率越大，压缩比就越小，画面质量就越高。码率越大，说明单位时间内取样率越大，数据流精度就越高，处理出来的文件就越接近原始文件，图像质量越好，画质越清晰，要求播放设备的解码能力也越高。</p>\n<pre><code>当然，码率越大，文件体积也越大，其计算公式是文件体积=时间X码率/8。例如，网络上常见的一部60分钟的码率为1Mbps的720P的视频文件，其体积就大概为3600秒×1Mb/8=450MB。\n</code></pre><h3 id=\"分辨率\"><a href=\"#分辨率\" class=\"headerlink\" title=\"分辨率\"></a>分辨率</h3><p>视频分辨率是指视频成像产品所成图像的大小或尺寸。分辨率决定了视频画面细节的精细程度。通常情况下，视频的分辨率越高，所包含的像素就越多，画面就越清晰。</p>\n<p>480P : 640 x 480 个像素点</p>\n<p>720P : 1280 x 720 个像素点</p>\n<p>1080P : 1920 x 1080 个像素点</p>\n<pre><code>分辨率是决定码率的主要因素，不同的分辨率要采用不同的码率。总体而言，视频的分辨率越高，所要求的码率也越大，但并不总是如此，不同分辨率都有合理的码率选择范围。\n所谓“合理的范围”指的是，如果低于这个范围，视频画面质量会很差；如果高于这个范围，画面提升有限甚至几乎无提升，且浪费网络流量和存储空间。 \n</code></pre><h3 id=\"帧率\"><a href=\"#帧率\" class=\"headerlink\" title=\"帧率\"></a>帧率</h3><p>帧率（Frame Rate）是单位时间内视频显示帧数的量度单位，也就是每秒钟刷新的图片的帧数，量度单位为“每秒显示帧数”（Frame Per Second，FPS）或“赫兹”</p>\n<p>关于帧率有如下几个基础数据：</p>\n<ul>\n<li>帧率越高，cpu消耗就高</li>\n<li>秀场视频直播，一般帧率20fps</li>\n<li>普通视频直播，一般帧率15fps</li>\n</ul>\n<h3 id=\"GOP（关键帧间隔）\"><a href=\"#GOP（关键帧间隔）\" class=\"headerlink\" title=\"GOP（关键帧间隔）\"></a>GOP（关键帧间隔）</h3><p>GOP（Group of Pictures）是一组以 MPEG 编码的影片或视讯串流内部的连续图像，以 I 帧开头，到下一个 I 帧结束</p>\n<ul>\n<li>I 帧(Intra Coded Picture)：又称帧内编码帧，为关键帧，是一种自带全部信息的独立帧，无需参考其他图像便可独立进行解码，可以简单理解为一张静态画面。视频序列中的第一个帧始终都是I 帧，每个 GOP 由I 帧开始。</li>\n<li>P 帧(Predictive Coded Picture)：又称帧间预测编码帧，需要参考前面的I帧才能进行编码。表示的是当前帧画面与前一帧（前一帧可能是I帧也可能是P帧）的差别。解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。与I帧相比，P帧通常占用更少的数据位，但不足是，由于P帧对前面的P和I参考帧有着复杂的依赖性，因此对传输错误非常敏感</li>\n<li>B 帧(Bidirectionally Predictive Coded Pictures)：又称双向预测编码帧，也就是B帧记录的是本帧与前后帧的差别。也就是说要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是对解码性能要求较高。</li>\n</ul>\n<p>GOP值表示关键帧的间隔(即两个关键帧之间的帧数)，也就是两个IDR帧之间的距离，一个帧组的最大帧数。一般而言，每一秒视频至少需要使用 1 个关键帧。增加关键帧个数可改善视频质量，但会同时增加带宽和网络负载。GOP值（帧数）除以帧率即为时间间隔，如阿里云视频点播默认的GOP值为250帧，帧率为25fps，则时间间隔为10秒。</p>\n<p>GOP值需要控制在合理范围，以平衡视频质量、文件大小（网络带宽）和seek效果（拖动、快进的响应速度）等：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.加大GOP值有利于减小视频文件大小，但也不宜设置过大，太大则会导致GOP后部帧的画面失真，影响视频质量。</span><br><span class=\"line\"></span><br><span class=\"line\">2.GOP值也是影响视频seek响应速度的关键因素，seek时播放器需要定位到离指定位置最近的前一个关键帧，如果GOP太大意味着距离指定位置可能越远（需要解码的预测帧就越多）、seek响应的时间（缓冲时间）也越长。</span><br><span class=\"line\"></span><br><span class=\"line\">3.由于P、B帧的复杂度大于I帧，GOP值过大，过多的P、B帧会影响编码效率，使编码效率降低。</span><br><span class=\"line\"></span><br><span class=\"line\">4.但如果设置过小的GOP值，则需要提高视频的输出码率，以确保画面质量不会降低，故会增加网络带宽。</span><br></pre></td></tr></table></figure>\n<h3 id=\"IDR-帧对齐\"><a href=\"#IDR-帧对齐\" class=\"headerlink\" title=\"IDR 帧对齐\"></a>IDR 帧对齐</h3><p>IDR帧（Instantaneous Decoding Refresh Picture），即时解码刷新帧，是 I 帧的一种。与普通 I 帧的区别在于，一个 IDR 帧之后的所有帧都不能引用该 IDR 帧之前的帧的内容；相反，对于普通的 I 帧，其后的 P 帧和 B 帧可以引用该普通 I 帧之前的其他 I 帧。在编码和解码中为了方便，将首个I帧和其他I帧区别开，称为IDR，这样就方便控制编码和解码流程</p>\n<h3 id=\"图像存储格式yuv\"><a href=\"#图像存储格式yuv\" class=\"headerlink\" title=\"图像存储格式yuv\"></a>图像存储格式yuv</h3><p>YUV格式，与我们熟知的RGB类似，YUV也是一种颜色编码方法。YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p>\n<p>YUV与RGB相比：<br>YUV是利用一个亮度（Y）、两个色差(U,V)来代替传统的RGB三原色来压缩图像。传统的RGB三原色使用红绿蓝三原色表示一个像素，每种原色占用一个字节（8bit），因此一个像素用RGB表示则需要8 * 3=24bit。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1.码率与分辨率有关系，分辨率决定码率的主要因素，跟帧率没关，帧率关系着画面流畅度和cpu消耗</p>\n<p>2.I帧可以看作一张完整的画面，P帧需要与缓存之前画面生成图像，而B帧则就需要记录前后画面画面生成图像。一般来说网络上的电影都会使用B帧，因为压缩率高，带宽消耗相对比较低。压缩率一般是 I帧（7）&lt; P帧（20） &lt; B帧（50）</p>\n<p>3.一般来说，硬编码相比一般性能高，效率高，但移植和实现都比较困难，而软编码则实现简单，但性能相比就低一点。</p>\n<blockquote>\n<p>PS:<br>在项目遇到过一次坑就是关于视频YUV的问题，由于海康和大华的颜色编码不是相同，海康设备使用了YV12格式，而大华使用了YUV420格式，但是程序统一使用了YUV420，因此海康的画面出现了色差问题。</p>\n</blockquote>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://zhuanlan.zhihu.com/p/232291020\" target=\"_blank\" rel=\"noopener\">音视频&amp;流媒体的原理以及基础入门知识\n</a></p>\n<p><a href=\"https://help.aliyun.com/document_detail/99380.html?spm=a2c4g.11186623.6.553.28b0c149c65swI\" target=\"_blank\" rel=\"noopener\">基础概念</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h1><p>学习流媒体之前，应该要首先知道流媒体相关基础知识点，这样能够更好地掌握流媒体</p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>流媒体是什么？按照我个人理解就是将音视频数据转化成能够在互联网进行播放的一种流式技术。</p>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><h3 id=\"文件格式\"><a href=\"#文件格式\" class=\"headerlink\" title=\"文件格式\"></a>文件格式</h3><p>操作系统的扩展名，常用的视频保存格式有：mp4、avi、mpg等</p>\n<h3 id=\"封装格式\"><a href=\"#封装格式\" class=\"headerlink\" title=\"封装格式\"></a>封装格式</h3><p>封装格式（Format），也称多媒体容器（Multimedia Container），是将已编码压缩好的视频轨道、音频轨道和元数据（视频基本信息如标题、字幕等）按照一定的格式规范，打包放到一个文件中，形成特定文件格式的视频文件。</p>\n<h3 id=\"编解码\"><a href=\"#编解码\" class=\"headerlink\" title=\"编解码\"></a>编解码</h3><p>硬编解码：通过硬件实现编解码，减轻CPU计算的负担，如GPU等</p>\n<p>软编解码：如 H264、H265、MPEG-4等编解码算法，更消耗CPU</p>\n<h3 id=\"编码格式\"><a href=\"#编码格式\" class=\"headerlink\" title=\"编码格式\"></a>编码格式</h3><p>视频编码方式将视频数据进行压缩或者解压。一般来说压缩技术都会有损数据的</p>\n<p>视频编码格式：</p>\n<ol>\n<li>H.26X系列：<ul>\n<li>H261：主要在老的视频会议和视频电话产品中使用。</li>\n<li>H263：主要用在视频会议、视频电话和网络视频上。</li>\n<li>H264：视频压缩技术，比较普及和广发使用，在媒体项目中也是会经常接触，目前市面上多数的流媒体服务都支持H264编码的视频</li>\n<li>H265：高效视频压缩技术，同比H264来说压缩效率提高了50%（同画面质量的情况下），而且还支持4K/8K的视频效果，未来会是趋势。但是目前市面上普遍的播放器支持度并不高，flv协议则不支持H265的格式编码的视频。</li>\n</ul>\n</li>\n<li>MPEG系列<ul>\n<li>MPEG-1第二部分：主要使用在VCD上，有些在线视频也使用这种格式，该编解码器的质量大致上和原有的VHS录像带相当。</li>\n<li>MPEG-2第二部分：等同于H.262，使用在DVD、SVCD和大多数数字视频广播系统和有线分布系统（Cable Distribution Systems）中。</li>\n<li>MPEG-4第二部分：可以使用在网络传输、广播和媒体存储上，比起MPEG-2和第一版的H.263，它的压缩性能有所提高。</li>\n<li>MPEG-4第十部分：技术上和ITU-TH.264是相同的标准，二者合作，诞生了H.264/AVC标准，ITU-T将其命名为H.264，而ISO/IEC称它为MPEG-4高级视频编码（Advanced Video Coding，AVC）。</li>\n</ul>\n</li>\n<li>AVS：我国自主知识产权的信源编码标准</li>\n</ol>\n<p>音频编码格式：</p>\n<ol>\n<li>AAC：ACC是MPEG-4中的音频标准（常见）</li>\n<li>AMR</li>\n<li>PCM</li>\n<li>ogg(ogg vorbis音频)</li>\n<li>AC3(DVD 专用音频编码)</li>\n<li>DTS(DVD 专用音频编码)</li>\n<li>APE(monkey’s 音频)</li>\n<li>AU(sun 格式)</li>\n<li>WMA</li>\n</ol>\n<p>音频编码方案之间音质比较（AAC，MP3，WMA等）结果： AAC+ &gt; MP3PRO &gt; AAC&gt; RealAudio &gt; WMA &gt; MP3</p>\n<h3 id=\"转码\"><a href=\"#转码\" class=\"headerlink\" title=\"转码\"></a>转码</h3><p>视频转码（Video Transcoding）是指将已经压缩编码的视频码流转换成另一个视频码流</p>\n<h3 id=\"转封装\"><a href=\"#转封装\" class=\"headerlink\" title=\"转封装\"></a>转封装</h3><p>转封装指的是将视频或音频的封装格式进行转换，如将AVI的视频转换为MP4，其间并不会进行音视频的编码和解码工作，而是直接将视频和音频压缩码流从一种封装格式文件中获取出来然后打包成另一种封装格式的文件。相比转码，转封装有两大特点：</p>\n<pre><code>处理速度极快。音视频编解码过程十分复杂，占据了转码的绝大部分时间。转封装不需要进行编码和解码，节约了大量的处理时间。\n\n音视频质量无损。没有解码（解压缩）和编码（压缩）过程，所以不会有音视频的压缩损伤。\n</code></pre><p>转封装后的文件与原始文件的分辨率、码率等几乎一致，故播放时也称其为“原画”。</p>\n<h3 id=\"码流与码率\"><a href=\"#码流与码率\" class=\"headerlink\" title=\"码流与码率\"></a>码流与码率</h3><p>码率（Bitrate）是指视频文件在单位时间内使用的数据流量，也叫码流或码流率，是视频编码中画面质量控制最重要的部分。量度单位为“比特每秒”（bit/s或bps），常使用Kbps（每秒多少千个比特）或Mbps。一般来说同样分辨率下，视频文件的码率越大，压缩比就越小，画面质量就越高。码率越大，说明单位时间内取样率越大，数据流精度就越高，处理出来的文件就越接近原始文件，图像质量越好，画质越清晰，要求播放设备的解码能力也越高。</p>\n<pre><code>当然，码率越大，文件体积也越大，其计算公式是文件体积=时间X码率/8。例如，网络上常见的一部60分钟的码率为1Mbps的720P的视频文件，其体积就大概为3600秒×1Mb/8=450MB。\n</code></pre><h3 id=\"分辨率\"><a href=\"#分辨率\" class=\"headerlink\" title=\"分辨率\"></a>分辨率</h3><p>视频分辨率是指视频成像产品所成图像的大小或尺寸。分辨率决定了视频画面细节的精细程度。通常情况下，视频的分辨率越高，所包含的像素就越多，画面就越清晰。</p>\n<p>480P : 640 x 480 个像素点</p>\n<p>720P : 1280 x 720 个像素点</p>\n<p>1080P : 1920 x 1080 个像素点</p>\n<pre><code>分辨率是决定码率的主要因素，不同的分辨率要采用不同的码率。总体而言，视频的分辨率越高，所要求的码率也越大，但并不总是如此，不同分辨率都有合理的码率选择范围。\n所谓“合理的范围”指的是，如果低于这个范围，视频画面质量会很差；如果高于这个范围，画面提升有限甚至几乎无提升，且浪费网络流量和存储空间。 \n</code></pre><h3 id=\"帧率\"><a href=\"#帧率\" class=\"headerlink\" title=\"帧率\"></a>帧率</h3><p>帧率（Frame Rate）是单位时间内视频显示帧数的量度单位，也就是每秒钟刷新的图片的帧数，量度单位为“每秒显示帧数”（Frame Per Second，FPS）或“赫兹”</p>\n<p>关于帧率有如下几个基础数据：</p>\n<ul>\n<li>帧率越高，cpu消耗就高</li>\n<li>秀场视频直播，一般帧率20fps</li>\n<li>普通视频直播，一般帧率15fps</li>\n</ul>\n<h3 id=\"GOP（关键帧间隔）\"><a href=\"#GOP（关键帧间隔）\" class=\"headerlink\" title=\"GOP（关键帧间隔）\"></a>GOP（关键帧间隔）</h3><p>GOP（Group of Pictures）是一组以 MPEG 编码的影片或视讯串流内部的连续图像，以 I 帧开头，到下一个 I 帧结束</p>\n<ul>\n<li>I 帧(Intra Coded Picture)：又称帧内编码帧，为关键帧，是一种自带全部信息的独立帧，无需参考其他图像便可独立进行解码，可以简单理解为一张静态画面。视频序列中的第一个帧始终都是I 帧，每个 GOP 由I 帧开始。</li>\n<li>P 帧(Predictive Coded Picture)：又称帧间预测编码帧，需要参考前面的I帧才能进行编码。表示的是当前帧画面与前一帧（前一帧可能是I帧也可能是P帧）的差别。解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。与I帧相比，P帧通常占用更少的数据位，但不足是，由于P帧对前面的P和I参考帧有着复杂的依赖性，因此对传输错误非常敏感</li>\n<li>B 帧(Bidirectionally Predictive Coded Pictures)：又称双向预测编码帧，也就是B帧记录的是本帧与前后帧的差别。也就是说要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是对解码性能要求较高。</li>\n</ul>\n<p>GOP值表示关键帧的间隔(即两个关键帧之间的帧数)，也就是两个IDR帧之间的距离，一个帧组的最大帧数。一般而言，每一秒视频至少需要使用 1 个关键帧。增加关键帧个数可改善视频质量，但会同时增加带宽和网络负载。GOP值（帧数）除以帧率即为时间间隔，如阿里云视频点播默认的GOP值为250帧，帧率为25fps，则时间间隔为10秒。</p>\n<p>GOP值需要控制在合理范围，以平衡视频质量、文件大小（网络带宽）和seek效果（拖动、快进的响应速度）等：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.加大GOP值有利于减小视频文件大小，但也不宜设置过大，太大则会导致GOP后部帧的画面失真，影响视频质量。</span><br><span class=\"line\"></span><br><span class=\"line\">2.GOP值也是影响视频seek响应速度的关键因素，seek时播放器需要定位到离指定位置最近的前一个关键帧，如果GOP太大意味着距离指定位置可能越远（需要解码的预测帧就越多）、seek响应的时间（缓冲时间）也越长。</span><br><span class=\"line\"></span><br><span class=\"line\">3.由于P、B帧的复杂度大于I帧，GOP值过大，过多的P、B帧会影响编码效率，使编码效率降低。</span><br><span class=\"line\"></span><br><span class=\"line\">4.但如果设置过小的GOP值，则需要提高视频的输出码率，以确保画面质量不会降低，故会增加网络带宽。</span><br></pre></td></tr></table></figure>\n<h3 id=\"IDR-帧对齐\"><a href=\"#IDR-帧对齐\" class=\"headerlink\" title=\"IDR 帧对齐\"></a>IDR 帧对齐</h3><p>IDR帧（Instantaneous Decoding Refresh Picture），即时解码刷新帧，是 I 帧的一种。与普通 I 帧的区别在于，一个 IDR 帧之后的所有帧都不能引用该 IDR 帧之前的帧的内容；相反，对于普通的 I 帧，其后的 P 帧和 B 帧可以引用该普通 I 帧之前的其他 I 帧。在编码和解码中为了方便，将首个I帧和其他I帧区别开，称为IDR，这样就方便控制编码和解码流程</p>\n<h3 id=\"图像存储格式yuv\"><a href=\"#图像存储格式yuv\" class=\"headerlink\" title=\"图像存储格式yuv\"></a>图像存储格式yuv</h3><p>YUV格式，与我们熟知的RGB类似，YUV也是一种颜色编码方法。YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p>\n<p>YUV与RGB相比：<br>YUV是利用一个亮度（Y）、两个色差(U,V)来代替传统的RGB三原色来压缩图像。传统的RGB三原色使用红绿蓝三原色表示一个像素，每种原色占用一个字节（8bit），因此一个像素用RGB表示则需要8 * 3=24bit。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1.码率与分辨率有关系，分辨率决定码率的主要因素，跟帧率没关，帧率关系着画面流畅度和cpu消耗</p>\n<p>2.I帧可以看作一张完整的画面，P帧需要与缓存之前画面生成图像，而B帧则就需要记录前后画面画面生成图像。一般来说网络上的电影都会使用B帧，因为压缩率高，带宽消耗相对比较低。压缩率一般是 I帧（7）&lt; P帧（20） &lt; B帧（50）</p>\n<p>3.一般来说，硬编码相比一般性能高，效率高，但移植和实现都比较困难，而软编码则实现简单，但性能相比就低一点。</p>\n<blockquote>\n<p>PS:<br>在项目遇到过一次坑就是关于视频YUV的问题，由于海康和大华的颜色编码不是相同，海康设备使用了YV12格式，而大华使用了YUV420格式，但是程序统一使用了YUV420，因此海康的画面出现了色差问题。</p>\n</blockquote>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://zhuanlan.zhihu.com/p/232291020\" target=\"_blank\" rel=\"noopener\">音视频&amp;流媒体的原理以及基础入门知识\n</a></p>\n<p><a href=\"https://help.aliyun.com/document_detail/99380.html?spm=a2c4g.11186623.6.553.28b0c149c65swI\" target=\"_blank\" rel=\"noopener\">基础概念</a></p>\n"},{"title":"视频性能压测","date":"2021-07-22T03:16:39.000Z","_content":"\n## 背景\n由于项目接入了二千多路摄像头，三十台机器集群，应项目的要求对程序项目进行压测，目标是测试到一台流媒体服务器能同时并发支撑多小路视频，从而推测整个集群的能力，也为以后的扩展。\n\n## 前期准备\n\n- 服务器1台\n\n  配置：CPU 8核,内存 16G\n- 客户端1台\n\n  配置：CPU 8核,内存 16G\n- 监控服务端工具nmon：\n- 压测工具：自研发的一款拉流工具，针对我们视频项目接口定制化开发\n\n- 300个海康摄像头1920×1080P(可用正式环境)\n\n## 压测\n\n在压测的时候我认为需要清楚了解整个网络架构图，这样才能发现哪些地方存在的瓶颈，便于后期针对瓶颈地方进行压测。以下是我大致画出当时项目的网络环境：\n\n![网络架构图](/images/video/压测流程图.png)\n\n\n经过分析，存在瓶颈：\n1. 客户端自研拉流程序m1存在拉流的性能瓶颈\n2. 流媒体北向的拉流分发能力m2的瓶颈\n3. 流媒体南向的推流能力m3的瓶颈\n4. 验证m4出口是否有千兆带宽\n\n\n### 场景一\n\n场景：多个用户，同时访问1路摄像头视频\n\n目的：测出单台流媒体服务北向分发能力m2的极限。\n\n为了减少自研发的客户端拉流程序瓶颈对本次压力测试造成影响，使用多个客户端进行拉流。  \n\n![场景一](/images/video/压测结果一.png)\n\n结论：160个用户访问同一路摄像头视频时，系统能够稳定工作；北向并发能力达到160以上。\n\n### 场景二\n\n场景：两个客户端分别请求N路不同的视频，共请求2N路视频。每路视频1人观看。\n\n目的：测出单台流媒体服务南向m3能力的极限。\n\n![场景二](/images/video/压测结果二.png)\n\n\n结论：南向并发处理80路摄像头视频时，系统能够稳定工作；南向并发处理100路摄像头视频时，网络出现较大波动；因此，单个流媒体服务的南向处理能力，为90路视频。\n\n\n### 场景三\n\n场景：两个客户端，分别请求两个不同的流媒体服务器；每个客户端请求N路视频，共请求2N路视频。\n\n目的：南向交换机性能瓶颈测试。\n\n![场景三](/images/video/压测结果三.png)\n\n\n结论：单台客户端服务器最高可以处理南向70路视频，\n单台流媒体服务器最多可处理南向90路视频。\n\n\n### 场景四\n\n场景：两个客户端，分别请求一台服务器上的两个流媒体服务；每个客户端请求N路视频，共请求2N路视频。\n\n目的：压测m4出口带宽是否达到千兆瓶颈\n\n![场景四](/images/video/压测结果四.png)\n\n结论：当请求并发90路视频时，单台流媒体服务器系统能够稳定工作，当并发请求100路视频时，网络IO出现较大波动。因此，单台流媒体服务器南向摄像头最多只能处理90路视频\n\n## 总结\n\n其实对于我来说，有幸参与了这次压测的整个过程，其中包括了跟项目组的沟通，跟第三方供应商技术交流等等。其实对于这类压测，最好能确认好控制单一要素，控制单一要素那就需要将每个步骤分层，然后将其余部分当作整体看待。举个例子，要想测试m3南向并发处理能力，那就将m3往下的部分当作整体，将其他没关要素降到影响最低（譬如客户端是瓶颈因素，那就水平扩展客户端），逐步增大压力，观察服务器等指标，如果出现一些业务报错或者其他问题往往就是触发到瓶颈，这个需要根据业务场景来定。由于我们这里偏向于IO密集型，所以一般都是观察网络IO主要是上下行带宽的指标为主。\n\n\n","source":"_posts/视频性能压测.md","raw":"---\ntitle: 视频性能压测\ndate: 2021-07-22 11:16:39\ncategories: \n- 视频\ntags:\n- 视频\n---\n\n## 背景\n由于项目接入了二千多路摄像头，三十台机器集群，应项目的要求对程序项目进行压测，目标是测试到一台流媒体服务器能同时并发支撑多小路视频，从而推测整个集群的能力，也为以后的扩展。\n\n## 前期准备\n\n- 服务器1台\n\n  配置：CPU 8核,内存 16G\n- 客户端1台\n\n  配置：CPU 8核,内存 16G\n- 监控服务端工具nmon：\n- 压测工具：自研发的一款拉流工具，针对我们视频项目接口定制化开发\n\n- 300个海康摄像头1920×1080P(可用正式环境)\n\n## 压测\n\n在压测的时候我认为需要清楚了解整个网络架构图，这样才能发现哪些地方存在的瓶颈，便于后期针对瓶颈地方进行压测。以下是我大致画出当时项目的网络环境：\n\n![网络架构图](/images/video/压测流程图.png)\n\n\n经过分析，存在瓶颈：\n1. 客户端自研拉流程序m1存在拉流的性能瓶颈\n2. 流媒体北向的拉流分发能力m2的瓶颈\n3. 流媒体南向的推流能力m3的瓶颈\n4. 验证m4出口是否有千兆带宽\n\n\n### 场景一\n\n场景：多个用户，同时访问1路摄像头视频\n\n目的：测出单台流媒体服务北向分发能力m2的极限。\n\n为了减少自研发的客户端拉流程序瓶颈对本次压力测试造成影响，使用多个客户端进行拉流。  \n\n![场景一](/images/video/压测结果一.png)\n\n结论：160个用户访问同一路摄像头视频时，系统能够稳定工作；北向并发能力达到160以上。\n\n### 场景二\n\n场景：两个客户端分别请求N路不同的视频，共请求2N路视频。每路视频1人观看。\n\n目的：测出单台流媒体服务南向m3能力的极限。\n\n![场景二](/images/video/压测结果二.png)\n\n\n结论：南向并发处理80路摄像头视频时，系统能够稳定工作；南向并发处理100路摄像头视频时，网络出现较大波动；因此，单个流媒体服务的南向处理能力，为90路视频。\n\n\n### 场景三\n\n场景：两个客户端，分别请求两个不同的流媒体服务器；每个客户端请求N路视频，共请求2N路视频。\n\n目的：南向交换机性能瓶颈测试。\n\n![场景三](/images/video/压测结果三.png)\n\n\n结论：单台客户端服务器最高可以处理南向70路视频，\n单台流媒体服务器最多可处理南向90路视频。\n\n\n### 场景四\n\n场景：两个客户端，分别请求一台服务器上的两个流媒体服务；每个客户端请求N路视频，共请求2N路视频。\n\n目的：压测m4出口带宽是否达到千兆瓶颈\n\n![场景四](/images/video/压测结果四.png)\n\n结论：当请求并发90路视频时，单台流媒体服务器系统能够稳定工作，当并发请求100路视频时，网络IO出现较大波动。因此，单台流媒体服务器南向摄像头最多只能处理90路视频\n\n## 总结\n\n其实对于我来说，有幸参与了这次压测的整个过程，其中包括了跟项目组的沟通，跟第三方供应商技术交流等等。其实对于这类压测，最好能确认好控制单一要素，控制单一要素那就需要将每个步骤分层，然后将其余部分当作整体看待。举个例子，要想测试m3南向并发处理能力，那就将m3往下的部分当作整体，将其他没关要素降到影响最低（譬如客户端是瓶颈因素，那就水平扩展客户端），逐步增大压力，观察服务器等指标，如果出现一些业务报错或者其他问题往往就是触发到瓶颈，这个需要根据业务场景来定。由于我们这里偏向于IO密集型，所以一般都是观察网络IO主要是上下行带宽的指标为主。\n\n\n","slug":"视频性能压测","published":1,"updated":"2021-09-07T08:00:52.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhs9001ld0tvwjliyvlj","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>由于项目接入了二千多路摄像头，三十台机器集群，应项目的要求对程序项目进行压测，目标是测试到一台流媒体服务器能同时并发支撑多小路视频，从而推测整个集群的能力，也为以后的扩展。</p>\n<h2 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ul>\n<li><p>服务器1台</p>\n<p>配置：CPU 8核,内存 16G</p>\n</li>\n<li><p>客户端1台</p>\n<p>配置：CPU 8核,内存 16G</p>\n</li>\n<li>监控服务端工具nmon：</li>\n<li><p>压测工具：自研发的一款拉流工具，针对我们视频项目接口定制化开发</p>\n</li>\n<li><p>300个海康摄像头1920×1080P(可用正式环境)</p>\n</li>\n</ul>\n<h2 id=\"压测\"><a href=\"#压测\" class=\"headerlink\" title=\"压测\"></a>压测</h2><p>在压测的时候我认为需要清楚了解整个网络架构图，这样才能发现哪些地方存在的瓶颈，便于后期针对瓶颈地方进行压测。以下是我大致画出当时项目的网络环境：</p>\n<p><img src=\"/images/video/压测流程图.png\" alt=\"网络架构图\"></p>\n<p>经过分析，存在瓶颈：</p>\n<ol>\n<li>客户端自研拉流程序m1存在拉流的性能瓶颈</li>\n<li>流媒体北向的拉流分发能力m2的瓶颈</li>\n<li>流媒体南向的推流能力m3的瓶颈</li>\n<li>验证m4出口是否有千兆带宽</li>\n</ol>\n<h3 id=\"场景一\"><a href=\"#场景一\" class=\"headerlink\" title=\"场景一\"></a>场景一</h3><p>场景：多个用户，同时访问1路摄像头视频</p>\n<p>目的：测出单台流媒体服务北向分发能力m2的极限。</p>\n<p>为了减少自研发的客户端拉流程序瓶颈对本次压力测试造成影响，使用多个客户端进行拉流。  </p>\n<p><img src=\"/images/video/压测结果一.png\" alt=\"场景一\"></p>\n<p>结论：160个用户访问同一路摄像头视频时，系统能够稳定工作；北向并发能力达到160以上。</p>\n<h3 id=\"场景二\"><a href=\"#场景二\" class=\"headerlink\" title=\"场景二\"></a>场景二</h3><p>场景：两个客户端分别请求N路不同的视频，共请求2N路视频。每路视频1人观看。</p>\n<p>目的：测出单台流媒体服务南向m3能力的极限。</p>\n<p><img src=\"/images/video/压测结果二.png\" alt=\"场景二\"></p>\n<p>结论：南向并发处理80路摄像头视频时，系统能够稳定工作；南向并发处理100路摄像头视频时，网络出现较大波动；因此，单个流媒体服务的南向处理能力，为90路视频。</p>\n<h3 id=\"场景三\"><a href=\"#场景三\" class=\"headerlink\" title=\"场景三\"></a>场景三</h3><p>场景：两个客户端，分别请求两个不同的流媒体服务器；每个客户端请求N路视频，共请求2N路视频。</p>\n<p>目的：南向交换机性能瓶颈测试。</p>\n<p><img src=\"/images/video/压测结果三.png\" alt=\"场景三\"></p>\n<p>结论：单台客户端服务器最高可以处理南向70路视频，<br>单台流媒体服务器最多可处理南向90路视频。</p>\n<h3 id=\"场景四\"><a href=\"#场景四\" class=\"headerlink\" title=\"场景四\"></a>场景四</h3><p>场景：两个客户端，分别请求一台服务器上的两个流媒体服务；每个客户端请求N路视频，共请求2N路视频。</p>\n<p>目的：压测m4出口带宽是否达到千兆瓶颈</p>\n<p><img src=\"/images/video/压测结果四.png\" alt=\"场景四\"></p>\n<p>结论：当请求并发90路视频时，单台流媒体服务器系统能够稳定工作，当并发请求100路视频时，网络IO出现较大波动。因此，单台流媒体服务器南向摄像头最多只能处理90路视频</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实对于我来说，有幸参与了这次压测的整个过程，其中包括了跟项目组的沟通，跟第三方供应商技术交流等等。其实对于这类压测，最好能确认好控制单一要素，控制单一要素那就需要将每个步骤分层，然后将其余部分当作整体看待。举个例子，要想测试m3南向并发处理能力，那就将m3往下的部分当作整体，将其他没关要素降到影响最低（譬如客户端是瓶颈因素，那就水平扩展客户端），逐步增大压力，观察服务器等指标，如果出现一些业务报错或者其他问题往往就是触发到瓶颈，这个需要根据业务场景来定。由于我们这里偏向于IO密集型，所以一般都是观察网络IO主要是上下行带宽的指标为主。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>由于项目接入了二千多路摄像头，三十台机器集群，应项目的要求对程序项目进行压测，目标是测试到一台流媒体服务器能同时并发支撑多小路视频，从而推测整个集群的能力，也为以后的扩展。</p>\n<h2 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ul>\n<li><p>服务器1台</p>\n<p>配置：CPU 8核,内存 16G</p>\n</li>\n<li><p>客户端1台</p>\n<p>配置：CPU 8核,内存 16G</p>\n</li>\n<li>监控服务端工具nmon：</li>\n<li><p>压测工具：自研发的一款拉流工具，针对我们视频项目接口定制化开发</p>\n</li>\n<li><p>300个海康摄像头1920×1080P(可用正式环境)</p>\n</li>\n</ul>\n<h2 id=\"压测\"><a href=\"#压测\" class=\"headerlink\" title=\"压测\"></a>压测</h2><p>在压测的时候我认为需要清楚了解整个网络架构图，这样才能发现哪些地方存在的瓶颈，便于后期针对瓶颈地方进行压测。以下是我大致画出当时项目的网络环境：</p>\n<p><img src=\"/images/video/压测流程图.png\" alt=\"网络架构图\"></p>\n<p>经过分析，存在瓶颈：</p>\n<ol>\n<li>客户端自研拉流程序m1存在拉流的性能瓶颈</li>\n<li>流媒体北向的拉流分发能力m2的瓶颈</li>\n<li>流媒体南向的推流能力m3的瓶颈</li>\n<li>验证m4出口是否有千兆带宽</li>\n</ol>\n<h3 id=\"场景一\"><a href=\"#场景一\" class=\"headerlink\" title=\"场景一\"></a>场景一</h3><p>场景：多个用户，同时访问1路摄像头视频</p>\n<p>目的：测出单台流媒体服务北向分发能力m2的极限。</p>\n<p>为了减少自研发的客户端拉流程序瓶颈对本次压力测试造成影响，使用多个客户端进行拉流。  </p>\n<p><img src=\"/images/video/压测结果一.png\" alt=\"场景一\"></p>\n<p>结论：160个用户访问同一路摄像头视频时，系统能够稳定工作；北向并发能力达到160以上。</p>\n<h3 id=\"场景二\"><a href=\"#场景二\" class=\"headerlink\" title=\"场景二\"></a>场景二</h3><p>场景：两个客户端分别请求N路不同的视频，共请求2N路视频。每路视频1人观看。</p>\n<p>目的：测出单台流媒体服务南向m3能力的极限。</p>\n<p><img src=\"/images/video/压测结果二.png\" alt=\"场景二\"></p>\n<p>结论：南向并发处理80路摄像头视频时，系统能够稳定工作；南向并发处理100路摄像头视频时，网络出现较大波动；因此，单个流媒体服务的南向处理能力，为90路视频。</p>\n<h3 id=\"场景三\"><a href=\"#场景三\" class=\"headerlink\" title=\"场景三\"></a>场景三</h3><p>场景：两个客户端，分别请求两个不同的流媒体服务器；每个客户端请求N路视频，共请求2N路视频。</p>\n<p>目的：南向交换机性能瓶颈测试。</p>\n<p><img src=\"/images/video/压测结果三.png\" alt=\"场景三\"></p>\n<p>结论：单台客户端服务器最高可以处理南向70路视频，<br>单台流媒体服务器最多可处理南向90路视频。</p>\n<h3 id=\"场景四\"><a href=\"#场景四\" class=\"headerlink\" title=\"场景四\"></a>场景四</h3><p>场景：两个客户端，分别请求一台服务器上的两个流媒体服务；每个客户端请求N路视频，共请求2N路视频。</p>\n<p>目的：压测m4出口带宽是否达到千兆瓶颈</p>\n<p><img src=\"/images/video/压测结果四.png\" alt=\"场景四\"></p>\n<p>结论：当请求并发90路视频时，单台流媒体服务器系统能够稳定工作，当并发请求100路视频时，网络IO出现较大波动。因此，单台流媒体服务器南向摄像头最多只能处理90路视频</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实对于我来说，有幸参与了这次压测的整个过程，其中包括了跟项目组的沟通，跟第三方供应商技术交流等等。其实对于这类压测，最好能确认好控制单一要素，控制单一要素那就需要将每个步骤分层，然后将其余部分当作整体看待。举个例子，要想测试m3南向并发处理能力，那就将m3往下的部分当作整体，将其他没关要素降到影响最低（譬如客户端是瓶颈因素，那就水平扩展客户端），逐步增大压力，观察服务器等指标，如果出现一些业务报错或者其他问题往往就是触发到瓶颈，这个需要根据业务场景来定。由于我们这里偏向于IO密集型，所以一般都是观察网络IO主要是上下行带宽的指标为主。</p>\n"},{"title":"视频总览（必看）","date":"2021-07-27T03:16:39.000Z","_content":"\n## 总览图\n\n![视频总览图](/images/video/视频总览.png)\n\n## 说明\n\n上图是在视频开发组上将近一年多的开发经验累积的知识点，以便日后能快速预览。","source":"_posts/视频总览.md","raw":"---\ntitle: 视频总览（必看）\ndate: 2021-07-27 11:16:39\ncategories: \n- 视频\ntags:\n- 视频\n---\n\n## 总览图\n\n![视频总览图](/images/video/视频总览.png)\n\n## 说明\n\n上图是在视频开发组上将近一年多的开发经验累积的知识点，以便日后能快速预览。","slug":"视频总览","published":1,"updated":"2021-09-07T08:00:52.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhsb001pd0tvc95dgx6a","content":"<h2 id=\"总览图\"><a href=\"#总览图\" class=\"headerlink\" title=\"总览图\"></a>总览图</h2><p><img src=\"/images/video/视频总览.png\" alt=\"视频总览图\"></p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>上图是在视频开发组上将近一年多的开发经验累积的知识点，以便日后能快速预览。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"总览图\"><a href=\"#总览图\" class=\"headerlink\" title=\"总览图\"></a>总览图</h2><p><img src=\"/images/video/视频总览.png\" alt=\"视频总览图\"></p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>上图是在视频开发组上将近一年多的开发经验累积的知识点，以便日后能快速预览。</p>\n"},{"title":"选型视频网关","date":"2021-07-23T03:16:39.000Z","_content":"\n## 背景\n\n随着发展，视频网关也逐步完善，但后期也出现了越来越多的需求，譬如流控、鉴权、业务分发等功能。这些功能原本是直接放在视频网关上面，但是考虑到以后的易于维护、可扩展性、复用、避免代码臃肿、职责单一的问题，就将这部分功能单独抽到一个api网关上面。这样一来我们接下来首要的问题就是选型了。\n\n## 技术对比\n\n![网关选型对比](/images/video/网关选型图.png)\n\n网关说到底最重要的技术选性格是并发能力，以下是Gateway官网作者做了一个压测\n\n![image](/images/video/网关压测性能对比.png)\n\n\n这篇文章是我看了那么多对比做得比较清晰简单的一篇：[压测对比](https://www.edjdhbb.com/2018/12/16/%E7%BD%91%E5%85%B3%E9%80%89%E6%8B%A9%E5%9B%B0%E9%9A%BE%E7%97%87/)\n\n### 为什么选择SpringCloud Gateway\n\n选择Gateway，基于以下几点考虑：\n\n1. 维护成本\n\n虽然Kong的并发能力更高，但是Kong比较适合业务相对简单的网关，且公司大多都是JAVA技术人员，对于JAVA技术栈的系统来说维护起来比较困难。举个例子当业务复杂起来时，维护lua的脚本就会越来越多，因此引入一种新的技术栈成本是一个相对较高的事情。\n\n2. 接入快\n\n相比zuul1.x与Gateway，都是可以无缝对接到spring boot或spring cloud,但相比起来Gateway能支持websocket且并发的能力相对高于zuul，而zuul2.x在后续没有整合到spring上。重要一点是，接入到Gateway相对比较快，开发对应的Filter就能满足业务。\n\n3. 内置功能完善\n\nGateway自带了多种Filter和Router，对于开发一个简单的网关来说是完全足够。像限流之类功能也是需要的。\n\n\n\n## SpringCloud Gateway\n\n既然选择了Gateway,我们现在就简单介绍下Gateway的用法，以下是Gateway的框架图：\n\n![Gateway框架](/images/video/gateway网关图.png)\n\n可以看出其实Gateway的架构其实是非常简单。Gateway有几个概念：Route、Predicate与Filter\n\n**Route**\n网关配置的基本组成模块，和Zuul的路由配置模块类似。一个Route模块由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。\n\n\n**Predicate**\n\nPredicate是一个Java8的函数，输入类型是Spring的ServerWebExchange，允许匹配来自Http的任何内容，如请求头或者参数。\n\n![Predicate功能图](/images/video/gateway断言.png)\n\n\n**Filter**\n使用特定工厂构建的Spring GatewayFilter实例，可以在发生下游请求之前修改请求信息或者响应请求之后修改返回内容（这一点与Zuul的过滤器一致）。\n\n![Filter功能图](/images/video/gateway触发器.png)\n\n\n\n## 如何自定义开发Filter\n\n1. 继承AbstractGatewayFilterFactory默认的抽象类,并实现apply的方法\n\n```\n/**\n * @description: 替换服务地址过滤器\n * @author: lhj\n * @Date: 2021年1月16日 下午5:00:00\n */\n@SuppressWarnings({ \"rawtypes\" })\npublic class ProvideServiceGatewayFilterFactory extends AbstractGatewayFilterFactory {\n\tprivate static final Logger LOG = LoggerFactory.getLogger(ProvideServiceGatewayFilterFactory.class);\n\tprivate CrudService<RuleTransformEntity> ruleService;\n\tpublic ProvideServiceGatewayFilterFactory() {\n\t\tsuper();\n\t}\n\tpublic ProvideServiceGatewayFilterFactory(CrudService<RuleTransformEntity> ruleService) {\n\t\tsuper();\n\t\tthis.ruleService = ruleService;\n\t}\n\t@Override\n\tpublic GatewayFilter apply(Object config) {\n\t\treturn (exchange, chain) -> {\n\t\t\tSimpleRespTaskEntity taskEntity = exchange.getAttribute(WebExchangeUtils.RESP_BASE_TASK_ENTITY);\n\t\t\tNetworkNature networkNature = exchange.getAttribute(WebExchangeUtils.NETWORK_TYPE);\n\t\t\tObject startTime = exchange.getAttribute(WebExchangeUtils.START_MILLIS);\n\t\t\tMap<String, String> urls = taskEntity.getUrls();\n\t\t\turls.entrySet().forEach(entry -> {\n\t\t\t\tString schemaUrl = entry.getKey();\n\t\t\t\tString url = entry.getValue();\n\t\t\t\ttry {\n\t\t\t\t\tURI uri = URI.create(url);\n\t\t\t\t\tString path = uri.getPath();\n\t\t\t\t\tString key = url.substring(0, url.indexOf(path)) + \"-\" + networkNature;\n\t\t\t\t\tRuleTransformEntity transform = ruleService.get(key);\n\t\t\t\t\tLOG.info(\"key:{},transform:{}\",key,transform);\n\t\t\t\t\tif (!Objects.isNull(transform)) {\n\t\t\t\t\t\tString transformUrl = url.replace(transform.getSourcePrefix(), transform.getTargetPrefix());\n\t\t\t\t\t\turls.put(schemaUrl, transformUrl);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLOG.error(e.getMessage());\n\t\t\t\t}\n\t\t\t});\n\t\t\tLOG.info(\"transform urls:{},spends {} ms\", urls,\n\t\t\t\t\tSystem.currentTimeMillis() - Long.parseLong(startTime.toString()));\n\t\t\treturn WebfluxUtil.writeResponse(ResponseResult.fromData(taskEntity), exchange.getResponse());\n\t\t};\n\t}\n}\n```\n\n2. 将这个工厂注入到spring容器当中\n\n```\n@Bean\npublic ProvideServiceGatewayFilterFactory replaceServiceGatewayFilterFactory(CrudService<RuleTransformEntity> ruleTransformManagerService) {\n\treturn new ProvideServiceGatewayFilterFactory(ruleTransformManagerService);\n}\n```\n\n3. 配置yml文件\n\n```\n  cloud:\n    gateway:\n      routes:\n        - id: stream\n          uri: http://{server}/mag-cluster-server/\n          predicates:\n            - Path=/api/video/startTransform/**\n            - name: ReadBodyPredicateFactory \n              args:\n                inClass: \"#{T(String)}\"\n                predicate: \"#{@testRequestBody}\"\n          filters:\n            - ProvideService\n```\n\n## 参考\n1. [Gateway官方文档](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/)","source":"_posts/选型视频网关.md","raw":"---\ntitle: 选型视频网关\ndate: 2021-07-23 11:16:39\ncategories: \n- 视频\ntags:\n- 视频\n---\n\n## 背景\n\n随着发展，视频网关也逐步完善，但后期也出现了越来越多的需求，譬如流控、鉴权、业务分发等功能。这些功能原本是直接放在视频网关上面，但是考虑到以后的易于维护、可扩展性、复用、避免代码臃肿、职责单一的问题，就将这部分功能单独抽到一个api网关上面。这样一来我们接下来首要的问题就是选型了。\n\n## 技术对比\n\n![网关选型对比](/images/video/网关选型图.png)\n\n网关说到底最重要的技术选性格是并发能力，以下是Gateway官网作者做了一个压测\n\n![image](/images/video/网关压测性能对比.png)\n\n\n这篇文章是我看了那么多对比做得比较清晰简单的一篇：[压测对比](https://www.edjdhbb.com/2018/12/16/%E7%BD%91%E5%85%B3%E9%80%89%E6%8B%A9%E5%9B%B0%E9%9A%BE%E7%97%87/)\n\n### 为什么选择SpringCloud Gateway\n\n选择Gateway，基于以下几点考虑：\n\n1. 维护成本\n\n虽然Kong的并发能力更高，但是Kong比较适合业务相对简单的网关，且公司大多都是JAVA技术人员，对于JAVA技术栈的系统来说维护起来比较困难。举个例子当业务复杂起来时，维护lua的脚本就会越来越多，因此引入一种新的技术栈成本是一个相对较高的事情。\n\n2. 接入快\n\n相比zuul1.x与Gateway，都是可以无缝对接到spring boot或spring cloud,但相比起来Gateway能支持websocket且并发的能力相对高于zuul，而zuul2.x在后续没有整合到spring上。重要一点是，接入到Gateway相对比较快，开发对应的Filter就能满足业务。\n\n3. 内置功能完善\n\nGateway自带了多种Filter和Router，对于开发一个简单的网关来说是完全足够。像限流之类功能也是需要的。\n\n\n\n## SpringCloud Gateway\n\n既然选择了Gateway,我们现在就简单介绍下Gateway的用法，以下是Gateway的框架图：\n\n![Gateway框架](/images/video/gateway网关图.png)\n\n可以看出其实Gateway的架构其实是非常简单。Gateway有几个概念：Route、Predicate与Filter\n\n**Route**\n网关配置的基本组成模块，和Zuul的路由配置模块类似。一个Route模块由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。\n\n\n**Predicate**\n\nPredicate是一个Java8的函数，输入类型是Spring的ServerWebExchange，允许匹配来自Http的任何内容，如请求头或者参数。\n\n![Predicate功能图](/images/video/gateway断言.png)\n\n\n**Filter**\n使用特定工厂构建的Spring GatewayFilter实例，可以在发生下游请求之前修改请求信息或者响应请求之后修改返回内容（这一点与Zuul的过滤器一致）。\n\n![Filter功能图](/images/video/gateway触发器.png)\n\n\n\n## 如何自定义开发Filter\n\n1. 继承AbstractGatewayFilterFactory默认的抽象类,并实现apply的方法\n\n```\n/**\n * @description: 替换服务地址过滤器\n * @author: lhj\n * @Date: 2021年1月16日 下午5:00:00\n */\n@SuppressWarnings({ \"rawtypes\" })\npublic class ProvideServiceGatewayFilterFactory extends AbstractGatewayFilterFactory {\n\tprivate static final Logger LOG = LoggerFactory.getLogger(ProvideServiceGatewayFilterFactory.class);\n\tprivate CrudService<RuleTransformEntity> ruleService;\n\tpublic ProvideServiceGatewayFilterFactory() {\n\t\tsuper();\n\t}\n\tpublic ProvideServiceGatewayFilterFactory(CrudService<RuleTransformEntity> ruleService) {\n\t\tsuper();\n\t\tthis.ruleService = ruleService;\n\t}\n\t@Override\n\tpublic GatewayFilter apply(Object config) {\n\t\treturn (exchange, chain) -> {\n\t\t\tSimpleRespTaskEntity taskEntity = exchange.getAttribute(WebExchangeUtils.RESP_BASE_TASK_ENTITY);\n\t\t\tNetworkNature networkNature = exchange.getAttribute(WebExchangeUtils.NETWORK_TYPE);\n\t\t\tObject startTime = exchange.getAttribute(WebExchangeUtils.START_MILLIS);\n\t\t\tMap<String, String> urls = taskEntity.getUrls();\n\t\t\turls.entrySet().forEach(entry -> {\n\t\t\t\tString schemaUrl = entry.getKey();\n\t\t\t\tString url = entry.getValue();\n\t\t\t\ttry {\n\t\t\t\t\tURI uri = URI.create(url);\n\t\t\t\t\tString path = uri.getPath();\n\t\t\t\t\tString key = url.substring(0, url.indexOf(path)) + \"-\" + networkNature;\n\t\t\t\t\tRuleTransformEntity transform = ruleService.get(key);\n\t\t\t\t\tLOG.info(\"key:{},transform:{}\",key,transform);\n\t\t\t\t\tif (!Objects.isNull(transform)) {\n\t\t\t\t\t\tString transformUrl = url.replace(transform.getSourcePrefix(), transform.getTargetPrefix());\n\t\t\t\t\t\turls.put(schemaUrl, transformUrl);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLOG.error(e.getMessage());\n\t\t\t\t}\n\t\t\t});\n\t\t\tLOG.info(\"transform urls:{},spends {} ms\", urls,\n\t\t\t\t\tSystem.currentTimeMillis() - Long.parseLong(startTime.toString()));\n\t\t\treturn WebfluxUtil.writeResponse(ResponseResult.fromData(taskEntity), exchange.getResponse());\n\t\t};\n\t}\n}\n```\n\n2. 将这个工厂注入到spring容器当中\n\n```\n@Bean\npublic ProvideServiceGatewayFilterFactory replaceServiceGatewayFilterFactory(CrudService<RuleTransformEntity> ruleTransformManagerService) {\n\treturn new ProvideServiceGatewayFilterFactory(ruleTransformManagerService);\n}\n```\n\n3. 配置yml文件\n\n```\n  cloud:\n    gateway:\n      routes:\n        - id: stream\n          uri: http://{server}/mag-cluster-server/\n          predicates:\n            - Path=/api/video/startTransform/**\n            - name: ReadBodyPredicateFactory \n              args:\n                inClass: \"#{T(String)}\"\n                predicate: \"#{@testRequestBody}\"\n          filters:\n            - ProvideService\n```\n\n## 参考\n1. [Gateway官方文档](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/)","slug":"选型视频网关","published":1,"updated":"2021-09-07T08:00:52.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktb6mhsd001sd0tvdbrn4w9r","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着发展，视频网关也逐步完善，但后期也出现了越来越多的需求，譬如流控、鉴权、业务分发等功能。这些功能原本是直接放在视频网关上面，但是考虑到以后的易于维护、可扩展性、复用、避免代码臃肿、职责单一的问题，就将这部分功能单独抽到一个api网关上面。这样一来我们接下来首要的问题就是选型了。</p>\n<h2 id=\"技术对比\"><a href=\"#技术对比\" class=\"headerlink\" title=\"技术对比\"></a>技术对比</h2><p><img src=\"/images/video/网关选型图.png\" alt=\"网关选型对比\"></p>\n<p>网关说到底最重要的技术选性格是并发能力，以下是Gateway官网作者做了一个压测</p>\n<p><img src=\"/images/video/网关压测性能对比.png\" alt=\"image\"></p>\n<p>这篇文章是我看了那么多对比做得比较清晰简单的一篇：<a href=\"https://www.edjdhbb.com/2018/12/16/%E7%BD%91%E5%85%B3%E9%80%89%E6%8B%A9%E5%9B%B0%E9%9A%BE%E7%97%87/\" target=\"_blank\" rel=\"noopener\">压测对比</a></p>\n<h3 id=\"为什么选择SpringCloud-Gateway\"><a href=\"#为什么选择SpringCloud-Gateway\" class=\"headerlink\" title=\"为什么选择SpringCloud Gateway\"></a>为什么选择SpringCloud Gateway</h3><p>选择Gateway，基于以下几点考虑：</p>\n<ol>\n<li>维护成本</li>\n</ol>\n<p>虽然Kong的并发能力更高，但是Kong比较适合业务相对简单的网关，且公司大多都是JAVA技术人员，对于JAVA技术栈的系统来说维护起来比较困难。举个例子当业务复杂起来时，维护lua的脚本就会越来越多，因此引入一种新的技术栈成本是一个相对较高的事情。</p>\n<ol>\n<li>接入快</li>\n</ol>\n<p>相比zuul1.x与Gateway，都是可以无缝对接到spring boot或spring cloud,但相比起来Gateway能支持websocket且并发的能力相对高于zuul，而zuul2.x在后续没有整合到spring上。重要一点是，接入到Gateway相对比较快，开发对应的Filter就能满足业务。</p>\n<ol>\n<li>内置功能完善</li>\n</ol>\n<p>Gateway自带了多种Filter和Router，对于开发一个简单的网关来说是完全足够。像限流之类功能也是需要的。</p>\n<h2 id=\"SpringCloud-Gateway\"><a href=\"#SpringCloud-Gateway\" class=\"headerlink\" title=\"SpringCloud Gateway\"></a>SpringCloud Gateway</h2><p>既然选择了Gateway,我们现在就简单介绍下Gateway的用法，以下是Gateway的框架图：</p>\n<p><img src=\"/images/video/gateway网关图.png\" alt=\"Gateway框架\"></p>\n<p>可以看出其实Gateway的架构其实是非常简单。Gateway有几个概念：Route、Predicate与Filter</p>\n<p><strong>Route</strong><br>网关配置的基本组成模块，和Zuul的路由配置模块类似。一个Route模块由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。</p>\n<p><strong>Predicate</strong></p>\n<p>Predicate是一个Java8的函数，输入类型是Spring的ServerWebExchange，允许匹配来自Http的任何内容，如请求头或者参数。</p>\n<p><img src=\"/images/video/gateway断言.png\" alt=\"Predicate功能图\"></p>\n<p><strong>Filter</strong><br>使用特定工厂构建的Spring GatewayFilter实例，可以在发生下游请求之前修改请求信息或者响应请求之后修改返回内容（这一点与Zuul的过滤器一致）。</p>\n<p><img src=\"/images/video/gateway触发器.png\" alt=\"Filter功能图\"></p>\n<h2 id=\"如何自定义开发Filter\"><a href=\"#如何自定义开发Filter\" class=\"headerlink\" title=\"如何自定义开发Filter\"></a>如何自定义开发Filter</h2><ol>\n<li>继承AbstractGatewayFilterFactory默认的抽象类,并实现apply的方法</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @description: 替换服务地址过滤器</span><br><span class=\"line\"> * @author: lhj</span><br><span class=\"line\"> * @Date: 2021年1月16日 下午5:00:00</span><br><span class=\"line\"> */</span><br><span class=\"line\">@SuppressWarnings(&#123; &quot;rawtypes&quot; &#125;)</span><br><span class=\"line\">public class ProvideServiceGatewayFilterFactory extends AbstractGatewayFilterFactory &#123;</span><br><span class=\"line\">\tprivate static final Logger LOG = LoggerFactory.getLogger(ProvideServiceGatewayFilterFactory.class);</span><br><span class=\"line\">\tprivate CrudService&lt;RuleTransformEntity&gt; ruleService;</span><br><span class=\"line\">\tpublic ProvideServiceGatewayFilterFactory() &#123;</span><br><span class=\"line\">\t\tsuper();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic ProvideServiceGatewayFilterFactory(CrudService&lt;RuleTransformEntity&gt; ruleService) &#123;</span><br><span class=\"line\">\t\tsuper();</span><br><span class=\"line\">\t\tthis.ruleService = ruleService;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic GatewayFilter apply(Object config) &#123;</span><br><span class=\"line\">\t\treturn (exchange, chain) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSimpleRespTaskEntity taskEntity = exchange.getAttribute(WebExchangeUtils.RESP_BASE_TASK_ENTITY);</span><br><span class=\"line\">\t\t\tNetworkNature networkNature = exchange.getAttribute(WebExchangeUtils.NETWORK_TYPE);</span><br><span class=\"line\">\t\t\tObject startTime = exchange.getAttribute(WebExchangeUtils.START_MILLIS);</span><br><span class=\"line\">\t\t\tMap&lt;String, String&gt; urls = taskEntity.getUrls();</span><br><span class=\"line\">\t\t\turls.entrySet().forEach(entry -&gt; &#123;</span><br><span class=\"line\">\t\t\t\tString schemaUrl = entry.getKey();</span><br><span class=\"line\">\t\t\t\tString url = entry.getValue();</span><br><span class=\"line\">\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\tURI uri = URI.create(url);</span><br><span class=\"line\">\t\t\t\t\tString path = uri.getPath();</span><br><span class=\"line\">\t\t\t\t\tString key = url.substring(0, url.indexOf(path)) + &quot;-&quot; + networkNature;</span><br><span class=\"line\">\t\t\t\t\tRuleTransformEntity transform = ruleService.get(key);</span><br><span class=\"line\">\t\t\t\t\tLOG.info(&quot;key:&#123;&#125;,transform:&#123;&#125;&quot;,key,transform);</span><br><span class=\"line\">\t\t\t\t\tif (!Objects.isNull(transform)) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tString transformUrl = url.replace(transform.getSourcePrefix(), transform.getTargetPrefix());</span><br><span class=\"line\">\t\t\t\t\t\turls.put(schemaUrl, transformUrl);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\t\tLOG.error(e.getMessage());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\tLOG.info(&quot;transform urls:&#123;&#125;,spends &#123;&#125; ms&quot;, urls,</span><br><span class=\"line\">\t\t\t\t\tSystem.currentTimeMillis() - Long.parseLong(startTime.toString()));</span><br><span class=\"line\">\t\t\treturn WebfluxUtil.writeResponse(ResponseResult.fromData(taskEntity), exchange.getResponse());</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将这个工厂注入到spring容器当中</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public ProvideServiceGatewayFilterFactory replaceServiceGatewayFilterFactory(CrudService&lt;RuleTransformEntity&gt; ruleTransformManagerService) &#123;</span><br><span class=\"line\">\treturn new ProvideServiceGatewayFilterFactory(ruleTransformManagerService);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>配置yml文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cloud:</span><br><span class=\"line\">  gateway:</span><br><span class=\"line\">    routes:</span><br><span class=\"line\">      - id: stream</span><br><span class=\"line\">        uri: http://&#123;server&#125;/mag-cluster-server/</span><br><span class=\"line\">        predicates:</span><br><span class=\"line\">          - Path=/api/video/startTransform/**</span><br><span class=\"line\">          - name: ReadBodyPredicateFactory </span><br><span class=\"line\">            args:</span><br><span class=\"line\">              inClass: &quot;#&#123;T(String)&#125;&quot;</span><br><span class=\"line\">              predicate: &quot;#&#123;@testRequestBody&#125;&quot;</span><br><span class=\"line\">        filters:</span><br><span class=\"line\">          - ProvideService</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/\" target=\"_blank\" rel=\"noopener\">Gateway官方文档</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着发展，视频网关也逐步完善，但后期也出现了越来越多的需求，譬如流控、鉴权、业务分发等功能。这些功能原本是直接放在视频网关上面，但是考虑到以后的易于维护、可扩展性、复用、避免代码臃肿、职责单一的问题，就将这部分功能单独抽到一个api网关上面。这样一来我们接下来首要的问题就是选型了。</p>\n<h2 id=\"技术对比\"><a href=\"#技术对比\" class=\"headerlink\" title=\"技术对比\"></a>技术对比</h2><p><img src=\"/images/video/网关选型图.png\" alt=\"网关选型对比\"></p>\n<p>网关说到底最重要的技术选性格是并发能力，以下是Gateway官网作者做了一个压测</p>\n<p><img src=\"/images/video/网关压测性能对比.png\" alt=\"image\"></p>\n<p>这篇文章是我看了那么多对比做得比较清晰简单的一篇：<a href=\"https://www.edjdhbb.com/2018/12/16/%E7%BD%91%E5%85%B3%E9%80%89%E6%8B%A9%E5%9B%B0%E9%9A%BE%E7%97%87/\" target=\"_blank\" rel=\"noopener\">压测对比</a></p>\n<h3 id=\"为什么选择SpringCloud-Gateway\"><a href=\"#为什么选择SpringCloud-Gateway\" class=\"headerlink\" title=\"为什么选择SpringCloud Gateway\"></a>为什么选择SpringCloud Gateway</h3><p>选择Gateway，基于以下几点考虑：</p>\n<ol>\n<li>维护成本</li>\n</ol>\n<p>虽然Kong的并发能力更高，但是Kong比较适合业务相对简单的网关，且公司大多都是JAVA技术人员，对于JAVA技术栈的系统来说维护起来比较困难。举个例子当业务复杂起来时，维护lua的脚本就会越来越多，因此引入一种新的技术栈成本是一个相对较高的事情。</p>\n<ol>\n<li>接入快</li>\n</ol>\n<p>相比zuul1.x与Gateway，都是可以无缝对接到spring boot或spring cloud,但相比起来Gateway能支持websocket且并发的能力相对高于zuul，而zuul2.x在后续没有整合到spring上。重要一点是，接入到Gateway相对比较快，开发对应的Filter就能满足业务。</p>\n<ol>\n<li>内置功能完善</li>\n</ol>\n<p>Gateway自带了多种Filter和Router，对于开发一个简单的网关来说是完全足够。像限流之类功能也是需要的。</p>\n<h2 id=\"SpringCloud-Gateway\"><a href=\"#SpringCloud-Gateway\" class=\"headerlink\" title=\"SpringCloud Gateway\"></a>SpringCloud Gateway</h2><p>既然选择了Gateway,我们现在就简单介绍下Gateway的用法，以下是Gateway的框架图：</p>\n<p><img src=\"/images/video/gateway网关图.png\" alt=\"Gateway框架\"></p>\n<p>可以看出其实Gateway的架构其实是非常简单。Gateway有几个概念：Route、Predicate与Filter</p>\n<p><strong>Route</strong><br>网关配置的基本组成模块，和Zuul的路由配置模块类似。一个Route模块由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。</p>\n<p><strong>Predicate</strong></p>\n<p>Predicate是一个Java8的函数，输入类型是Spring的ServerWebExchange，允许匹配来自Http的任何内容，如请求头或者参数。</p>\n<p><img src=\"/images/video/gateway断言.png\" alt=\"Predicate功能图\"></p>\n<p><strong>Filter</strong><br>使用特定工厂构建的Spring GatewayFilter实例，可以在发生下游请求之前修改请求信息或者响应请求之后修改返回内容（这一点与Zuul的过滤器一致）。</p>\n<p><img src=\"/images/video/gateway触发器.png\" alt=\"Filter功能图\"></p>\n<h2 id=\"如何自定义开发Filter\"><a href=\"#如何自定义开发Filter\" class=\"headerlink\" title=\"如何自定义开发Filter\"></a>如何自定义开发Filter</h2><ol>\n<li>继承AbstractGatewayFilterFactory默认的抽象类,并实现apply的方法</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @description: 替换服务地址过滤器</span><br><span class=\"line\"> * @author: lhj</span><br><span class=\"line\"> * @Date: 2021年1月16日 下午5:00:00</span><br><span class=\"line\"> */</span><br><span class=\"line\">@SuppressWarnings(&#123; &quot;rawtypes&quot; &#125;)</span><br><span class=\"line\">public class ProvideServiceGatewayFilterFactory extends AbstractGatewayFilterFactory &#123;</span><br><span class=\"line\">\tprivate static final Logger LOG = LoggerFactory.getLogger(ProvideServiceGatewayFilterFactory.class);</span><br><span class=\"line\">\tprivate CrudService&lt;RuleTransformEntity&gt; ruleService;</span><br><span class=\"line\">\tpublic ProvideServiceGatewayFilterFactory() &#123;</span><br><span class=\"line\">\t\tsuper();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic ProvideServiceGatewayFilterFactory(CrudService&lt;RuleTransformEntity&gt; ruleService) &#123;</span><br><span class=\"line\">\t\tsuper();</span><br><span class=\"line\">\t\tthis.ruleService = ruleService;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic GatewayFilter apply(Object config) &#123;</span><br><span class=\"line\">\t\treturn (exchange, chain) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSimpleRespTaskEntity taskEntity = exchange.getAttribute(WebExchangeUtils.RESP_BASE_TASK_ENTITY);</span><br><span class=\"line\">\t\t\tNetworkNature networkNature = exchange.getAttribute(WebExchangeUtils.NETWORK_TYPE);</span><br><span class=\"line\">\t\t\tObject startTime = exchange.getAttribute(WebExchangeUtils.START_MILLIS);</span><br><span class=\"line\">\t\t\tMap&lt;String, String&gt; urls = taskEntity.getUrls();</span><br><span class=\"line\">\t\t\turls.entrySet().forEach(entry -&gt; &#123;</span><br><span class=\"line\">\t\t\t\tString schemaUrl = entry.getKey();</span><br><span class=\"line\">\t\t\t\tString url = entry.getValue();</span><br><span class=\"line\">\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\tURI uri = URI.create(url);</span><br><span class=\"line\">\t\t\t\t\tString path = uri.getPath();</span><br><span class=\"line\">\t\t\t\t\tString key = url.substring(0, url.indexOf(path)) + &quot;-&quot; + networkNature;</span><br><span class=\"line\">\t\t\t\t\tRuleTransformEntity transform = ruleService.get(key);</span><br><span class=\"line\">\t\t\t\t\tLOG.info(&quot;key:&#123;&#125;,transform:&#123;&#125;&quot;,key,transform);</span><br><span class=\"line\">\t\t\t\t\tif (!Objects.isNull(transform)) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tString transformUrl = url.replace(transform.getSourcePrefix(), transform.getTargetPrefix());</span><br><span class=\"line\">\t\t\t\t\t\turls.put(schemaUrl, transformUrl);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\t\t\tLOG.error(e.getMessage());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\tLOG.info(&quot;transform urls:&#123;&#125;,spends &#123;&#125; ms&quot;, urls,</span><br><span class=\"line\">\t\t\t\t\tSystem.currentTimeMillis() - Long.parseLong(startTime.toString()));</span><br><span class=\"line\">\t\t\treturn WebfluxUtil.writeResponse(ResponseResult.fromData(taskEntity), exchange.getResponse());</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将这个工厂注入到spring容器当中</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public ProvideServiceGatewayFilterFactory replaceServiceGatewayFilterFactory(CrudService&lt;RuleTransformEntity&gt; ruleTransformManagerService) &#123;</span><br><span class=\"line\">\treturn new ProvideServiceGatewayFilterFactory(ruleTransformManagerService);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>配置yml文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cloud:</span><br><span class=\"line\">  gateway:</span><br><span class=\"line\">    routes:</span><br><span class=\"line\">      - id: stream</span><br><span class=\"line\">        uri: http://&#123;server&#125;/mag-cluster-server/</span><br><span class=\"line\">        predicates:</span><br><span class=\"line\">          - Path=/api/video/startTransform/**</span><br><span class=\"line\">          - name: ReadBodyPredicateFactory </span><br><span class=\"line\">            args:</span><br><span class=\"line\">              inClass: &quot;#&#123;T(String)&#125;&quot;</span><br><span class=\"line\">              predicate: &quot;#&#123;@testRequestBody&#125;&quot;</span><br><span class=\"line\">        filters:</span><br><span class=\"line\">          - ProvideService</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/\" target=\"_blank\" rel=\"noopener\">Gateway官方文档</a></li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cktb6mhra0008d0tvdg5q9lxo","category_id":"cktb6mhr50004d0tvaohqu4e9","_id":"cktb6mhrg000gd0tvdpf39s5d"},{"post_id":"cktb6mhqu0000d0tvv4kg0b7s","category_id":"cktb6mhr50004d0tvaohqu4e9","_id":"cktb6mhrm000kd0tv7hkf56rg"},{"post_id":"cktb6mhr10002d0tvjt7ixrtj","category_id":"cktb6mhrc000ad0tv59r8iehf","_id":"cktb6mhrq000pd0tvstk2u4ig"},{"post_id":"cktb6mhrg000fd0tvktltqsk6","category_id":"cktb6mhrc000ad0tv59r8iehf","_id":"cktb6mhrs000td0tv8yn9xjga"},{"post_id":"cktb6mhrl000jd0tv22qkmemr","category_id":"cktb6mhrc000ad0tv59r8iehf","_id":"cktb6mhru000wd0tv9dhxo73s"},{"post_id":"cktb6mhr80006d0tvuil4okos","category_id":"cktb6mhr50004d0tvaohqu4e9","_id":"cktb6mhrx0010d0tvxv5n9y9z"},{"post_id":"cktb6mhrb0009d0tvjka9ib8g","category_id":"cktb6mhrq000od0tvsr5oz6cu","_id":"cktb6mhrz0014d0tvs0mgrpaa"},{"post_id":"cktb6mhrt000ud0tvjtxj9t7x","category_id":"cktb6mhr50004d0tvaohqu4e9","_id":"cktb6mhs10019d0tv4mwld226"},{"post_id":"cktb6mhrw000zd0tvjg36o3sp","category_id":"cktb6mhr50004d0tvaohqu4e9","_id":"cktb6mhs3001cd0tvv7v1qzo0"},{"post_id":"cktb6mhrd000dd0tvfglkon3m","category_id":"cktb6mhrv000xd0tv1itc2uea","_id":"cktb6mhs6001hd0tvphrk4qye"},{"post_id":"cktb6mhs2001ad0tvexm08ahw","category_id":"cktb6mhrc000ad0tv59r8iehf","_id":"cktb6mhsa001md0tvr69jrnm1"},{"post_id":"cktb6mhro000md0tvzqoyedst","category_id":"cktb6mhrz0016d0tvrmgqswta","_id":"cktb6mhsc001qd0tvfk8cb57v"},{"post_id":"cktb6mhs4001ed0tvg15ivsvz","category_id":"cktb6mhr50004d0tvaohqu4e9","_id":"cktb6mhse001td0tvqqibeufc"},{"post_id":"cktb6mhs7001id0tv14jtco0p","category_id":"cktb6mhr50004d0tvaohqu4e9","_id":"cktb6mhsf001wd0tvynix4u8y"},{"post_id":"cktb6mhrr000rd0tv1732ls6x","category_id":"cktb6mhrz0016d0tvrmgqswta","_id":"cktb6mhsg001yd0tv179ssfgm"},{"post_id":"cktb6mhs9001ld0tvwjliyvlj","category_id":"cktb6mhr50004d0tvaohqu4e9","_id":"cktb6mhsh0021d0tvq8opo0a6"},{"post_id":"cktb6mhsb001pd0tvc95dgx6a","category_id":"cktb6mhr50004d0tvaohqu4e9","_id":"cktb6mhsi0023d0tv82jt870v"},{"post_id":"cktb6mhsd001sd0tvdbrn4w9r","category_id":"cktb6mhr50004d0tvaohqu4e9","_id":"cktb6mhsj0025d0tv35ab809r"},{"post_id":"cktb6mhs00017d0tvsavqk7aa","category_id":"cktb6mhse001ud0tv88bxfus4","_id":"cktb6mhsk0027d0tvi6mms07p"},{"post_id":"cktb6mhry0012d0tv2plskops","category_id":"cktb6mhsa001nd0tv64y9kgex","_id":"cktb6mhsl0028d0tvg29s0u2g"},{"post_id":"cktb6mhry0012d0tv2plskops","category_id":"cktb6mhsg0020d0tvbn9fthis","_id":"cktb6mhsm0029d0tvxmozu19k"}],"PostTag":[{"post_id":"cktb6mhra0008d0tvdg5q9lxo","tag_id":"cktb6mhr70005d0tv6zuwsbho","_id":"cktb6mhrd000cd0tvmh6qlx4i"},{"post_id":"cktb6mhqu0000d0tvv4kg0b7s","tag_id":"cktb6mhr70005d0tv6zuwsbho","_id":"cktb6mhrf000ed0tvngcqnalh"},{"post_id":"cktb6mhr10002d0tvjt7ixrtj","tag_id":"cktb6mhrc000bd0tvnds3bihy","_id":"cktb6mhrn000ld0tv9ded2ef4"},{"post_id":"cktb6mhrg000fd0tvktltqsk6","tag_id":"cktb6mhrc000bd0tvnds3bihy","_id":"cktb6mhrp000nd0tvl99ikzx8"},{"post_id":"cktb6mhrl000jd0tv22qkmemr","tag_id":"cktb6mhrc000bd0tvnds3bihy","_id":"cktb6mhrs000sd0tvoa8r2fhr"},{"post_id":"cktb6mhr80006d0tvuil4okos","tag_id":"cktb6mhr70005d0tv6zuwsbho","_id":"cktb6mhru000vd0tvvz1wnelq"},{"post_id":"cktb6mhrb0009d0tvjka9ib8g","tag_id":"cktb6mhrq000qd0tvp96xtahg","_id":"cktb6mhrx0011d0tv79ct4p6b"},{"post_id":"cktb6mhrt000ud0tvjtxj9t7x","tag_id":"cktb6mhr70005d0tv6zuwsbho","_id":"cktb6mhrz0013d0tvtghsnsxr"},{"post_id":"cktb6mhrw000zd0tvjg36o3sp","tag_id":"cktb6mhr70005d0tv6zuwsbho","_id":"cktb6mhs10018d0tvo6vwh5q1"},{"post_id":"cktb6mhrd000dd0tvfglkon3m","tag_id":"cktb6mhrq000qd0tvp96xtahg","_id":"cktb6mhs3001bd0tv0yaslzyn"},{"post_id":"cktb6mhs00017d0tvsavqk7aa","tag_id":"cktb6mhrq000qd0tvp96xtahg","_id":"cktb6mhs6001gd0tvtfkj9fv0"},{"post_id":"cktb6mhro000md0tvzqoyedst","tag_id":"cktb6mhrz0015d0tvfwq8kdmf","_id":"cktb6mhs8001jd0tvzjnng1f9"},{"post_id":"cktb6mhs2001ad0tvexm08ahw","tag_id":"cktb6mhrc000bd0tvnds3bihy","_id":"cktb6mhsa001od0tv6s8p2hkj"},{"post_id":"cktb6mhs4001ed0tvg15ivsvz","tag_id":"cktb6mhr70005d0tv6zuwsbho","_id":"cktb6mhsc001rd0tvkg6yo2pk"},{"post_id":"cktb6mhrr000rd0tv1732ls6x","tag_id":"cktb6mhrz0015d0tvfwq8kdmf","_id":"cktb6mhse001vd0tvguwm1ba0"},{"post_id":"cktb6mhs7001id0tv14jtco0p","tag_id":"cktb6mhr70005d0tv6zuwsbho","_id":"cktb6mhsf001xd0tvjeefdzur"},{"post_id":"cktb6mhs9001ld0tvwjliyvlj","tag_id":"cktb6mhr70005d0tv6zuwsbho","_id":"cktb6mhsg001zd0tvt8ncw87f"},{"post_id":"cktb6mhsb001pd0tvc95dgx6a","tag_id":"cktb6mhr70005d0tv6zuwsbho","_id":"cktb6mhsh0022d0tvoeqj4t2q"},{"post_id":"cktb6mhry0012d0tv2plskops","tag_id":"cktb6mhs8001kd0tvpkzenyv4","_id":"cktb6mhsi0024d0tvym0smsl2"},{"post_id":"cktb6mhsd001sd0tvdbrn4w9r","tag_id":"cktb6mhr70005d0tv6zuwsbho","_id":"cktb6mhsk0026d0tve2fy887m"}],"Tag":[{"name":"视频","_id":"cktb6mhr70005d0tv6zuwsbho"},{"name":"大数据","_id":"cktb6mhrc000bd0tvnds3bihy"},{"name":"笔记","_id":"cktb6mhrq000qd0tvp96xtahg"},{"name":"总结","_id":"cktb6mhrz0015d0tvfwq8kdmf"},{"name":"书籍篇","_id":"cktb6mhs8001kd0tvpkzenyv4"}]}}