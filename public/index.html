<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="小小的天，大大的梦">
<meta property="og:type" content="website">
<meta property="og:title" content="Jay-Luo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jay-Luo">
<meta property="og:description" content="小小的天，大大的梦">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jay-Luo">
<meta name="twitter:description" content="小小的天，大大的梦">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Jay-Luo</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bc6214a71594310d314698ac546aca76";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jay-Luo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小小的天，大大的梦</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/27/spark sql学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/27/spark sql学习/" itemprop="url">Spark Sql基础知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-27T11:16:39+08:00">
                2021-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spark-Sql基础知识点"><a href="#Spark-Sql基础知识点" class="headerlink" title="Spark Sql基础知识点"></a>Spark Sql基础知识点</h1><h2 id="Spark-Sql-总体图"><a href="#Spark-Sql-总体图" class="headerlink" title="Spark Sql 总体图"></a>Spark Sql 总体图</h2><p><img src="/images/bdata/spark-sql.png" alt="spark-sql"></p>
<h2 id="Spark-Sql-功能图"><a href="#Spark-Sql-功能图" class="headerlink" title="Spark Sql 功能图"></a>Spark Sql 功能图</h2><h2 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h2><p>DataSet概念：<br>DataSet代表被分配的数据集合</p>
<p>DataFrame概念：<br>DataFrame是dataSet组织的列名集合。可看作是关系数据库的二维数据表，但相比于此，更具有丰富优化。它可从多个数据源构建，如hive tables、已有RDD、文件等</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为什么要使用Spark Sql？Hive Sql不是能够足够支持？</p>
<p>因为Hive中底层执行sql是需要转化成mapreduce程序来执行，众所周知，mapreduce的程序计算模型效率相对比较慢，而且程序的复杂性会相对比较高。因此，Spark Sql能有效解决这个问题，因为是RDD执行效率会更快。</p>
<h2 id="demo例子"><a href="#demo例子" class="headerlink" title="demo例子"></a>demo例子</h2><p>1.读取json文件demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"default"</span>).setMaster(<span class="string">"local"</span>);<span class="comment">//.setJars(jars);</span></span><br><span class="line">        conf.set(<span class="string">"spark.executor.memory"</span>, <span class="string">"512m"</span>);</span><br><span class="line">        conf.set(<span class="string">"spark.executor.cores"</span>, <span class="string">"1"</span>);</span><br><span class="line">        sc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建spark session</span></span><br><span class="line">        SparkSession spark = SparkSession</span><br><span class="line">        		  .builder()</span><br><span class="line">        		  .appName(<span class="string">"Java Spark SQL basic example"</span>)</span><br><span class="line">        		  .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">        		  .getOrCreate();</span><br><span class="line">		</span><br><span class="line">		Dataset&lt;Row&gt; df = spark.read().json(<span class="string">"./src/main/java/org/jay/spark/areaInfo.json"</span>);</span><br><span class="line"></span><br><span class="line">		Dataset&lt;Row&gt; df2 = df.select(<span class="string">"address"</span>);</span><br><span class="line">		</span><br><span class="line">		df2.show();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//输出schema</span></span><br><span class="line">		df.printSchema();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Register the DataFrame as a SQL temporary view</span></span><br><span class="line">		df.createOrReplaceTempView(<span class="string">"people"</span>);</span><br><span class="line">		Dataset&lt;Row&gt; namesDF = spark.sql(<span class="string">"SELECT address.city FROM people"</span>);		</span><br><span class="line">		<span class="comment">//数据输出</span></span><br><span class="line">		namesDF.show();</span><br></pre></td></tr></table></figure></p>
<p>2.创建schema的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"default"</span>).setMaster(<span class="string">"local"</span>);<span class="comment">//.setJars(jars);</span></span><br><span class="line">        conf.set(<span class="string">"spark.executor.memory"</span>, <span class="string">"512m"</span>);</span><br><span class="line">        conf.set(<span class="string">"spark.executor.cores"</span>, <span class="string">"1"</span>);</span><br><span class="line">        sc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建spark session</span></span><br><span class="line">        SparkSession spark = SparkSession</span><br><span class="line">        		  .builder()</span><br><span class="line">        		  .appName(<span class="string">"Java Spark SQL basic example"</span>)</span><br><span class="line">        		  .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">        		  .getOrCreate();</span><br><span class="line">		</span><br><span class="line">        </span><br><span class="line">        JavaRDD&lt;HostBean&gt; rdd = spark.read().text(<span class="string">"./src/main/java/org/jay/spark/itcast.log"</span>).javaRDD().map(<span class="keyword">new</span> Function&lt;Row, HostBean&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> HostBean <span class="title">call</span><span class="params">(Row v1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				String line = v1.toString();</span><br><span class="line">				String[] strs = line.split(<span class="string">"\t"</span>);</span><br><span class="line">				HostBean bean = <span class="keyword">new</span> HostBean();</span><br><span class="line">				bean.setHost(strs[<span class="number">1</span>]);</span><br><span class="line">				bean.setTime(strs[<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">return</span> bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建schema</span></span><br><span class="line">        List&lt;StructField&gt; fields = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String fieldName : <span class="string">"time host"</span>.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">          StructField field = DataTypes.createStructField(fieldName, DataTypes.StringType, <span class="keyword">true</span>);</span><br><span class="line">          fields.add(field);</span><br><span class="line">        &#125;</span><br><span class="line">        StructType schema = DataTypes.createStructType(fields);</span><br><span class="line">        <span class="comment">//将rdd转为row</span></span><br><span class="line">        JavaRDD&lt;Row&gt; rowRDD = rdd.map((Function&lt;HostBean, Row&gt;) record -&gt; &#123;</span><br><span class="line">        	  <span class="keyword">return</span> RowFactory.create(record.getTime(), record.getHost());</span><br><span class="line">        	&#125;);</span><br><span class="line">        <span class="comment">//创建df</span></span><br><span class="line">        Dataset&lt;Row&gt; df = spark.createDataFrame(rowRDD,schema);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Dataset&lt;Row&gt; df = spark.createDataFrame(rdd, HostBean.class);</span></span><br><span class="line">        </span><br><span class="line">        df.createOrReplaceTempView(<span class="string">"test"</span>);</span><br><span class="line">        </span><br><span class="line">        Dataset&lt;Row&gt; host = spark.sql(<span class="string">"SELECT name FROM test"</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p>1.<a href="http://spark.apache.org/sql/" target="_blank" rel="noopener">Spark Sql</a></p>
<p>2.<a href="http://spark.apache.org/docs/latest/sql-programming-guide.html" target="_blank" rel="noopener">Spark Sql Guide</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/27/spark streaming学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/27/spark streaming学习/" itemprop="url">Spark Streaming基础知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-27T11:16:39+08:00">
                2021-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spark-Streaming基础知识点"><a href="#Spark-Streaming基础知识点" class="headerlink" title="Spark Streaming基础知识点"></a>Spark Streaming基础知识点</h1><h2 id="Spark-Streaming-功能图"><a href="#Spark-Streaming-功能图" class="headerlink" title="Spark Streaming 功能图"></a>Spark Streaming 功能图</h2><h2 id="Spark-Streaming-特性"><a href="#Spark-Streaming-特性" class="headerlink" title="Spark Streaming 特性"></a>Spark Streaming 特性</h2><ol>
<li>易用：能够通过API创建应用</li>
<li>容错：自身能够恢复丢失的操作或者工作的状态</li>
<li>易整合到spark体系中</li>
</ol>
<h2 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h2><ul>
<li><p>DStream概念：DStream是基础抽象,代表了持续性的流式数据。在内部实现上，DStream表示一系列连续的RDD</p>
</li>
<li><p>DStream相关操作(参照官网)</p>
</li>
</ul>
<p>DStream的Transformations<br>名称 | 功能<br>—|—<br>map（func） | Return a new DStream by passing each element of the source DStream through a function func.<br>flatMap(func) | Similar to map, but each input item can be mapped to 0 or more output items.<br>filter(func) | Return a new DStream by selecting only the records of the source DStream on which func returns true.<br>repartition(numPartitions) | Changes the level of parallelism in this DStream by creating more or fewer partitions.<br>union(otherStream) | Return a new DStream that contains the union of the elements in the source DStream and otherDStream.<br>count() | Return a new DStream of single-element RDDs by counting the number of elements in each RDD of the source DStream.<br>reduce(func) | Return a new DStream of single-element RDDs by aggregating the elements in each RDD of the source DStream using a function func (which takes two arguments and returns one). The function should be associative so that it can be computed in parallel.<br>countByValue() | When called on a DStream of elements of type K, return a new DStream of (K, Long) pairs where the value of each key is its frequency in each RDD of the source DStream.<br>reduceByKey(func, [numTasks]) | When called on a DStream of (K, V) pairs, return a new DStream of (K, V) pairs where the values for each key are aggregated using the given reduce function. Note: By default, this uses Spark’s default number of parallel tasks (2 for local mode, and in cluster mode the number is determined by the config property spark.default.parallelism) to do the grouping. You can pass an optional numTasks argument to set a different number of tasks.<br>join(otherStream, [numTasks]) | When called on two DStreams of (K, V) and (K, W) pairs, return a new DStream of (K, (V, W)) pairs with all pairs of elements for each key.<br>cogroup(otherStream, [numTasks]) | When called on a DStream of (K, V) and (K, W) pairs, return a new DStream of (K, Seq[V], Seq[W]) tuples.<br>transform(func) | Return a new DStream by applying a RDD-to-RDD function to every RDD of the source DStream. This can be used to do arbitrary RDD operations on the DStream.<br>updateStateByKey(func) | Return a new “state” DStream where the state for each key is updated by applying the given function on the previous state of the key and the new values for the key. This can be used to maintain arbitrary state data for each key.</p>
<p>主要讲解常用Operation</p>
<p>1.UpdateStateByKey Operation</p>
<p>能够将前后的数据通过给出的函数整合起来，如统计之类的功能</p>
<p>Java的Demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function2&lt;List&lt;Integer&gt;, Optional&lt;Integer&gt;, Optional&lt;Integer&gt;&gt; updateFunction =</span><br><span class="line">  (values, state) -&gt; &#123;</span><br><span class="line">    Integer newSum = ...  <span class="comment">// add the new values with the previous running count to get the new count</span></span><br><span class="line">    <span class="keyword">return</span> Optional.of(newSum);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaPairDStream&lt;String, Integer&gt; runningCounts = pairs.updateStateByKey(updateFunction);</span><br></pre></td></tr></table></figure>
<p>2.Window Operations</p>
<p>窗口函数，通过滑动窗口间隔来进行计算</p>
<p>3.Transform Operation</p>
<p>Transform允许DStream上执行任意的RDD-to-RDD函数。通过该函数可以方便的扩展Spark API</p>
<p>4.Output Operations</p>
<p>能够将DStream的数据输出到多个外部系统</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html#a-quick-example" target="_blank" rel="noopener">Spark Streaming guide</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/27/spark入门知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/27/spark入门知识/" itemprop="url">Spark入门知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-27T11:16:39+08:00">
                2021-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spark入门知识"><a href="#Spark入门知识" class="headerlink" title="Spark入门知识"></a>Spark入门知识</h1><h2 id="Spark总体图"><a href="#Spark总体图" class="headerlink" title="Spark总体图"></a>Spark总体图</h2><p><img src="file:///D:/%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91/spark.jpg" alt="image"></p>
<h2 id="Spark基础知识"><a href="#Spark基础知识" class="headerlink" title="Spark基础知识"></a>Spark基础知识</h2><h3 id="Spark-RDD算子"><a href="#Spark-RDD算子" class="headerlink" title="Spark RDD算子"></a>Spark RDD算子</h3><ul>
<li>RDD算子：分布式数据集,能并行计算操作的且具有高可靠、可容错、自动感知的集合</li>
</ul>
<ul>
<li><p>RDD分为两种：1.Transformation(转换):延迟执行；2.Action(动作)：马上执行</p>
</li>
<li><p>RDD主要属性：</p>
<p>  1.作用于分区</p>
<p>  2.多个不同算子RDD</p>
<p>  3.可以依赖于不同RDD</p>
<p>  4.默认key-value 分区</p>
<p>  5.能自动选择数据位置执行RDD操作（计算任务会尽可能分配到数据库的存储位置）</p>
</li>
</ul>
<ul>
<li>RDD 依赖关系</li>
</ul>
<p>窄依赖：指的是每一个父RDD只会传递到唯一的子RDD中</p>
<p>宽依赖：指定是每一个父RDD能传递到1个或多个的子RDD中</p>
<p><img src="https://note.youdao.com/favicon.ico" alt="image"></p>
<ul>
<li>RDD常用算子介绍</li>
</ul>
<p>Transformation算子<br>名称 | 功能<br>—|—<br>map（func） | 返回新rdd,可用于将输入元素经过转换获得类似map形式<br>filter(func) | 返回新rdd,可用于过滤元素<br>flatMap（func） | 返回新rdd,先扁平化,后map<br>mapPartitions(func) | 作用于分区的map<br>mapPartitionsWithIndex(func) | 作用于分区的map，有每个分区的索引值<br>reduceByKey(func, [numTasks]) | 经过函数func合并相同的key,返回rdd<br>groupByKey([numTasks]) |    合并相同的key,生成迭代器<br>union(otherDataset) |  两个RDD求并集，返回RDD<br>intersection(otherDataset)  |  对源RDD和参数RDD求交集后返回一个新的RDD<br>distinct([numTasks]))  |  对源RDD去重<br>sortBy(func,[ascending], [numTasks]) | 经过函数排序RDD</p>
<p>Action算子</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>reduce(func)</td>
<td>通过func函数聚集RDD中的所有元素</td>
</tr>
<tr>
<td>collect()</td>
<td>以数组的形式返回数据集的所有元素</td>
</tr>
<tr>
<td>count()</td>
<td>返回RDD的元素个数</td>
</tr>
<tr>
<td>first()</td>
<td>返回RDD的第一个元素（类似于take(1)）</td>
</tr>
<tr>
<td>take(n)</td>
<td>返回第n个元素</td>
</tr>
<tr>
<td>saveAsTextFile(path)</td>
<td>将RDD数据保存至文件系统中</td>
</tr>
<tr>
<td>countByKey()</td>
<td>针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数。</td>
</tr>
<tr>
<td>foreach(func)</td>
<td>在每个RDD中执行func元素</td>
</tr>
</tbody>
</table>
<ul>
<li>RDD 其他信息</li>
</ul>
<p>广播变量：针对同一个app，共享数据到不同的worker上面</p>
<p>Lineage:将创建RDD的一系列信息记录下来，记录RDD的元数据和转换行为，以防RDD部分分区丢失的时候可以重新对这部分分区进行计算</p>
<p>RDD提供缓存功能:cache()</p>
<p>RDD提供checkPoint功能,可以将某阶段RDD数据存储到分布式的系统中（如hdfs）</p>
<h3 id="Spark执行结构"><a href="#Spark执行结构" class="headerlink" title="Spark执行结构"></a>Spark执行结构</h3><p><img src="/images/bdata/spark.png" alt="spark-sql"></p>
<p>Driver:用户提交的应用程序代码在spark中运行起来就是一个driver，用户提交的程序运行起来就是一个driver，他是一个一段特殊的excutor进程，这个进程除了一般excutor都具有的运行环境外，这个进程里面运行着DAGscheduler,Tasksheduler Schedulerbackedn等组件。</p>
<p>Master:管理所有的worker,进而资源调度<br>Worker:管理当前计算节点,worker会启动一个executor来完成真正计算<br>Executor:真正执行任务的jvm</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/27/大数据总览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/27/大数据总览/" itemprop="url">大数据总览（必看）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-27T11:16:39+08:00">
                2021-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h2><p><img src="/images/bdata/大数据总览.png" alt="大数据总览图"></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>上图是在大数据开发组上将近一年多的开发经验累积的知识点，以便日后能快速预览。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/20/kettle在项目中应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/20/kettle在项目中应用/" itemprop="url">kettle在项目中应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-20T12:00:00+08:00">
                2021-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着发展，公司后续对接的项目对大数据量的存储和清洗需求越来越旺盛，我有幸接触这个项目并成为其中开发一员，致力于构建了一个底层的ETL清洗服务。这也是我首次调部门的第一个项目。</p>
<h2 id="Kettle的介绍"><a href="#Kettle的介绍" class="headerlink" title="Kettle的介绍"></a>Kettle的介绍</h2><p>Kettle从名称就可以知道“水壶”，顾名思义就是封装了很多内置功能，它是一个ETL的开源工具。Kettle就像一个容纳器，将很多ETL所需要的功能都涵盖进去，形成一个独立的生态系统。</p>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>下图可以看出,kettle包含了丰富的功能。</p>
<p><img src="/images/bdata/kettle功能图.png" alt="Kettle功能图"></p>
<html><br><center>kettle功能图</center><br></html>

<h3 id="为什么使用kettle"><a href="#为什么使用kettle" class="headerlink" title="为什么使用kettle"></a>为什么使用kettle</h3><p>基于Kettle开发了一段时间，也逐渐深入了解到kettle的优势。以下是我使用Kettle以来个人的观点：</p>
<p>优势：</p>
<ul>
<li>内置众多的成熟稳定开源组件，天然支持多种ETL业务场景。</li>
<li>kettle设计是基于职责单一原则，各个组件独立，不相互依赖。因此提高重用性。</li>
<li>构建任务脚本简单，通过PC客户端拖拉组件的方式就能轻松实现转化任务。因此不用有编程基础的人都能够自行实现。</li>
<li>kettle有独立的官网，上面文档较为完善，但是可能市面上不怎么流行，网上关于kettle的问题并不是很多。</li>
</ul>
<p>劣势：</p>
<ul>
<li>组件繁多，有额外的学习门槛。</li>
<li>没有提供Web端的开发页面，只有PC客户端，因此开发人员只能通过客户端调试并开发。</li>
<li>由于基于开源组件开发，调试难度相对较大。线上部署测试难度大。</li>
<li>天然包含众多组件，偏重量级开源框架，因此打包会比较大。</li>
<li>不支持对非结构化文本的解释，如非结构化网页html、爬虫、不支持对流的操作和传输、难以支持逻辑较为复杂的业务流程，如数据融合，数据分析等。</li>
<li>开发自定义组件相对复杂，调试比较难。</li>
</ul>
<p>我大大小小也基于kettle开发过几十个脚本，但是往全公司推广确实举步维艰，因为需要学习成本，这个也跟公司的架构有关系（主要原因）。一旦脚本众多，维护起来就越来越麻烦，特别对于过于复杂的脚本来说，没几多人愿意维护起来。</p>
<h3 id="Kettle安装与使用"><a href="#Kettle安装与使用" class="headerlink" title="Kettle安装与使用"></a>Kettle安装与使用</h3><p><a href="http://note.youdao.com/noteshare?id=28505b7348b9d73ed38d8da36bfd1425&amp;sub=171D26FDD37442F184CA9B8947192B95" target="_blank" rel="noopener">Kettle安装使用</a></p>
<h3 id="集成Kettle"><a href="#集成Kettle" class="headerlink" title="集成Kettle"></a>集成Kettle</h3><ol>
<li>添加Maven<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;kettle.version&gt;8.3.0.0-371&lt;/kettle.version&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;kettle-core&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;kettle-engine&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;pentaho-kettle&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;kettle-dbdialog&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;$&#123;kettle.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>需要额外添加Pentaho自身的仓库，不然下载不了对应的Jar包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">  	&lt;repository&gt;</span><br><span class="line">      &lt;id&gt;pentaho-public&lt;/id&gt;</span><br><span class="line">      &lt;name&gt;Pentaho Public&lt;/name&gt;</span><br><span class="line">      &lt;url&gt;http://nexus.pentaho.org/content/groups/omni&lt;/url&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>代码集成</li>
</ol>
<ul>
<li><p>加载插件并进行kettle环境的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean init() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		if (pluginDir != null) &#123;</span><br><span class="line">			// Load plugins</span><br><span class="line">			StepPluginType.getInstance().getPluginFolders().add(new PluginFolder(pluginDir, false, true));</span><br><span class="line">		&#125;</span><br><span class="line">		KettleEnvironment.init();</span><br><span class="line">	&#125; catch (KettleException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		Log.error(&quot;kettle executor init&quot;,e);</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行Trans任务具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath  脚本路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramMap  脚本参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> level 脚本输出日志级别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">runTrans</span><span class="params">(String filePath, Map&lt;String, String&gt; paramMap,String level)</span> </span>&#123;</span><br><span class="line">		Trans trans = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			</span><br><span class="line">			LOG.info(<span class="string">"Running trans &#123;&#125;..."</span>, filePath);</span><br><span class="line">			<span class="keyword">long</span> st = System.currentTimeMillis();</span><br><span class="line">			</span><br><span class="line">			TransMeta transMeta = <span class="keyword">new</span> TransMeta(filePath);    <span class="comment">//构建Tran文件元数据对象</span></span><br><span class="line">			</span><br><span class="line">			trans = <span class="keyword">new</span> Trans(transMeta);   <span class="comment">//构建Trans任务</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置Trans里面输入的参数</span></span><br><span class="line">			<span class="keyword">if</span> (paramMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span>( String param: paramMap.keySet() ) &#123;</span><br><span class="line">					trans.setParameterValue( param, paramMap.get(param));</span><br><span class="line">					transMeta.setParameterValue( param, paramMap.get(param));</span><br><span class="line">				&#125;		</span><br><span class="line">				trans.activateParameters();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//执行Trans任务的脚本</span></span><br><span class="line">			trans.execute(<span class="keyword">null</span>);</span><br><span class="line">			trans.waitUntilFinished();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (trans.getErrors() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				LOG.error(<span class="string">"There are errors while running transformation! Error Code: &#123;&#125;"</span>, trans.getErrors());</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">long</span> dt = System.currentTimeMillis() - st;</span><br><span class="line">				LOG.info(<span class="string">"Run trans &#123;&#125; finish in &#123;&#125; ms"</span>, filePath, dt);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">if</span>(!trans.isFinished())&#123;</span><br><span class="line">				trans.stopAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>运行</li>
</ol>
<p>到了这部基本上已经可以跑kettle生成的trans的脚本，如果还想增加调度的功能话可以集成quartz调度包、市面上比较流行的saturn、xxl-job等调度框架，或者基于公司的业务架构来自行实现调度框架也是可以。以上的框架我也有使用过并进行对比和集成。后面会有一章节额外说明，这里就不详细说了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://community.hitachivantara.com/s/article/data-integration-kettle" target="_blank" rel="noopener">kettle官网</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/19/Kettle自定义插件开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/19/Kettle自定义插件开发/" itemprop="url">kettle自定义插件开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-19T12:00:00+08:00">
                2021-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着业务种类越来越多，kettle内置的插件也逐渐满足不了各种业务需求，因此需要通过kettle自定义插件的方式来满足业务的需求。</p>
<h2 id="kettle插件"><a href="#kettle插件" class="headerlink" title="kettle插件"></a>kettle插件</h2><p>开发kettle的业务插件也有一段时间，整理了一下大概也有十多个，大概如下：</p>
<ol>
<li><p>ESDB Output组件：Pipeline ESDB Output组件是一个Kettle的扩展插件，用于将数据输出到ESDB（自研发的地球科学数据库）中。</p>
</li>
<li><p>ESDB 字段映射组件：要用于将数据字段名称映射成规范的编码。比如我们提供了一份《气象行业字段标准编码》的文件，里面包含了CIMISS字段、IDEA字段与标准编码的映射。那么在采集CIMISS数据，或者IDEA数据时，就可以通过该组件，将字段名转换为标准的编码，最后才通过ESDB Output插件，进行入库。<br>每个行业（如气象、水利等），都可以整理一份字段标准编码CSV文件, 然后利用该组件进行自动匹配。规范字段编码的意义，在于对于不同的系统（比如不同省份的相似系统），数据查询的时候，可以通过统一的字段进行查询。比如地表温度，可以通过gst字段进行查询，无论该数据是来源于CIMISS，还是来源IDEA，还是来源于本地客户提供的数据。</p>
</li>
<li><p>Pipeline 通用组件：pipeline 通用组件,为用户开发自定义转换的插件提供统一的界面展示和配置操作。</p>
</li>
<li><p>Pipeline 通用组件-经纬度转换组件：pipeline 通用组件 经纬度转换组件,为用户提供经纬度转换坐标系（WGS84、GCJ_02、BD_09之间相互转换）的功能。</p>
</li>
<li><p>Pipeline 通用组件-站点插值组件：pipeline 通用组件-插值组件,为用户提供站点插值成格点数据的功能。</p>
</li>
<li><p>Pipeline 通用组件-idea（intgetdata2d接口）格点解析组件：格点解析组件,为用户提供解析intgetdata2d接口格点数据的功能</p>
</li>
<li>Pipeline 列合并组件：为用户提供针对某个字段，多行数据合并成一行数据的功能，合并后的对象是一个List对象。</li>
<li>Pipeline 多值映射组件：为用户提供值映射的功能。</li>
<li>Pipeline 通用组件-idea-byte转格点：dea（qpe、qpf接口）byte转格点解析组件,为用户提供byte转格点数据的功能。由于qpe与qpf接口返回格点数据经过base64加密，因此该插件会先base64解密然后将byte转换成格点数据</li>
<li>Pipeline 通用组件-格点双线性插值：为用户格点插值的功能（双线性插值）。</li>
<li>Pipeline 通用组件-气象文件读取插件（网格文件）：</li>
<li>Pipeline 通用组件-RestClientNew插件：提供读取rest接口的功能，主要是增加超时设置，kettle自带的restClient插值没有读取超时机制，如果接口卡住，连接会一直保持，所以新增本插件支持读取超时设置功能。</li>
<li>Pipeline 通用组件-多行数据转JSON插件：多行数据转JSON插件,提供把一行或多行数据根据分组字段合并成json字符串。</li>
<li>Pipeline 图片压缩插件：用于将图片进一步压缩的组件。</li>
<li>Pipeline 图片生成gif动图插件：能够将多张图片生成多张含有时间信息的图片，并将生成后的图片聚合成一张gif动态图片。</li>
</ol>
<h2 id="开发自定义插件"><a href="#开发自定义插件" class="headerlink" title="开发自定义插件"></a>开发自定义插件</h2><p>本章简单记录我认为开发属于自己步骤插件的要点，要想完整搭建参考<a href="https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins" target="_blank" rel="noopener">自定义步骤插件开发</a>。</p>
<h3 id="四个接口"><a href="#四个接口" class="headerlink" title="四个接口"></a>四个接口</h3><p>开发前提条件首先要了解四个接口</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>基础类</th>
<th>主要职责</th>
</tr>
</thead>
<tbody>
<tr>
<td>StepMetaInterface</td>
<td>BaseStepMeta</td>
<td>1.存储step设置信息<br>2.验证step设置信息<br>3.序列化step设置信息<br>4.提供获取step类的方法</td>
</tr>
<tr>
<td>StepDialogInterface</td>
<td>org.pentaho.di.ui.trans.step.BaseStepDialog</td>
<td>step属性信息配置窗口</td>
</tr>
<tr>
<td>StepInterface</td>
<td>BaseStep</td>
<td>执行数据行的功能流程</td>
</tr>
<tr>
<td>StepDataInterface</td>
<td>BaseStepData</td>
<td>存储处理中的数据状态</td>
</tr>
</tbody>
</table>
<p>以下我结合代码尽量</p>
<h3 id="实现StepMetaInterface"><a href="#实现StepMetaInterface" class="headerlink" title="实现StepMetaInterface"></a>实现StepMetaInterface</h3><p>该接口主要是对步骤元数据信息进行操作。</p>
<p>接口常用方法介绍：</p>
<ul>
<li>setDefault()：每次创建新步骤并将该步骤配置分配或设置为合理的默认值时，都会调用此方法。创建新步骤时，PDI客户端（Spoon）将使用此处设置的值。这是确保将步设置初始化为非空值的好地方。在序列化和对话框填充中，空值的处理可能很麻烦，因此大多数PDI步骤实现对于所有步骤设置都坚持非空值。</li>
<li><p>clone()：在PDI客户端中复制步骤时，将调用此方法。它返回步骤元对象的深层副本。如果步骤配置存储在可修改的对象（例如列表或自定义帮助对象）中，则实现类必须创建正确的深层副本，这一点至关重要。</p>
</li>
<li><p>getXML()：每当步骤将其设置序列化为XML时，PDI都会调用此方法。在PDI客户端中保存转换时会调用它。该方法返回一个XML字符串，其中包含序列化的步骤设置。该字符串包含一系列XML标记，每个设置一个标记。辅助类org.pentaho.di.core.xml.XMLHandler构造XML字符串。</p>
</li>
<li>loadXML()：每当步骤从XML读取其设置时，PDI都会调用此方法。包含步骤设置的XML节点作为参数传入。再次，帮助程序类 org.pentaho.di.core.xml.XMLHandler从XML节点读取步骤设置。</li>
<li>saveRep()：每当步骤将其设置保存到PDI存储库时，PDI都会调用此方法。作为第一个参数传入的存储库对象提供了一组用于序列化步骤设置的方法。调用存储库序列化方法时，该步骤将传入的转换ID和步骤ID用作标识符。</li>
<li>readRep()：每当步骤从PDI存储库中读取其配置时，PDI都会调用此方法。使用存储库序列化方法时，参数中给出的步骤ID用作标识符。</li>
</ul>
<p>获取其他实例</p>
<ul>
<li>public StepDialogInterface getDialog()</li>
<li>public StepInterface getStep()</li>
<li>public StepDataInterface getStepData()</li>
</ul>
<p>StepMetaInterface必须使用Step Java注释对实现的类进行注释。提供以下注释属性：<br>属性|描述<br>—|—<br>id | 该步骤的全局唯一ID<br>image | 步骤的png图标图像的资源位置<br>name | 该步骤的简短标签<br>description    | 该步骤的详细说明<br>categoryDescription |    步骤的类别应显示在PDI步骤树中。例如输入，输出，变换等。<br>i18nPackageName |如果i18nPackageName在批注属性中提供了该属性，则将name，description和categoryDe​​scription的值解释为 i18n相对于给定包中包含的消息束的键。<br>可以以扩展形式的i18n:<packagename>键来提供键，以指定与i18nPackageName属性中给定的包不同的包。</packagename></p>
<h3 id="实现StepDialogInterface"><a href="#实现StepDialogInterface" class="headerlink" title="实现StepDialogInterface"></a>实现StepDialogInterface</h3><p>该接口主要用于实现窗口的功能，以及设置属性信息的入口。打开步骤设置时候都会实例化dialog传入到StepMetaInterface接口对象并调用open()方法。</p>
<p>接口常用方法介绍：</p>
<ul>
<li>open()：仅在确认或取消对话框后，此方法才返回。</li>
</ul>
<h3 id="实现StepInterface"><a href="#实现StepInterface" class="headerlink" title="实现StepInterface"></a>实现StepInterface</h3><p>StepInterface当转换运行时，类实现负责实际的行处理。</p>
<p><img src="/images/bdata/kettle流程.png" alt="StepInterface"></p>
<p>接口常用方法介绍：</p>
<ul>
<li><p>init()：当转换准备开始执行时，将调用该方法初始化资源。</p>
</li>
<li><p>processRow()：转换开始执行该方法，读取上一步骤传递下来的行数据，直到没有行就调用setOutputDone()返回false。</p>
</li>
<li><p>dispose()：转换完成后，PDI将调用该方法取消init()分配的资源。</p>
</li>
</ul>
<h3 id="实现StepDataInterface"><a href="#实现StepDataInterface" class="headerlink" title="实现StepDataInterface"></a>实现StepDataInterface</h3><p>类实现StepInterface不会在其任何字段中存储处理状态。取而代之的StepDataInterface是，使用一个附加的类实现来存储处理状态，包括状态标志，索引，缓存表，数据库连接，文件句柄等</p>
<h2 id="部署步骤插件"><a href="#部署步骤插件" class="headerlink" title="部署步骤插件"></a>部署步骤插件</h2><ol>
<li>创建一个包含您的插件类和资源的JAR文件</li>
<li>创建一个新文件夹，为其命名，然后将您的JAR文件放在该文件夹中</li>
<li>将刚创建的插件文件夹放置在特定位置，以供PDI查找。根据您使用PDI的方式，您需要按如下方式将插件文件夹复制到一个或多个位置。<ul>
<li>部署到PDI客户端（Spoon）或Carte：</li>
<li>将plugin文件夹复制到以下位置： design-tools / data-integration / plugins / steps。</li>
<li>重新启动PDI客户端。重新启动PDI客户端后，可以使用新的作业条目。</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://help.pentaho.com/Documentation/8.3/Developer_center/Embed_and_extend_PDI_functionality" target="_blank" rel="noopener">Kettle开发中心</a></p>
<p><a href="https://help.pentaho.com/Documentation/8.3/Developer_center/Extend_Pentaho_Data_Integration" target="_blank" rel="noopener">扩展Pentaho数据集成</a></p>
<p><a href="https://help.pentaho.com/Documentation/8.3/Developer_center/Create_step_plugins" target="_blank" rel="noopener">自定义步骤插件开发</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/27/视频总览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/27/视频总览/" itemprop="url">视频总览（必看）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-27T11:16:39+08:00">
                2021-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h2><p><img src="/images/video/视频总览.png" alt="视频总览图"></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>上图是在视频开发组上将近一年多的开发经验累积的知识点，以便日后能快速预览。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/26/流媒体基础知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/26/流媒体基础知识点/" itemprop="url">流媒体基础知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-26T11:16:39+08:00">
                2021-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>学习流媒体之前，应该要首先知道流媒体相关基础知识点，这样能够更好地掌握流媒体</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>流媒体是什么？按照我个人理解就是将音视频数据转化成能够在互联网进行播放的一种流式技术。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>操作系统的扩展名，常用的视频保存格式有：mp4、avi、mpg等</p>
<h3 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h3><p>封装格式（Format），也称多媒体容器（Multimedia Container），是将已编码压缩好的视频轨道、音频轨道和元数据（视频基本信息如标题、字幕等）按照一定的格式规范，打包放到一个文件中，形成特定文件格式的视频文件。</p>
<h3 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h3><p>硬编解码：通过硬件实现编解码，减轻CPU计算的负担，如GPU等</p>
<p>软编解码：如 H264、H265、MPEG-4等编解码算法，更消耗CPU</p>
<h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>视频编码方式将视频数据进行压缩或者解压。一般来说压缩技术都会有损数据的</p>
<p>视频编码格式：</p>
<ol>
<li>H.26X系列：<ul>
<li>H261：主要在老的视频会议和视频电话产品中使用。</li>
<li>H263：主要用在视频会议、视频电话和网络视频上。</li>
<li>H264：视频压缩技术，比较普及和广发使用，在媒体项目中也是会经常接触，目前市面上多数的流媒体服务都支持H264编码的视频</li>
<li>H265：高效视频压缩技术，同比H264来说压缩效率提高了50%（同画面质量的情况下），而且还支持4K/8K的视频效果，未来会是趋势。但是目前市面上普遍的播放器支持度并不高，flv协议则不支持H265的格式编码的视频。</li>
</ul>
</li>
<li>MPEG系列<ul>
<li>MPEG-1第二部分：主要使用在VCD上，有些在线视频也使用这种格式，该编解码器的质量大致上和原有的VHS录像带相当。</li>
<li>MPEG-2第二部分：等同于H.262，使用在DVD、SVCD和大多数数字视频广播系统和有线分布系统（Cable Distribution Systems）中。</li>
<li>MPEG-4第二部分：可以使用在网络传输、广播和媒体存储上，比起MPEG-2和第一版的H.263，它的压缩性能有所提高。</li>
<li>MPEG-4第十部分：技术上和ITU-TH.264是相同的标准，二者合作，诞生了H.264/AVC标准，ITU-T将其命名为H.264，而ISO/IEC称它为MPEG-4高级视频编码（Advanced Video Coding，AVC）。</li>
</ul>
</li>
<li>AVS：我国自主知识产权的信源编码标准</li>
</ol>
<p>音频编码格式：</p>
<ol>
<li>AAC：ACC是MPEG-4中的音频标准（常见）</li>
<li>AMR</li>
<li>PCM</li>
<li>ogg(ogg vorbis音频)</li>
<li>AC3(DVD 专用音频编码)</li>
<li>DTS(DVD 专用音频编码)</li>
<li>APE(monkey’s 音频)</li>
<li>AU(sun 格式)</li>
<li>WMA</li>
</ol>
<p>音频编码方案之间音质比较（AAC，MP3，WMA等）结果： AAC+ &gt; MP3PRO &gt; AAC&gt; RealAudio &gt; WMA &gt; MP3</p>
<h3 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h3><p>视频转码（Video Transcoding）是指将已经压缩编码的视频码流转换成另一个视频码流</p>
<h3 id="转封装"><a href="#转封装" class="headerlink" title="转封装"></a>转封装</h3><p>转封装指的是将视频或音频的封装格式进行转换，如将AVI的视频转换为MP4，其间并不会进行音视频的编码和解码工作，而是直接将视频和音频压缩码流从一种封装格式文件中获取出来然后打包成另一种封装格式的文件。相比转码，转封装有两大特点：</p>
<pre><code>处理速度极快。音视频编解码过程十分复杂，占据了转码的绝大部分时间。转封装不需要进行编码和解码，节约了大量的处理时间。

音视频质量无损。没有解码（解压缩）和编码（压缩）过程，所以不会有音视频的压缩损伤。
</code></pre><p>转封装后的文件与原始文件的分辨率、码率等几乎一致，故播放时也称其为“原画”。</p>
<h3 id="码流与码率"><a href="#码流与码率" class="headerlink" title="码流与码率"></a>码流与码率</h3><p>码率（Bitrate）是指视频文件在单位时间内使用的数据流量，也叫码流或码流率，是视频编码中画面质量控制最重要的部分。量度单位为“比特每秒”（bit/s或bps），常使用Kbps（每秒多少千个比特）或Mbps。一般来说同样分辨率下，视频文件的码率越大，压缩比就越小，画面质量就越高。码率越大，说明单位时间内取样率越大，数据流精度就越高，处理出来的文件就越接近原始文件，图像质量越好，画质越清晰，要求播放设备的解码能力也越高。</p>
<pre><code>当然，码率越大，文件体积也越大，其计算公式是文件体积=时间X码率/8。例如，网络上常见的一部60分钟的码率为1Mbps的720P的视频文件，其体积就大概为3600秒×1Mb/8=450MB。
</code></pre><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>视频分辨率是指视频成像产品所成图像的大小或尺寸。分辨率决定了视频画面细节的精细程度。通常情况下，视频的分辨率越高，所包含的像素就越多，画面就越清晰。</p>
<p>480P : 640 x 480 个像素点</p>
<p>720P : 1280 x 720 个像素点</p>
<p>1080P : 1920 x 1080 个像素点</p>
<pre><code>分辨率是决定码率的主要因素，不同的分辨率要采用不同的码率。总体而言，视频的分辨率越高，所要求的码率也越大，但并不总是如此，不同分辨率都有合理的码率选择范围。
所谓“合理的范围”指的是，如果低于这个范围，视频画面质量会很差；如果高于这个范围，画面提升有限甚至几乎无提升，且浪费网络流量和存储空间。 
</code></pre><h3 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h3><p>帧率（Frame Rate）是单位时间内视频显示帧数的量度单位，也就是每秒钟刷新的图片的帧数，量度单位为“每秒显示帧数”（Frame Per Second，FPS）或“赫兹”</p>
<p>关于帧率有如下几个基础数据：</p>
<ul>
<li>帧率越高，cpu消耗就高</li>
<li>秀场视频直播，一般帧率20fps</li>
<li>普通视频直播，一般帧率15fps</li>
</ul>
<h3 id="GOP（关键帧间隔）"><a href="#GOP（关键帧间隔）" class="headerlink" title="GOP（关键帧间隔）"></a>GOP（关键帧间隔）</h3><p>GOP（Group of Pictures）是一组以 MPEG 编码的影片或视讯串流内部的连续图像，以 I 帧开头，到下一个 I 帧结束</p>
<ul>
<li>I 帧(Intra Coded Picture)：又称帧内编码帧，为关键帧，是一种自带全部信息的独立帧，无需参考其他图像便可独立进行解码，可以简单理解为一张静态画面。视频序列中的第一个帧始终都是I 帧，每个 GOP 由I 帧开始。</li>
<li>P 帧(Predictive Coded Picture)：又称帧间预测编码帧，需要参考前面的I帧才能进行编码。表示的是当前帧画面与前一帧（前一帧可能是I帧也可能是P帧）的差别。解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。与I帧相比，P帧通常占用更少的数据位，但不足是，由于P帧对前面的P和I参考帧有着复杂的依赖性，因此对传输错误非常敏感</li>
<li>B 帧(Bidirectionally Predictive Coded Pictures)：又称双向预测编码帧，也就是B帧记录的是本帧与前后帧的差别。也就是说要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是对解码性能要求较高。</li>
</ul>
<p>GOP值表示关键帧的间隔(即两个关键帧之间的帧数)，也就是两个IDR帧之间的距离，一个帧组的最大帧数。一般而言，每一秒视频至少需要使用 1 个关键帧。增加关键帧个数可改善视频质量，但会同时增加带宽和网络负载。GOP值（帧数）除以帧率即为时间间隔，如阿里云视频点播默认的GOP值为250帧，帧率为25fps，则时间间隔为10秒。</p>
<p>GOP值需要控制在合理范围，以平衡视频质量、文件大小（网络带宽）和seek效果（拖动、快进的响应速度）等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.加大GOP值有利于减小视频文件大小，但也不宜设置过大，太大则会导致GOP后部帧的画面失真，影响视频质量。</span><br><span class="line"></span><br><span class="line">2.GOP值也是影响视频seek响应速度的关键因素，seek时播放器需要定位到离指定位置最近的前一个关键帧，如果GOP太大意味着距离指定位置可能越远（需要解码的预测帧就越多）、seek响应的时间（缓冲时间）也越长。</span><br><span class="line"></span><br><span class="line">3.由于P、B帧的复杂度大于I帧，GOP值过大，过多的P、B帧会影响编码效率，使编码效率降低。</span><br><span class="line"></span><br><span class="line">4.但如果设置过小的GOP值，则需要提高视频的输出码率，以确保画面质量不会降低，故会增加网络带宽。</span><br></pre></td></tr></table></figure>
<h3 id="IDR-帧对齐"><a href="#IDR-帧对齐" class="headerlink" title="IDR 帧对齐"></a>IDR 帧对齐</h3><p>IDR帧（Instantaneous Decoding Refresh Picture），即时解码刷新帧，是 I 帧的一种。与普通 I 帧的区别在于，一个 IDR 帧之后的所有帧都不能引用该 IDR 帧之前的帧的内容；相反，对于普通的 I 帧，其后的 P 帧和 B 帧可以引用该普通 I 帧之前的其他 I 帧。在编码和解码中为了方便，将首个I帧和其他I帧区别开，称为IDR，这样就方便控制编码和解码流程</p>
<h3 id="图像存储格式yuv"><a href="#图像存储格式yuv" class="headerlink" title="图像存储格式yuv"></a>图像存储格式yuv</h3><p>YUV格式，与我们熟知的RGB类似，YUV也是一种颜色编码方法。YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p>
<p>YUV与RGB相比：<br>YUV是利用一个亮度（Y）、两个色差(U,V)来代替传统的RGB三原色来压缩图像。传统的RGB三原色使用红绿蓝三原色表示一个像素，每种原色占用一个字节（8bit），因此一个像素用RGB表示则需要8 * 3=24bit。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.码率与分辨率有关系，分辨率决定码率的主要因素，跟帧率没关，帧率关系着画面流畅度和cpu消耗</p>
<p>2.I帧可以看作一张完整的画面，P帧需要与缓存之前画面生成图像，而B帧则就需要记录前后画面画面生成图像。一般来说网络上的电影都会使用B帧，因为压缩率高，带宽消耗相对比较低。压缩率一般是 I帧（7）&lt; P帧（20） &lt; B帧（50）</p>
<p>3.一般来说，硬编码相比一般性能高，效率高，但移植和实现都比较困难，而软编码则实现简单，但性能相比就低一点。</p>
<blockquote>
<p>PS:<br>在项目遇到过一次坑就是关于视频YUV的问题，由于海康和大华的颜色编码不是相同，海康设备使用了YV12格式，而大华使用了YUV420格式，但是程序统一使用了YUV420，因此海康的画面出现了色差问题。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/232291020" target="_blank" rel="noopener">音视频&amp;流媒体的原理以及基础入门知识
</a></p>
<p><a href="https://help.aliyun.com/document_detail/99380.html?spm=a2c4g.11186623.6.553.28b0c149c65swI" target="_blank" rel="noopener">基础概念</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/nginx支持流媒体/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/25/nginx支持流媒体/" itemprop="url">nginx支持流媒体</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-25T11:16:39+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本章介绍如何搭建一个nginx的流媒体服务器，可以直接通过nginx访问hls的m3u8与rtmp的链接。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装nginx其实没有什么值得说，主要是要下载nginx的nginx-rtmp-module模块,编译时候加下此模块就OK了</p>
<p>下载nginx-rtmp-module：<a href="https://github.com/arut/nginx-rtmp-module" target="_blank" rel="noopener">https://github.com/arut/nginx-rtmp-module</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-pcre=/home/user/pcre/pcre-8.32 --with-zlib=/home/user/zlib/zlib-1.2.8 --with-openssl=/home/user/openssl/openssl-1.0.1i  --add-module=/home/user/nginx-rtmp-module</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li><p>RTMP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;                #RTMP服务</span><br><span class="line">   server &#123;</span><br><span class="line">       listen 1935;  #//服务端口</span><br><span class="line">       chunk_size 4096;   #//数据传输块的大小</span><br><span class="line">       application vod &#123;</span><br><span class="line">         play /opt/video/vod; #//视频文件存放位置。</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include      mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen      80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        #配置nginx的rtmp一览页面</span><br><span class="line">        location /stat &#123;</span><br><span class="line">                rtmp_stat all;</span><br><span class="line">            rtmp_stat_stylesheet stat.xsl;</span><br><span class="line">        &#125;</span><br><span class="line">        location /stat.xsl &#123;</span><br><span class="line">           root /etc/rtmpServer/nginx-rtmp-module/;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root  html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page  500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root  html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HLS</p>
</li>
</ul>
<p>该配置是播放hls的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /hls &#123;  </span><br><span class="line">    types&#123;  </span><br><span class="line">        application/vnd.apple.mpegurl m3u8;  </span><br><span class="line">        video/mp2t ts;  </span><br><span class="line">    &#125;  </span><br><span class="line">    suffix m3u8;</span><br><span class="line">   #配置一个根路径 </span><br><span class="line">   root /data/baiyun/; </span><br><span class="line">   add_header Cache-Control no-cache;</span><br><span class="line">   add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;</span><br><span class="line">   add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该配置是支持远程推流到nginx负责切片成m3u8的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        chunk_size 4000;</span><br><span class="line">        #HLS</span><br><span class="line">        application hls &#123;</span><br><span class="line">            live on;</span><br><span class="line">            hls on;</span><br><span class="line">            #视频流存放地址</span><br><span class="line">            hls_path /usr/local/nginx/html/hls; </span><br><span class="line">            hls_fragment 5s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weiyuefei/article/details/74001589" target="_blank" rel="noopener">视频直播点播nginx-rtmp开发手册中文版</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/流媒体协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/25/流媒体协议/" itemprop="url">流媒体协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-25T11:16:39+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>总结我在流媒体项目中接触到且使用过的所有协议</p>
<h1 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h1><p><img src="/images/video/agreement.png" alt="image"></p>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><p>学习流媒体的协议，首当其冲就是学习TCP与UDP的协议，因为基本的协议都是基于这两种协议来传输</p>
<h2 id="RTP与RTCP"><a href="#RTP与RTCP" class="headerlink" title="RTP与RTCP"></a>RTP与RTCP</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>RTP实时流传输协议，是用于Internet上针对多媒体数据流的一种传输协议。RTP位于传输层，基于UDP之上。RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，服务质量由RTCP来提供。</p>
<p>RTCP是实时传输控制协议，RTCP收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，jitter，单向和双向网络延迟等，服务器可以利用这些信息动态的改变传输速率，甚至改变净荷的类型。RTCP消息也被封装为UDP数据报进行传输</p>
<p>一般而言,目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个 给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的 UDP端口＋1），这样就构成一个UDP端口对。 RTP的发送过程如下，接收过程则相反。</p>
<h3 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h3><h4 id="RTP协议结构"><a href="#RTP协议结构" class="headerlink" title="RTP协议结构"></a>RTP协议结构</h4><p><img src="/images/video/RTCP协议.png" alt="RTP协议结构"></p>
<p>RTP分组头部的各字段含义为：</p>
<p>V：RTP版本号。为“10”。</p>
<p>P：填充指示位。P为“1”时表示分组结尾含有1个或多个填充字节，其中这部分不属于有效载荷。</p>
<p>X：扩展指示位。X为“1”时，则表示固定头部后还有一个扩展头部，这种情况较复杂，很少使用。</p>
<p>CC：CSRC计数。指示固定头部后的CSRC的个数</p>
<p>M：标志。</p>
<p>PT：负载类型。表示RTP分组的负载类型。我们常用的有</p>
<table>
<thead>
<tr>
<th>Payload Type</th>
<th>Codec</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>PCM μ -Law</td>
</tr>
<tr>
<td>8</td>
<td>PCM-A Law</td>
</tr>
<tr>
<td>9</td>
<td>G..722 audio codec</td>
</tr>
<tr>
<td>4</td>
<td>G..723 audio codec</td>
</tr>
<tr>
<td>15</td>
<td>G..728 audio codec</td>
</tr>
<tr>
<td>18</td>
<td>G..729 audio codec</td>
</tr>
<tr>
<td>34</td>
<td>G..763 audio codec</td>
</tr>
<tr>
<td>31</td>
<td>G..761 audio codec</td>
</tr>
</tbody>
</table>
<p>序列号：序号顾名思义就是表示RTP分组的次序。初值为随机数，每发送一个增加1。可供接收方检测分组丢失和恢复分组次序。</p>
<p>时间戳：表示RTP分组第一个字节的取样时刻。其初值为随机数，每个采用周期加1。如果每次传送20ms的数据，由于音频的采样频率为8000Hz，即每20ms有160次采样，则每传送20ms的数据，时戳增加160。</p>
<p>SSRC：同步源标识(Synchronous Source)。表示信号的同步源，其值应随机选择，以保证同一个RTP会话中任意两个同步源的SSRC标识不同。</p>
<p>CSRC：分信源(贡献源)标识(Contributing Source)。识别该数据包中的有效载荷的贡献源。换句话说，CSRC标识由混合器插入，其值就是组成复合信号的各个分信号的SSRC标识，用以标识各个组成分信号的信源。RTP分组的头部最多可以包含15个CSRC标识，其数目由CC字段指明。</p>
<h4 id="RTCP协议结构"><a href="#RTCP协议结构" class="headerlink" title="RTCP协议结构"></a>RTCP协议结构</h4><p><img src="/images/video/RTP协议.jpg" alt="RTCP"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">版本（V）：同RTP包头域。</span><br><span class="line"></span><br><span class="line">填充（P）：同RTP包头域。</span><br><span class="line"></span><br><span class="line">接收报告计数器（RC）：5比特，该SR包中的接收报告块的数目，可以为零。</span><br><span class="line"></span><br><span class="line">包类型（PT）：8比特，SR包是200。</span><br><span class="line"></span><br><span class="line">长度域（Length）：16比特，其中存放的是该SR包以32比特为单位的总长度减一。</span><br><span class="line"></span><br><span class="line">同步源（SSRC of sender）：SR包发送者的同步源标识符。与对应RTP包中的SSRC一样。</span><br><span class="line"></span><br><span class="line">NTP Timestamp（Network time protocol）SR包发送时的绝对时间值。NTP的作用是同步不同的RTP媒体流。</span><br><span class="line"></span><br><span class="line">RTP Timestamp：与NTP时间戳对应，与RTP数据包中的RTP时间戳具有相同的单位和随机初始值。</span><br><span class="line"></span><br><span class="line">Sender’s packet count：从开始发送包到产生这个SR包这段时间里，发送者发送的RTP数据包的总数. SSRC改变时，这个域清零。</span><br><span class="line"></span><br><span class="line">Sender`s octet count：从开始发送包到产生这个SR包这段时间里，发送者发送的净荷数据的总字节数（不包括头部和填充）。发送者改变其SSRC时，这个域要清零。</span><br><span class="line"></span><br><span class="line">同步源n的SSRC标识符：该报告块中包含的是从该源接收到的包的统计信息。</span><br><span class="line"></span><br><span class="line">丢失率（Fraction Lost）：表明从上一个SR或RR包发出以来从同步源n(SSRC_n)来的RTP数据包的丢失率。</span><br><span class="line"></span><br><span class="line">累计的包丢失数目：从开始接收到SSRC_n的包到发送SR,从SSRC_n传过来的RTP数据包的丢失总数。</span><br><span class="line"></span><br><span class="line">收到的扩展最大序列号：从SSRC_n收到的RTP数据包中最大的序列号，</span><br><span class="line"></span><br><span class="line">接收抖动（Interarrival jitter）：RTP数据包接受时间的统计方差估计</span><br><span class="line"></span><br><span class="line">上次SR时间戳（Last SR,LSR）：取最近从SSRC_n收到的SR包中的NTP时间戳的中间32比特。如果目前还没收到SR包，则该域清零。</span><br><span class="line"></span><br><span class="line">上次SR以来的延时（Delay since last SR,DLSR）：上次从SSRC_n收到SR包到发送本报告的延时。</span><br></pre></td></tr></table></figure>
<p>根据所携带的控制信息不同RTCP信息包可分为RR（接收者报告包）、SR（源报告包）、SEDS（源描述包）、BYE（离开申明）和APP（特殊应用包）五类5类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>缩写表示</th>
<th>用途</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>SR（Sender Report）</td>
<td>发送端报告</td>
<td>发送端报告包，用于发送和接收活动源的统计信息；</td>
</tr>
<tr>
<td>201</td>
<td>RR（Receiver Report）</td>
<td>接收端报告</td>
<td>接收者报告包，用于接收非活动站的统计信息；</td>
</tr>
<tr>
<td>202</td>
<td>SDES（Source Description Items）</td>
<td>源点描述</td>
<td>源描述包，用于报告和站点相关的信息，包括CNAME；</td>
</tr>
<tr>
<td>203</td>
<td>BYE</td>
<td>结束传输</td>
<td>断开RTCP包，是站点离开系统的报告，表示结束；</td>
</tr>
<tr>
<td>204</td>
<td>APP</td>
<td>特定应用</td>
<td>应用特定函数。</td>
</tr>
</tbody>
</table>
<h2 id="RTSP"><a href="#RTSP" class="headerlink" title="RTSP"></a>RTSP</h2><p><img src="/images/video/RTSP协议.png" alt="image"></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>实时串流协议（应用层）,TCP/IP协议体系中的一个应用层协议，RTSP位于RTP和RTCP之上，可以基于TCP或者UDP来完成数据传输。RTSP实时性比较，扩展性比较好（UDP,TCP传输数据）。rtsp流主要是控制流媒体的行为动作，提供了诸如暂停，快进等控制，而它本身并不传输流媒体数。</p>
<h3 id="协议介绍-1"><a href="#协议介绍-1" class="headerlink" title="协议介绍"></a>协议介绍</h3><ol>
<li>RTSP结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtsp://admin:a12345678@47.106.89.193:10000/h264/ch33/main/av_stream</span><br></pre></td></tr></table></figure>
<p>结构：<br>rtsp://user:pwd@host:port/abs_path/content_name</p>
<p>user:摄像头设备的登陆用户名</p>
<p>pwd:摄像头设备的登陆密码</p>
<p>host:摄像头有效的域名或是IP地址</p>
<p>port:端口号，对于RTSP协议来说，缺省的端口号为554</p>
<p>abs_path:媒体流资源标识</p>
<ol>
<li>方法定义</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th>方向</th>
<th>对象</th>
<th>要求</th>
<th>含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DESCRIBE</td>
<td>C-&gt;S</td>
<td>P，S</td>
<td>推荐</td>
<td>检查演示或媒体对象的描述，也允许使用接收头指定用户理解的描述格式。DESCRIBE的答复-响应组成媒体RTSP初始阶段</td>
</tr>
<tr>
<td style="text-align:center">ANNOUNCE</td>
<td>C-&gt;S,S-&gt;C</td>
<td>P，S</td>
<td>可选</td>
<td>当从用户发往服务器时，ANNOUNCE将请求URL识别的演示或媒体对象描述发送给服务器；反之，ANNOUNCE实时更新连接描述。如新媒体流加入演示，整个演示描述再次发送，而不仅仅是附加组件，使组件能被删除</td>
</tr>
<tr>
<td style="text-align:center">GET_PARAMETER</td>
<td>C-&gt;S,S-&gt;C</td>
<td>P，S</td>
<td>可选</td>
<td>GET_PARAMETER请求检查URL指定的演示与媒体的参数值。没有实体体时，GET_PARAMETER也许能用来测试用户与服务器的连通情况</td>
</tr>
<tr>
<td style="text-align:center">OPTIONS</td>
<td>C-&gt;S,S-&gt;C</td>
<td>P，S</td>
<td>要求</td>
<td>可在任意时刻发出OPTIONS请求，如用户打算尝试非标准请求，并不影响服务器状态</td>
</tr>
<tr>
<td style="text-align:center">PAUSE</td>
<td>C-&gt;S</td>
<td>P，S</td>
<td>推荐</td>
<td>PAUSE请求引起流发送临时中断。如请求URL命名一个流，仅回放和记录被停止；如请求URL命名一个演示或流组，演示或组中所有当前活动的流发送都停止。恢复回放或记录后，必须维持同步。在SETUP消息中连接头超时参数所指定时段期间被暂停后，尽管服务器可能关闭连接并释放资源，但服务器资源会被预订</td>
</tr>
<tr>
<td style="text-align:center">PLAY</td>
<td>C-&gt;S</td>
<td>P，S</td>
<td>要求</td>
<td>PLAY告诉服务器以SETUP指定的机制开始发送数据；直到一些SETUP请求被成功响应，客户端才可发布PLAY请求。PLAY请求将正常播放时间设置在所指定范围的起始处，发送流数据直到范围的结束处。PLAY请求可排成队列，服务器将PLAY请求排成队列，顺序执行</td>
</tr>
<tr>
<td style="text-align:center">RECORD</td>
<td>C-&gt;S</td>
<td>P，S</td>
<td>可选</td>
<td>该方法根据演示描述初始化媒体数据记录范围，时标反映开始和结束时间；如没有给出时间范围，使用演示描述提供的开始和结束时间。如连接已经启动，立即开始记录，服务器数据请求URL或其他URL决定是否存储记录的数据；如服务器没有使用URL请求，响应应为201（创建），并包含描述请求状态和参考新资源的实体与位置头。支持现场演示记录的媒体服务器必须支持时钟范围格式，smpte格式没有意义</td>
</tr>
<tr>
<td style="text-align:center">REDIRECT</td>
<td>S-&gt;C</td>
<td>P，S</td>
<td>可选</td>
<td>重定向请求通知客户端连接到另一服务器地址。它包含强制头地址，指示客户端发布URL请求；也可能包括参数范围，以指明重定向何时生效。若客户端要继续发送或接收URL媒体，客户端必须对当前连接发送TEARDOWN请求，而对指定主执新连接发送SETUP请求</td>
</tr>
<tr>
<td style="text-align:center">SETUP</td>
<td>C-&gt;S</td>
<td>S</td>
<td>要求</td>
<td>对URL的SETUP请求指定用于流媒体的传输机制。客户端对正播放的流发布一个SETUP请求，以改变服务器允许的传输参数。如不允许这样做，响应错误为”455 Method Not Valid In This State”。为了透过防火墙，客户端必须指明传输参数，即使对这些参数没有影响</td>
</tr>
<tr>
<td style="text-align:center">SET_PARAMETER</td>
<td>C-&gt;S,S-&gt;C</td>
<td>P，S</td>
<td>可选</td>
<td>这个方法请求设置演示或URL指定流的参数值。请求仅应包含单个参数，允许客户端决定某个特殊请求为何失败。如请求包含多个参数，所有参数可成功设置，服务器必须只对该请求起作用。服务器必须允许参数可重复设置成同一值，但不让改变参数值。注意：媒体流传输参数必须用SETUP命令设置。将设置传输参数限制为SETUP有利于防火墙。将参数划分成规则排列形式，结果有更多有意义的错误指示</td>
</tr>
<tr>
<td style="text-align:center">TEARDOWN</td>
<td>C-&gt;S</td>
<td>S</td>
<td>要求</td>
<td>TEARDOWN请求停止给定URL流发送，释放相关资源。如URL是此演示URL，任何RTSP连接标识不再有效。除非全部传输参数是连接描述定义的，SETUP请求必须在连接可再次播放前发布</td>
</tr>
</tbody>
</table>
<ol>
<li><p>交互流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">C表示RTSP客户端,S表示RTSP服务端</span><br><span class="line"></span><br><span class="line">1. 第一步：查询服务器端可用方法</span><br><span class="line">1.C-&gt;S:OPTION request //询问S有哪些方法可用</span><br><span class="line"></span><br><span class="line">1.S-&gt;C:OPTION response //S回应信息的public头字段中包括提供的所有可用方法</span><br><span class="line"></span><br><span class="line">2. 第二步：得到媒体描述信息</span><br><span class="line">2.C-&gt;S:DESCRIBE request //要求得到S提供的媒体描述信息</span><br><span class="line"></span><br><span class="line">2.S-&gt;C:DESCRIBE response //S回应媒体描述信息，一般是sdp信息</span><br><span class="line"></span><br><span class="line">3. 第三步：建立RTSP会话</span><br><span class="line">3.C-&gt;S:SETUP request //通过Transport头字段列出可接受的传输选项，请求S建立会话</span><br><span class="line"></span><br><span class="line">3.S-&gt;C:SETUP response //S建立会话，通过Transport头字段返回选择的具体转输选项，并返回建立的Session ID;</span><br><span class="line"></span><br><span class="line">4. 第四步：请求开始传送数据</span><br><span class="line">4.C-&gt;S:PLAY request //C请求S开始发送数据</span><br><span class="line"></span><br><span class="line">4.S-&gt;C:PLAY response //S回应该请求的信息</span><br><span class="line"></span><br><span class="line">5. 第五步： 数据传送播放中</span><br><span class="line">S-&gt;C:发送流媒体数据 // 通过RTP协议传送数据</span><br><span class="line"></span><br><span class="line">6. 第六步：关闭会话，退出</span><br><span class="line">6.C-&gt;S:TEARDOWN request //C请求关闭会话</span><br><span class="line"></span><br><span class="line">6.S-&gt;C:TEARDOWN response //S回应该请求</span><br></pre></td></tr></table></figure>
</li>
<li><p>RTSP与HTTP区别</p>
</li>
</ol>
<ul>
<li>RTSP中客户端和服务器都可以发出请求,HTTP只能客户端发起请求；</li>
<li>RTSP相比HTTP提供多种方法定义</li>
<li>RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据</li>
</ul>
<h2 id="SDP-SIP"><a href="#SDP-SIP" class="headerlink" title="SDP/SIP"></a>SDP/SIP</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>SIP与SDP这两个协议会在国标视频上会出现比较多。其中一般会与RTSP等协议共同</p>
<p>SIP它是一个基于文本的应用层控制协议，独立于底层传输协议，用于建立、修改和终止IP网络上的双方或多方多媒体会话</p>
<p>SDP（Session Description Protocol）是一个用来描述多媒体会话的应用层控制协议，它是一个基于文本的协议，用于会话建立过程中的媒体类型和编码方案的协商等</p>
<h3 id="协议介绍-2"><a href="#协议介绍-2" class="headerlink" title="协议介绍"></a>协议介绍</h3><h4 id="SIP介绍"><a href="#SIP介绍" class="headerlink" title="SIP介绍"></a>SIP介绍</h4><ol>
<li>SIP 角色</li>
</ol>
<table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户代理（UA）</td>
<td>用户代理客户端（UAC）和用户代理服务器（UAS）组成，UAC负责发起呼叫，UAS负责接收呼叫并作出响应</td>
</tr>
<tr>
<td>代理服务器（PS）</td>
<td>通过它把来自用户代理客户端（UAC）的请求转发到用户代理服务端（UAS），并把UAS的响应消息转发回UAC</td>
</tr>
<tr>
<td>注册服务器（register server）</td>
<td>是具有接收注册请求、将请求中携带的信息进行保存并提供本域内位置服务的功能服务器</td>
</tr>
<tr>
<td>重定向服务器（redirect server）</td>
<td>负责规划SIP呼叫路由。它将获得的呼叫下一跳地址信息告诉呼叫方，以使呼叫方根据此地址直接向下一跳发出请求，此后重定向服务器退出呼叫过程。</td>
</tr>
</tbody>
</table>
<ol>
<li><p>SIP请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">是客户端发给服务器激活一个SIP操作的消息，由一个方法名（Method）、一个请求URI（Request-URI）和一个协议版本 （SIP-Version）组成，三个部分之间以空格（SP）间隔。</span><br><span class="line"></span><br><span class="line">Request-Line  =  Method + SP + Request-URI + SP + SIP-Version + CRLF</span><br><span class="line"></span><br><span class="line">RFC中定义了6中请求：</span><br><span class="line"></span><br><span class="line">INVITE：表明接收用户或服务被邀请加入一个会话；也可以使用这种方式来修改先前建立会话的特性；成功响应（200 OK）表明被叫方愿意参与会话；</span><br><span class="line"></span><br><span class="line">ACK：确认UAC已经接收到了INVITE请求的最终响应（只与INVITE请求一起使用）；用于结束一个200 OK响应；若INVITE请求中不含有会话描述信息，ACK可以包含一个最终会话描述的消息体；</span><br><span class="line"></span><br><span class="line">OPTION：UA用此向UAS查询它的功能；</span><br><span class="line"></span><br><span class="line">BYE：用于终结一个先前建立的会话；</span><br><span class="line"></span><br><span class="line">CANCEL：使UAC和网络服务器取消一个正在进行的请求（如INVITE）；</span><br><span class="line"></span><br><span class="line">REGISTER：客户端注册其目前的位置信息；</span><br></pre></td></tr></table></figure>
</li>
<li><p>SIP响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">服务器向客户端发送SIP响应，指明客户端先前发送给服务器的SIP请求的状态；由一个协议版本（SIP-Version），一个状态码（Status-Code）和一个原因说明（Reason-Phrase）组成，类似于请求消息，三个部分之间也以空格字符（SP）间隔。</span><br><span class="line"></span><br><span class="line">Status-Line := SIP-Version + SP + Status-Code + SP + Reason-Phrase + CRLF</span><br><span class="line"></span><br><span class="line">状态码是一个100～699之间的3位正整数（具体参见后面附录），它表示对于一个请求消息的响应结果；原因说明是一串可以显示的字符，用于对响应的状态码进行简短说明。</span><br><span class="line"></span><br><span class="line">1xx：临时响应 （Provisional）；之前的请求消息已经收到，并准备接着处理后面的请求消息。</span><br><span class="line"></span><br><span class="line">2xx：成功响应 （Success）； 操作成功，请求消息已被收到并且成功地处理。</span><br><span class="line"></span><br><span class="line">3xx：重定向响应 （Redirection）； 服务器向客户端返回其它可能的位置，客户端应当根据响应中包含的地址信息向另一个服务器重发请求消息。</span><br><span class="line"></span><br><span class="line">4xx： 客户端错误 （Client Error）； 请求由于客户端的错误而失败，客户端可以根据响应状态码修改并重发刚才的请求消息。</span><br><span class="line"></span><br><span class="line">5xx：服务器错误 （Server Error） ；请求由于服务器的错误而失败，客户端可以向另一个服务器重发请求消息。</span><br><span class="line"></span><br><span class="line">6xx：全局错误（Global Failure）； 请求失败，客户端不应该再向任何服务器重发该请求消息。</span><br></pre></td></tr></table></figure>
</li>
<li><p>标题头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">遵从HTTP标题头（RFC2616）定义的同样格式：每个标题头由字段名，紧跟着冒号(:)和字段组成。</span><br><span class="line"></span><br><span class="line">主要标题头（详情参见</span><br><span class="line"></span><br><span class="line">SIP常见头域（header）说明</span><br><span class="line"></span><br><span class="line">From：定义请求发起者（通常是发送者AOR），包含SIP或SIP URI和一个可选的显示名字；</span><br><span class="line"></span><br><span class="line">To：定义了请求的接收者（通常是接收者AOR），包含SIP或SIP URI和一个可选的显示名字；因重定向和转移，SIP请求不一定发送给‘希望的’接收者；</span><br><span class="line"></span><br><span class="line">Call-ID：定义了一系列的SIP消息，对所有由对话中的UA发送的所有SIP请求和响应，Call-ID必须唯一；</span><br><span class="line"></span><br><span class="line">Cseq：由一个整数值和一个方式名称组成，在一个对话中标识和序列SIP请求，也区分重传和新消息；</span><br><span class="line"></span><br><span class="line">Via：定义请求路径和响应要发送的地址；</span><br><span class="line"></span><br><span class="line">Contact：定义US希望接收新SIP请求的SIP或SIPS URI（实际地址）；</span><br><span class="line"></span><br><span class="line">Allow：列出产生SIP消息的UA所支持的功能集合；</span><br><span class="line"></span><br><span class="line">Supported：列出所有UA支持的SIP扩展（RFC3262）；</span><br><span class="line"></span><br><span class="line">Require：包含远端UA必须支持的SIP扩展；</span><br><span class="line"></span><br><span class="line">Content-Type：请求或响应的消息体类型；</span><br><span class="line"></span><br><span class="line">Content-Length：请求或响应的消息体的大小（十进制）；</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="SDP协议"><a href="#SDP协议" class="headerlink" title="SDP协议"></a>SDP协议</h4><p>SDP协议内容(具体可参考国标规范文档)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 v=:Version ，表示协议的版本号</span><br><span class="line">2 o=: Origin,表示源。值域中各项的含义依次是username(用户名)，sess-id(会话ID)，sess-version(会话版本号)，nettype(网络类型)，addrtype(地址类型)，unucast-address(单播地址)。</span><br><span class="line">3 s=:Session Name,表示本sdp所描述的session的名称</span><br><span class="line">4 c=:Connection Data 链接数据。其中值域中以空格分配的两个字段分贝是网络类型和网络地址，以后的RTP流就会发到该地址上。</span><br><span class="line">5 b=:Badwidth type，带宽类型</span><br><span class="line">6 t=:Timing ,起止时间，0表示无限</span><br><span class="line">7 m=:audio Media Type,媒体类型。audio表示音频，50452表示音频端口号，RTP/AVR是传输协议；后面是支持的Codec类型，与RTP流中的PayloadType(载荷类型)相对应，在这里分别是8,0,98和101,8和0分别代表PCMA和PCMU，他们属于静态编码，大于95的编码都属于动态编码，需要在后面使用“a=rtpmap”进行说明。</span><br><span class="line">8 a=: Attributes,属性。 它用于描述上面的音频的属性。如本例中98代表8000hz的ILBC编码，101代表RFC2833dtmf事件。a=sendrecv表示该媒体流可用于收和发，其他的还有sendonly(仅收)，recvonly(仅发)和inactive(不收不发)</span><br><span class="line">9 v=:Video，视频。</span><br></pre></td></tr></table></figure></p>
<h4 id="点播流程"><a href="#点播流程" class="headerlink" title="点播流程"></a>点播流程</h4><p>为了更加熟悉SIP的流程，截取点播流程的流程图。可以看出，SIP传输过程当中都会有SDP的使用。</p>
<p><img src="/images/video/wps2.png" alt="SIP点播流程"></p>
<h2 id="RTMP-HTTP-HLS-HTTP-FLV"><a href="#RTMP-HTTP-HLS-HTTP-FLV" class="headerlink" title="RTMP/HTTP-HLS/HTTP-FLV"></a>RTMP/HTTP-HLS/HTTP-FLV</h2><p>RTMP、HTTP-HLS与HTTP-FLV目前市面上比较常用的流媒体协议，都能基于浏览器来观看。</p>
<ul>
<li><p>RTMP：实时消息传送协议，基于FLASH播放器的私有协议，默认使用端口 1935。RTMP一般被切割一个个块（chunk）的形式基于TCP协议上传输的明文协议。市面上的摄像头基本都会支持RTMP的形式，而且RTMP一般延时在 1-3s 之间相对延时较低，不过目前来说谷歌禁用了FLASH，可能对RTMP支持可能有所减弱</p>
</li>
<li><p>HTTP-HLS：HTTP Live Streaming，苹果公司基于HTTP的流媒体传输协议。工作原理是在服务端将视频流切片成ts小文件形式，通过m3u8索引文件访问ts文件。不过HLS的延迟在10s以上，且文件比较碎片化比较难以保存，但是有利有弊，正因为有ts文件落地，可支持回放等功能。</p>
</li>
<li><p>HTTP-FLV：Flash Video，主要是将音视频数据封装成FLV格式，然后通过 HTTP 协议传输给客户端。像B站都是使用该协议进行PC页面播放。FLV延迟比较低。</p>
</li>
<li><p>ws-flv：ws-flv直播技术基本与http-flv一致，无非是传输介质换成了websocket协议，除了解除了http-flv不能同时打开过多同域名下的直播窗口的限制，其他技术特性、参数基本与http-flv一致。目前看，ws-flv既适合视频监控(可以同时打开多路监控视频)也适合视频直播行业，是rtmp很高的升级替代方案。</p>
</li>
<li>webrtc：webrtc是谷歌主导的视频通话技术标准，目前各大主流浏览器都兼容该标准。通过该技术，用户可以在浏览器上实现无插件的视频通话，该技术也可以用于实现低延时的视频直播。目前业界也有很多基于webrtc的应用和产品，但是很多局限于视频聊天等低延时交互式场景，在视频监控领域，目前还尚未流行。而且该技术栈目前还在持续更新，技术难点太多，要与视频监控领域融合还需时日。</li>
</ul>
<h3 id="协议介绍-3"><a href="#协议介绍-3" class="headerlink" title="协议介绍"></a>协议介绍</h3><h4 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h4><p><img src="/images/video/hls-message.png" alt="RTMP"></p>
<p>具体可参考：<a href="https://www.jianshu.com/p/d511d59b185c" target="_blank" rel="noopener">RTMP协议详解</a></p>
<h4 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h4><p><a href="https://www.jianshu.com/p/d511d59b185c" target="_blank" rel="noopener">HLS协议详解</a></p>
<p>以下简单介绍下m3u8的相关内容</p>
<p><img src="/images/video/hls.png" alt="m3u8"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">EXTM3U：每个M3U文件第一行必须是这个tag，请标示作用</span><br><span class="line"></span><br><span class="line">EXT-X-MEDIA-SEQUENCE:7</span><br><span class="line">每一个media URI 在 PlayList中只有唯一的序号，相邻之间序号+1, 一个media URI并不是必须要包含的，如果没有，默认为0</span><br><span class="line"></span><br><span class="line">EXTINF:</span><br><span class="line">duration 指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效，title是下载资源的url</span><br><span class="line"></span><br><span class="line">EXT-X-TARGETDURATION</span><br><span class="line">指定最大的媒体段时间长（秒）。所以#EXTINF中指定的时间长度必须小于或是等于这个最大值。这个tag在整个PlayList文件中只能出现一 次（在嵌套的情况下，一般有真正ts url的m3u8才会出现该tag）</span><br><span class="line"></span><br><span class="line">EXT-X-KEY</span><br><span class="line">表示怎么对media segments进行解码。其作用范围是下次该tag出现前的所有media URI，属性为NONE 或者 AES-128。NONE表示 URI以及IV（Initialization Vector）属性必须不存在， AES-128(Advanced EncryptionStandard)表示URI必须存在，IV可以不存在。</span><br><span class="line">对于AES-128的情况，keytag和URI属性共同表示了一个key文件，通过URI可以获得这个key，如果没有IV（Initialization Vector）,则使用序列号作为IV进行编解码，将序列号的高位赋到16个字节的buffer中，左边补0；如果有IV，则将改值当成16个字节的16进制数。</span><br><span class="line"></span><br><span class="line">EXT-X-PROGRAM-DATE-TIME</span><br><span class="line">将一个绝对时间或是日期和一个媒体段中的第一个sample相关联，只对下一个meida URI有效，格式如#EXT-X-PROGRAM-DATE-TIME:</span><br><span class="line">For example: #EXT-X-PROGRAM-DATE-TIME:2010-02-19T14:54:23.031+08:00</span><br><span class="line"></span><br><span class="line">EXT-X-ALLOW-CACHE</span><br><span class="line">是否允许做cache，这个可以在PlayList文件中任意地方出现，并且最多出现一次，作用效果是所有的媒体段。格式如下：#EXT-X-ALLOW-CACHE:</span><br><span class="line"></span><br><span class="line">EXT-X-PLAYLIST-TYPE</span><br><span class="line">提供关于PlayList的可变性的信息， 这个对整个PlayList文件有效，是可选的，格式如下：#EXT-X-PLAYLIST-TYPE:：如果是VOD，则服务器不能改变PlayList 文件；如果是EVENT，则服务器不能改变或是删除PlayList文件中的任何部分，但是可以向该文件中增加新的一行内容。</span><br><span class="line"></span><br><span class="line">EXT-X-ENDLIST</span><br><span class="line">表示PlayList的末尾了，它可以在PlayList中任意位置出现，但是只能出现一个，格式如下：#EXT-X-ENDLIST</span><br><span class="line"></span><br><span class="line">EXT-X-MEDIA</span><br><span class="line">被用来在PlayList中表示相同内容的不用语种/译文的版本，比如可以通过使用3个这种tag表示3中不用语音的音频，或者用2个这个tag表示不同角度的video在PlayLists中。这个标签是独立存在的，属性包含：</span><br><span class="line">URI：如果没有，则表示这个tag描述的可选择版本在主PlayList的EXT-X-STREAM-INF中存在;</span><br><span class="line">TYPE:AUDIO and VIDEO;</span><br><span class="line">GROUP-ID:具有相同ID的MEDIAtag，组成一组样式；</span><br><span class="line">LANGUAGE：确定使用的主要语言</span><br><span class="line">NAME：人类可读的语言的翻译</span><br><span class="line">DEFAULT：YES或是NO，默认是No，如果是YES，则客户端会以这种选项来播放，除非用户自己进行选择。</span><br><span class="line">AUTOSELECT：YES或是NO，默认是No，如果是YES，则客户端会根据当前播放环境来进行选择（用户没有根据自己偏好进行选择的前提下）。</span><br><span class="line"></span><br><span class="line">EXT-X-STREAM-INF</span><br><span class="line">指定一个包含多媒体信息的 media URI 作为PlayList，一般做M3U8的嵌套使用，它只对紧跟后面的URI有效，格式如下：#EXT-X-STREAM-INF:有以下属性：</span><br><span class="line">BANDWIDTH：带宽，必须有。</span><br><span class="line">PROGRAM-ID：该值是一个十进制整数，惟一地标识一个在PlayList文件范围内的特定的描述。一个PlayList 文件中可能包含多个有相同ID的此tag。</span><br><span class="line">CODECS：不是必须的。</span><br><span class="line">RESOLUTION：分辨率。</span><br><span class="line">AUDIO：这个值必须和AUDIO类别的“EXT-X-MEDIA”标签中“GROUP-ID”属性值相匹配。</span><br><span class="line">VIDEO：同上</span><br></pre></td></tr></table></figure>
<h4 id="FLV"><a href="#FLV" class="headerlink" title="FLV"></a>FLV</h4><p><a href="https://zhuanlan.zhihu.com/p/287220" target="_blank" rel="noopener">FLV协议详解</a></p>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p><img src="/images/video/协议性能对比.png" alt="协议性能对比"></p>
<h2 id="PES-TS-ES流"><a href="#PES-TS-ES流" class="headerlink" title="PES/TS/ES流"></a>PES/TS/ES流</h2><p>PES、TS、ES流都是用于封装视频、音频数据的数据流。</p>
<p>ES流（Elementary Stream）：基本码流，不分段的音频、视频或其他信息的连续码流。</p>
<p>PES流：把基本流ES分割成段，并加上相应头文件打包成形的打包基本码流。</p>
<p>PS流（Program Stream）：节目流，将具有共同时间基准的一个或多个PES组合（复合）而成的单一数据流（用于播放或编辑系统，如m2p）。</p>
<p>TS流（Transport Stream）：传输流，将具有共同时间基准或独立时间基准的一个或多个PES组合（复合）而成的单一数据流（用于数据传输）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面列了很多我在项目中所有用到过的协议，每种协议都有不同的封装格式以及各自不同属性，个人觉得对于开发者或者使用者来说不一定每种协议都要面面俱到，平常大概知道他们具体作用性能和普遍的属性之类就可以，到真正使用的时候再去深入了解，反而会更高效。以下，我总结下这段时间来对这几个协议的了解：<br>    <img src="/images/video/zlm.png" alt="协议"></p>
<p>根据上图可以看出，一般来说推流的方式可能会议国标方式或者接入海康、大华等厂商的摄像头来直接推流到流媒体，而从流媒体转码成flv,hls等不同协议供客户端来拉流访问。</p>
<p>参考</p>
<ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/72917813" target="_blank" rel="noopener">关于RTSP/RTP/RTCP</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/news/387488" target="_blank" rel="noopener">会话初始协议SIP与SDP简介</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/48100533" target="_blank" rel="noopener">RTMP、HTTP-FLV、HLS，你了解常见的三大直播协议吗
</a></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Jay-Luo" />
            
              <p class="site-author-name" itemprop="name">Jay-Luo</p>
              <p class="site-description motion-element" itemprop="description">小小的天，大大的梦</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yourname" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jay-Luo</span>

  
</div>


  <div class="powered-by">个人专属</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">博客 &mdash; NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
