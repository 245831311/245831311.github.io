<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="小小的天，大大的梦">
<meta property="og:type" content="website">
<meta property="og:title" content="Jay-Luo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Jay-Luo">
<meta property="og:description" content="小小的天，大大的梦">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jay-Luo">
<meta name="twitter:description" content="小小的天，大大的梦">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Jay-Luo</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bc6214a71594310d314698ac546aca76";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jay-Luo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小小的天，大大的梦</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/gateway源码分析(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/25/gateway源码分析(一)/" itemprop="url">Gateway源码分析（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-25T11:16:39+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当选用了SpringCloud Gateway作为视频项目的网关之后,出于学习的心态，看下视频网关是如何构造起来的。</p>
<h2 id="Spring-WebFlux学习"><a href="#Spring-WebFlux学习" class="headerlink" title="Spring WebFlux学习"></a>Spring WebFlux学习</h2><p>阅读源码之前首先学习下WebFlux基础概念和相关常用的API</p>
<p>Spring WebFlux简单说是与Spring MVC类似的一门响应式异步非阻塞Web端控制框架。与Spring MVC有着相同功能的注解</p>
<ol>
<li>什么是响应式编程(Reactive)</li>
</ol>
<p>官方解释：</p>
<blockquote>
<p>The term, “reactive,”  refers to programming models that are built around reacting to change<br>响应式编程是一种围绕对变化作出反应而构建的编程模型。</p>
</blockquote>
<p>后面给出了例子：</p>
<blockquote>
<p>network components reacting to I/O events, UI controllers reacting to mouse events, and others. In that sense, non-blocking is reactive, because, instead of being blocked, we are now in the mode of reacting to notifications as operations complete or data becomes available.<br>网络组件对IO事件的响应，UI控制器对鼠标事件的响应。从这个意义上说，非阻塞也是响应式,因为我们现在也是在操作完成或者数据可用的时候作出响应的模式，而不是被阻塞。</p>
</blockquote>
<ol>
<li>什么是背压（back pressure）</li>
</ol>
<p>官方解析：</p>
<blockquote>
<p>Reactive Streams is a small spec (also adopted in Java 9) that defines the interaction between asynchronous components with back pressure. For example a data repository (acting as Publisher) can produce data that an HTTP server (acting as Subscriber) can then write to the response. The main purpose of Reactive Streams is to let the subscriber control how quickly or how slowly the publisher produces data.<br>响应式流是一个小小的规范，定义了带有背压异步组件交互。例如，数据仓库（作为发布者）产生数据使HTTP服务（作为订阅者）能响应。主要目的就是响应式能让订阅者控制发布者发布数据的快与慢。</p>
</blockquote>
<p>其实上述说白了就是订阅者能够通过生产者需要多小数据，这样能够以免生产者无限量产生数据压垮订阅者。</p>
<ol>
<li>SpringMVC与WebFlux选择<br><img src="https://docs.spring.io/spring-framework/docs/current/reference/html/images/spring-mvc-and-webflux-venn.png" alt="webFlux&amp;SpringMVC"></li>
</ol>
<ul>
<li><p>如果您有运行正常的Spring MVC应用程序，则无需更改。命令式编程是编写，理解和调试代码的最简单方法。您有最大的库选择空间，因为从历史上看，大多数库都是阻塞的。</p>
</li>
<li><p>如果您已经在选择无阻塞的Web堆栈，Spring WebFlux可以提供与该领域其他服务器相同的执行模型优势，还可以选择服务器（Netty，Tomcat，Jetty，Undertow和Servlet 3.1+容器），选择编程模型（带注释的控制器和功能性Web端点），以及选择反应式库（Reactor，RxJava或其他）。</p>
</li>
<li><p>如果您对与Java 8 lambda或Kotlin一起使用的轻量级功能性Web框架感兴趣，则可以使用Spring WebFlux功能性Web端点。对于要求较低复杂性的较小应用程序或微服务（可以受益于更高的透明度和控制）而言，这也是一个不错的选择。</p>
</li>
<li><p>在微服务架构中，您可以混合使用带有Spring MVC或Spring WebFlux控制器或带有Spring WebFlux功能端点的应用程序。在两个框架中都支持相同的基于注释的编程模型，这使得重用知识变得更加容易，同时还为正确的工作选择了正确的工具。</p>
</li>
<li><p>评估应用程序的一种简单方法是检查其依赖关系。如果您要使用阻塞性持久性API（JPA，JDBC）或网络API，则Spring MVC至少是通用体系结构的最佳选择。使用Reactor和RxJava在单独的线程上执行阻塞调用在技术上是可行的，但您不会充分利用非阻塞Web堆栈。</p>
</li>
<li><p>如果您的Spring MVC应用程序具有对远程服务的调用，请尝试使用active WebClient。您可以直接从Spring MVC控制器方法返回反应类型（Reactor，RxJava或其他）。每个呼叫的等待时间或呼叫之间的相互依赖性越大，好处就越明显。Spring MVC控制器也可以调用其他反应式组件。</p>
</li>
</ul>
<ol>
<li>WebFlux提供了两种模型</li>
</ol>
<ul>
<li>注解控制器（Annotated Controllers）：与Spring MVC有一致的注解，都是基于spring-web模型。一个显著的区别是，WebFlux也支持响应式@RequestBody参数。</li>
<li>函数终端（Functional Endpoints）：基于Lambda,轻量级和函数编程模型。提供了大量的方法来路由和处理请求。与注解控制器（Annotated Controllers）最大区别就是函数端模型能够负责请求的从头到尾的处理而不是只是通过声明注解然后回调。</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>两个Publisher接口：Flux与Mono。两者区别在于Flux是代表多个元素的发布者，Mono是单个元素的发布者.</p>
<p>Mono 实现了 Publisher 接口，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">empty()：创建一个不包含任何元素，只发布结束消息的序列。</span><br><span class="line">just()：可以指定序列中包含的全部元素。创建出来的 Mono序列在发布这些元素之后会自动结束。</span><br><span class="line">justOrEmpty()：从一个 Optional 对象或可能为 null 的对象中创建 Mono。只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。</span><br><span class="line">error(Throwable error)：创建一个只包含错误消息的序列。</span><br><span class="line">never()：创建一个不包含任何消息通知的序列。</span><br><span class="line">fromCallable()、fromCompletionStage()、fromFuture()、fromRunnable()和 fromSupplier()：分别从 Callable、CompletionStage、CompletableFuture、Runnable 和 Supplier 中创建 Mono。</span><br><span class="line">delay(Duration duration)和 delayMillis(long duration)：创建一个 Mono 序列，在指定的延迟时间之后，产生数字 0 作为唯一值。</span><br><span class="line">create()：通过 create()方法来使用 MonoSink 来创建 Mono。</span><br></pre></td></tr></table></figure></p>
<p>Flux<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">just：可以指定序列中包含的全部元素。创建出来的 Flux 序列在发布这些元素之后会自动结束。</span><br><span class="line">fromArray、fromIterable、fromStream：可以从一个数组、Iterable 对象或 Stream 对象中创建 Flux 对象。</span><br><span class="line">empty()：创建一个不包含任何元素，只发布结束消息的序列,在响应式编程中，流的传递是基于元素的，empty表示没有任何元素，所以不会进行后续传递，需要用switchIfEmpty等处理</span><br><span class="line">error(Throwable error)：创建一个只包含错误消息的序列。</span><br><span class="line">never()：创建一个不包含任何消息通知的序列。使用示例：</span><br><span class="line">range(int start, int count)：创建包含从 start 起始的 count 个数量的 Integer 对象的序列。</span><br><span class="line">intervalMillis(long period)： interval()方法的作用相同，只不过该方法通过毫秒数来指定时间间隔和延迟时间。</span><br><span class="line">create()：与 generate()方法的不同之处在于所使用的是 FluxSink 对象。FluxSink 支持同步和异步的消息产生，并且可以在一次调用中产生多个元素。</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章主要是简单记录下WebFlux的介绍以及简单说明下WebFlux相关的几个概念。WebFlux的官方文档还是相对比较完善的，里面都有挺详细的说明，我就不一一照搬到这里。下一章就开始阅读Gateway的代码，看下Gateway里面是如何使用WebFlux构建网关。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#spring-webflux" target="_blank" rel="noopener">webFlux官网</a></li>
</ul>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/92460075" target="_blank" rel="noopener">外行人都能看得懂的WebFlux</a></li>
</ul>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485692&amp;idx=1&amp;sn=a6b3f040b13fa2324992b11a927e34dc&amp;chksm=ebd749fddca0c0eb1b05c08ede7ee4a44699584fbc0c3449ec2cac7642fd13819470ec7f44d8&amp;token=1024331018&amp;lang=zh_CN#rd" target="_blank" rel="noopener">最近学到的Lambda表达式基础知识</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/Gateway源码分析(二)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/25/Gateway源码分析(二)/" itemprop="url">Gateway源码分析（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-25T11:16:39+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>这一章开始记录我开始Gateway阅读之路，看下究竟是如何实现网关。</p>
<h1 id="个人疑问"><a href="#个人疑问" class="headerlink" title="个人疑问"></a>个人疑问</h1><ol>
<li><p>Gateway的网关框架是如何接收请求并转发</p>
</li>
<li><p>如何执行Filter</p>
</li>
<li><p>如何加载路由、过滤器、断言等信息</p>
</li>
</ol>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactI&gt;</span><br><span class="line">	&lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>还是一样的图<br><img src="/images/video/gateway网关图.png" alt="Gateway框架"></p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>gateway-core.jar是gateway的核心包，主要的实现都在里面。阅读代码前最好先知道个个包的主要功能.</p>
<p><img src="/images/video/gateway的jar包架构图.png" alt="包组成"></p>
<ul>
<li>actuate</li>
</ul>
<p>该包主要是gateway自带的一个控制器GatewayControllerEndpoint，该endpiont提供了关于filter及routes的信息查询以及指定route信息更新的rest api，这给web界面提供管理配置功能提供了极大的便利</p>
<ul>
<li>config</li>
</ul>
<p>该包主要是Gateway的配置实体类，譬如yml上面的配置GatewayProperties、全局的跨域配置GlobalCorsProperties等等。</p>
<ul>
<li>discovery</li>
</ul>
<p>该包主要是实现服务发现的功能。从服务注册中心获取服务注册信息，然后配置相应的路由</p>
<ul>
<li>event</li>
</ul>
<p>该包是一些发布事件的定义。</p>
<ul>
<li>filter</li>
</ul>
<p>该包包含了gateway所有内置的过滤器。</p>
<ul>
<li>handler</li>
</ul>
<p>该包主要包括了所有内置的Predicates断言，RoutePredicateHandlerMapping类是一个实现了将接收请求到转发到filter里面的功能，FilteringWebHandler主要是构造过滤器链。</p>
<ul>
<li>route</li>
</ul>
<p>该包主要是定义路由信息，构造路由等。</p>
<ul>
<li>support</li>
</ul>
<p>该包主要是一些工具方法。用于全局。</p>
<h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="问题一：如何转发请求"><a href="#问题一：如何转发请求" class="headerlink" title="问题一：如何转发请求"></a>问题一：如何转发请求</h3><h4 id="DispatchHandler类"><a href="#DispatchHandler类" class="headerlink" title="DispatchHandler类"></a>DispatchHandler类</h4><p>WebFlux请求转发核心类：DispatchHandler</p>
<p>DispatchHandler内部主要的私有字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerResultHandler&gt; resultHandlers;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>HandlerMapping</td>
<td>映射请求到一个处理器。该映射是基于一定的标准、细节因不同HandlerMapping而不同。<br>例如有注解控制器, 简单URL匹配映射等等。<br>主要的HandlerMapping实现：<br>1.有RequestMappingHandlerMapping对于注解的@RequestMapping。<br>2.RouterFunctionMapping 对应于函数式端点路由。<br>3.SimpleUrlHandlerMappingURI路径模式的显式注册。<br>4.WebHandler的实例</td>
</tr>
<tr>
<td>HandlerAdapter</td>
<td>帮助DispatcherHandler调用映射的请求的处理器，而不管该处理程序实际上是如何调用的。<br>例如执行一个注解控制器需要解释注解。其主要目的是帮助DispatcherHandler隐藏实现的细节。</td>
</tr>
<tr>
<td>HandlerResultHandler</td>
<td>处理程序调用的结果并最后确定响应。<br>1.ResponseEntityResultHandler：ResponseEntity，处理@Controller实例。<br>2.ServerResponseResultHandler：ServerResponse，处理函数式端点。<br>3.ResponseBodyResultHandler：处理从@ResponseBody方法和@RestController类的返回值。<br>4.ViewResolutionResultHandler：处理成CharSequence,View, Model, Map, Rendering等其他的模型属性。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Mono.error(HANDLER_NOT_FOUND_EXCEPTION);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Flux.fromIterable(<span class="keyword">this</span>.handlerMappings)</span><br><span class="line">			.concatMap(mapping -&gt; mapping.getHandler(exchange))</span><br><span class="line">			.next()</span><br><span class="line">			.switchIfEmpty(Mono.error(HANDLER_NOT_FOUND_EXCEPTION))</span><br><span class="line">			.flatMap(handler -&gt; invokeHandler(exchange, handler))</span><br><span class="line">			.flatMap(result -&gt; handleResult(exchange, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心方法主要做了三个步骤：</p>
<ol>
<li>匹配每一个不同HandlerMapping，使用首先匹配的那个。</li>
<li>执行器被找到就会找到对应的HandlerAdapter,然后就会将返回结果返回到HandlerResult里。</li>
<li>HandlerResult会给出一个合适的处理器去完成直接写到响应里面或者使用View来渲染的处理。</li>
</ol>
<h4 id="RoutePredicateHandlerMapping类"><a href="#RoutePredicateHandlerMapping类" class="headerlink" title="RoutePredicateHandlerMapping类"></a>RoutePredicateHandlerMapping类</h4><p>刚说完DispatchHandler的类，就到HandlerMapping了，类RoutePredicateHandlerMapping实现了HandlerMapping。</p>
<p>其核心私有字段分别有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FilteringWebHandler webHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RouteLocator routeLocator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer managmentPort;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>Bean类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>webHandler</td>
<td>构建过滤器的责任链</td>
</tr>
<tr>
<td>routeLocator</td>
<td>路由的定义信息</td>
</tr>
<tr>
<td>managmentPort</td>
<td>gateway管理端口</td>
</tr>
</tbody>
</table>
<p>其核心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Mono&lt;?&gt; getHandlerInternal(ServerWebExchange exchange) &#123;</span><br><span class="line">	<span class="comment">// don't handle requests on the management port if set</span></span><br><span class="line">	<span class="keyword">if</span> (managmentPort != <span class="keyword">null</span> &amp;&amp; exchange.getRequest().getURI().getPort() == managmentPort.intValue()) &#123;</span><br><span class="line">		<span class="keyword">return</span> Mono.empty();</span><br><span class="line">	&#125;</span><br><span class="line">	exchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lookupRoute(exchange)</span><br><span class="line">			<span class="comment">// .log("route-predicate-handler-mapping", Level.FINER) //name this</span></span><br><span class="line">			.flatMap((Function&lt;Route, Mono&lt;?&gt;&gt;) r -&gt; &#123;</span><br><span class="line">				exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Mapping ["</span> + getExchangeDesc(exchange) + <span class="string">"] to "</span> + r);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				exchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);</span><br><span class="line">				<span class="keyword">return</span> Mono.just(webHandler);</span><br><span class="line">			&#125;).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">				exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">"No RouteDefinition found for ["</span> + getExchangeDesc(exchange) + <span class="string">"]"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该核心方法做了几件事：</p>
<ol>
<li>找到合适的路由lookupRoute方法。</li>
<li>将路由信息放到ServerWebExchange请求线程的属性里，以便整个运行随时可用。</li>
<li>执行webHandler中的过滤器链。==（后面会介绍如何执行）==</li>
</ol>
<p>lookupRoute执行过程：</p>
<ol>
<li>通过routeLocator的获取所有配置好的路由信息。 ==（后面会介绍如何加载路由信息、过滤器、断言）==</li>
<li>匹配每一个路由的断言，是否符合，若符合则返回对应的路由信息。若不符合则next()下一个路由的断言匹配。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Mono&lt;Route&gt; <span class="title">lookupRoute</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.routeLocator</span><br><span class="line">			.getRoutes()</span><br><span class="line">			<span class="comment">//individually filter routes so that filterWhen error delaying is not a problem</span></span><br><span class="line">			.concatMap(route -&gt; Mono</span><br><span class="line">					.just(route)</span><br><span class="line">					.filterWhen(r -&gt; &#123;</span><br><span class="line">						<span class="comment">// add the current route we are testing</span></span><br><span class="line">						exchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());</span><br><span class="line">						<span class="keyword">return</span> r.getPredicate().apply(exchange);</span><br><span class="line">					&#125;)</span><br><span class="line">					<span class="comment">//instead of immediately stopping main flux due to error, log and swallow it</span></span><br><span class="line">					.doOnError(e -&gt; logger.error(<span class="string">"Error applying predicate for route: "</span>+route.getId(), e))</span><br><span class="line">					.onErrorResume(e -&gt; Mono.empty())</span><br><span class="line">			)</span><br><span class="line">			<span class="comment">// .defaultIfEmpty() put a static Route not found</span></span><br><span class="line">			<span class="comment">// or .switchIfEmpty()</span></span><br><span class="line">			<span class="comment">// .switchIfEmpty(Mono.&lt;Route&gt;empty().log("noroute"))</span></span><br><span class="line">			.next()</span><br><span class="line">			<span class="comment">//<span class="doctag">TODO:</span> error handling</span></span><br><span class="line">			.map(route -&gt; &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Route matched: "</span> + route.getId());</span><br><span class="line">				&#125;</span><br><span class="line">				validateRoute(route, exchange);</span><br><span class="line">				<span class="keyword">return</span> route;</span><br><span class="line">			&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题二：如何执行Filter"><a href="#问题二：如何执行Filter" class="headerlink" title="问题二：如何执行Filter"></a>问题二：如何执行Filter</h3><h4 id="如何执行Filter-FilteringWebHandler类"><a href="#如何执行Filter-FilteringWebHandler类" class="headerlink" title="如何执行Filter(FilteringWebHandler类)"></a>如何执行Filter(FilteringWebHandler类)</h4><p>执行流程：</p>
<ol>
<li>初始化时候构造好全局的过滤器集合。</li>
<li>合并路由上配置的过滤器与全局过滤器</li>
<li>排序好所有过滤器传入DefaultGatewayFilterChain的责任链里执行。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Mono&lt;Void&gt; handle(ServerWebExchange exchange) &#123;</span><br><span class="line">	Route route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);</span><br><span class="line">	List&lt;GatewayFilter&gt; gatewayFilters = route.getFilters();</span><br><span class="line"></span><br><span class="line">	List&lt;GatewayFilter&gt; combined = new ArrayList&lt;&gt;(this.globalFilters);</span><br><span class="line">	combined.addAll(gatewayFilters);</span><br><span class="line">	//TODO: needed or cached?</span><br><span class="line">	AnnotationAwareOrderComparator.sort(combined);</span><br><span class="line"></span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Sorted gatewayFilterFactories: &quot;+ combined);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return new DefaultGatewayFilterChain(combined).filter(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>责任链是一个常用的编程设计模式，它能够将请求与处理步骤解耦，请求操作对链内部的执行透明，而且每个链子都有自己具体实现，能够自由组装复用，不相互影响，使得代码更加简洁。不过责任联在调试方面相对来说比较麻烦，不便于观察等缺点。</p>
<p>看下如何构造一个责任联，内部类DefaultGatewayFilterChain<br>的filter方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultGatewayFilterChain</span> <span class="keyword">implements</span> <span class="title">GatewayFilterChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> List&lt;GatewayFilter&gt; filters;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">DefaultGatewayFilterChain</span><span class="params">(List&lt;GatewayFilter&gt; filters)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.filters = filters;</span><br><span class="line">			<span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">DefaultGatewayFilterChain</span><span class="params">(DefaultGatewayFilterChain parent, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.filters = parent.getFilters();</span><br><span class="line">			<span class="keyword">this</span>.index = index;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> List&lt;GatewayFilter&gt; <span class="title">getFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> filters;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Mono.defer(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.index &lt; filters.size()) &#123;</span><br><span class="line">					GatewayFilter filter = filters.get(<span class="keyword">this</span>.index);</span><br><span class="line">					DefaultGatewayFilterChain chain = <span class="keyword">new</span> DefaultGatewayFilterChain(<span class="keyword">this</span>, <span class="keyword">this</span>.index + <span class="number">1</span>);</span><br><span class="line">					<span class="keyword">return</span> filter.filter(exchange, chain);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> Mono.empty(); <span class="comment">// complete</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="问题三：如何加载路由、过滤器、断言等信息"><a href="#问题三：如何加载路由、过滤器、断言等信息" class="headerlink" title="问题三：如何加载路由、过滤器、断言等信息"></a>问题三：如何加载路由、过滤器、断言等信息</h3><h4 id="RouteDefinitionRouteLocator类"><a href="#RouteDefinitionRouteLocator类" class="headerlink" title="RouteDefinitionRouteLocator类"></a>RouteDefinitionRouteLocator类</h4><ul>
<li>获取路由信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Flux&lt;Route&gt; getRoutes() &#123;</span><br><span class="line">	return this.routeDefinitionLocator.getRouteDefinitions()</span><br><span class="line">			.map(this::convertToRoute)</span><br><span class="line">			//TODO: error handling</span><br><span class="line">			.map(route -&gt; &#123;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;RouteDefinition matched: &quot; + route.getId());</span><br><span class="line">				&#125;</span><br><span class="line">				return route;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/* TODO: trace logging</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;RouteDefinition did not match: &quot; + routeDefinition.getId());</span><br><span class="line">		&#125;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==this.routeDefinitionLocator.getRouteDefinitions()== 初始化首次加载获取配置文件中定义的路由信息并存于缓存中以便下次使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public CachingRouteDefinitionLocator(RouteDefinitionLocator delegate) &#123;</span><br><span class="line">		this.delegate = delegate;</span><br><span class="line">		routeDefinitions = CacheFlux.lookup(cache, &quot;routeDefs&quot;, RouteDefinition.class)</span><br><span class="line">				.onCacheMissResume(this.delegate::getRouteDefinitions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>==convertToRoute==则是将配置信息定义的路由信息转变为真正内部使用的路由实体，具体实现如下：</p>
<ol>
<li>组装断言链表</li>
<li>获取配置信息定义过滤器</li>
<li>组装成真正路由对象Route<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Route convertToRoute(RouteDefinition routeDefinition) &#123;</span><br><span class="line">		AsyncPredicate&lt;ServerWebExchange&gt; predicate = combinePredicates(routeDefinition);</span><br><span class="line">		List&lt;GatewayFilter&gt; gatewayFilters = getFilters(routeDefinition);</span><br><span class="line"></span><br><span class="line">		return Route.async(routeDefinition)</span><br><span class="line">				.asyncPredicate(predicate)</span><br><span class="line">				.replaceFilters(gatewayFilters)</span><br><span class="line">				.build();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其实这段代码使用了一个设计模式就是建造者模式。该模式能将构建和实现分离开来，建造者能逐步细化而不影响其它模块功能。不过建造者对产品会依赖，当产品发生变化，建造者相应也需要改变。所以这种模式建议用在比较简化的建造者依赖类上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return Route.async(routeDefinition)</span><br><span class="line">				.asyncPredicate(predicate)</span><br><span class="line">				.replaceFilters(gatewayFilters)</span><br><span class="line">				.build();</span><br></pre></td></tr></table></figure>
<p><img src="/images/video/Router的结构图.png" alt="建造者模式"></p>
<p>“断言”的功能在我看来实现得是非常巧妙的，所有断言正如过滤器一样都有一个共同的父类AbstractRoutePredicateFactory，实现apply的方法。看个例子：</p>
<p>PathRoutePredicateFactory断言类：作用是匹配请求uri资源。可以看出返回的是一个Predicate的实例，这样的好处就是在下次执行只会执行return返回的这一部分代码功能，不再需要执行配置行的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Predicate&lt;ServerWebExchange&gt; apply(Config config) &#123;</span><br><span class="line">	final ArrayList&lt;PathPattern&gt; pathPatterns = new ArrayList&lt;&gt;();</span><br><span class="line">	synchronized (this.pathPatternParser) &#123;</span><br><span class="line">		pathPatternParser.setMatchOptionalTrailingSeparator(config.isMatchOptionalTrailingSeparator());</span><br><span class="line">		config.getPatterns().forEach(pattern -&gt; &#123;</span><br><span class="line">			PathPattern pathPattern = this.pathPatternParser.parse(pattern);</span><br><span class="line">			pathPatterns.add(pathPattern);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	return exchange -&gt; &#123;</span><br><span class="line">		PathContainer path = parsePath(exchange.getRequest().getURI().getPath());</span><br><span class="line"></span><br><span class="line">		Optional&lt;PathPattern&gt; optionalPathPattern = pathPatterns.stream()</span><br><span class="line">				.filter(pattern -&gt; pattern.matches(path))</span><br><span class="line">				.findFirst();</span><br><span class="line"></span><br><span class="line">		if (optionalPathPattern.isPresent()) &#123;</span><br><span class="line">			PathPattern pathPattern = optionalPathPattern.get();</span><br><span class="line">			traceMatch(&quot;Pattern&quot;, pathPattern.getPatternString(), path, true);</span><br><span class="line">			PathMatchInfo pathMatchInfo = pathPattern.matchAndExtract(path);</span><br><span class="line">			putUriTemplateVariables(exchange, pathMatchInfo.getUriVariables());</span><br><span class="line">			return true;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			traceMatch(&quot;Pattern&quot;, config.getPatterns(), path, false);</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过Flux.zip方法连成一条断言链子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private AsyncPredicate&lt;ServerWebExchange&gt; combinePredicates(RouteDefinition routeDefinition) &#123;</span><br><span class="line">	List&lt;PredicateDefinition&gt; predicates = routeDefinition.getPredicates();</span><br><span class="line">	AsyncPredicate&lt;ServerWebExchange&gt; predicate = lookup(routeDefinition, predicates.get(0));</span><br><span class="line"></span><br><span class="line">	for (PredicateDefinition andPredicate : predicates.subList(1, predicates.size())) &#123;</span><br><span class="line">		AsyncPredicate&lt;ServerWebExchange&gt; found = lookup(routeDefinition, andPredicate);</span><br><span class="line">		predicate = predicate.and(found);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return predicate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">default AsyncPredicate&lt;T&gt; and(AsyncPredicate&lt;? super T&gt; other) &#123;</span><br><span class="line">	Objects.requireNonNull(other, &quot;other must not be null&quot;);</span><br><span class="line"></span><br><span class="line">	return t -&gt; Flux.zip(apply(t), other.apply(t))</span><br><span class="line">			.map(tuple -&gt; tuple.getT1() &amp;&amp; tuple.getT2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实到这里这一章就差不多了，基本上Gateway的主要总体框架功能就这些。这一次的阅读源码能够使我对lambda表达式的用处更深刻，而且，对这种响应式流的理解更进一步了，后续还会持续学习关于netty reactor的用法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/frp穿透/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/25/frp穿透/" itemprop="url">frp穿透</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-25T11:16:39+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="frp穿透"><a href="#frp穿透" class="headerlink" title="frp穿透"></a>frp穿透</h1><p>主要介绍如何将内网摄像头的rtsp通过frp穿透工具映射到互联网上。</p>
<p>准备：</p>
<p>摄像头ip：172.16.10.2</p>
<p>内网服务器：10.144.21.90（与摄像头是互通）</p>
<p>互联网服务器：47.106.89.193</p>
<p>frp工具包：frp_0.35.1_linux_386.tar.gz</p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol>
<li><p>两台分别安装frp穿透工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.35.1/frp_0.35.1_linux_386.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置服务端</p>
</li>
</ol>
<p>互联网服务器47.106.89.193作为服务端,配置frps.ini</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000    #绑定端口</span><br><span class="line"></span><br><span class="line">[rtsp]</span><br><span class="line">listen_port = 10000 #监听端口</span><br></pre></td></tr></table></figure>
<p>开启服务端监听命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c ./frps.ini &amp;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>配置客户端</li>
</ol>
<p>内网服务器10.144.21.90作为客户端,配置frpc.ini</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 47.106.89.193 #服务端ip</span><br><span class="line">server_port = 7000  #服务端绑定的端口</span><br><span class="line"></span><br><span class="line">#[ssh]</span><br><span class="line">#type = tcp</span><br><span class="line">#local_ip = 127.0.0.1</span><br><span class="line">#local_port = 22</span><br><span class="line">#remote_port = 6000</span><br><span class="line"></span><br><span class="line">[rtsp]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 172.16.10.2  #摄像头Ip</span><br><span class="line">local_port = 554    #摄像头端口</span><br><span class="line">remote_port = 10000 #服务端监听得端口</span><br></pre></td></tr></table></figure>
<p>开启服务端监听命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frpc -c ./frpc.ini &amp;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>结果</li>
</ol>
<p>rtsp://admin:a12345678@47.106.89.193:10000/h264/ch33/main/av_stream</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/liusingbon/p/12623774.html" target="_blank" rel="noopener">frp映射摄像头地址及端口</a></p>
<p><a href="https://www.oschina.net/p/frp?hmsr=aladdin1e1" target="_blank" rel="noopener">frp 内网穿透工具</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/FFmpeg学习与使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/25/FFmpeg学习与使用/" itemprop="url">FFmpeg学习与使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-25T11:16:39+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本节主要记录下FFmpeg的使用方法以及如何用于视频项目上作一个简单的介绍</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FFmpeg是一款多媒体处理工具，内部包含了解码、编码、转码、解密的操作命令。正式由于FFmpeg太强大，目前大部分流媒体服务都会或多或小使用到FFmpeg的功能，所以我们有必要学习下FFmpeg的使用指令。</p>
<h2 id="常用命令以及解析"><a href="#常用命令以及解析" class="headerlink" title="常用命令以及解析"></a>常用命令以及解析</h2><h3 id="主要成分："><a href="#主要成分：" class="headerlink" title="主要成分："></a>主要成分：</h3><ol>
<li>libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能；</li>
<li>libavcodec：用于各种类型声音/图像编解码；</li>
<li>libavutil：包含一些公共的工具函数；</li>
<li>libswscale：用于视频场景比例缩放、色彩映射转换；</li>
<li>libpostproc：用于后期效果处理；</li>
<li>ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等；</li>
<li>ffsever：一个 HTTP 多媒体即时广播串流服务器；</li>
<li>ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示；</li>
</ol>
<h3 id="ffprobe"><a href="#ffprobe" class="headerlink" title="ffprobe"></a>ffprobe</h3><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -rtsp_transport tcp -i &quot;rtsp://10.128.184.34:554/01?Short=1&amp;Token=vEKOlIYbbCFseXHTjO3kbtEKZGZ4eyRExIkPU+yWWPA=&amp;DomainCode=6a7c1a077a004406a344a1f260d86e41&amp;UserId=6&amp;&quot;</span><br></pre></td></tr></table></figure></p>
<p>-rtsp_transport tcp/udp：选择以TCP还是UDP方式打开<br>·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。<br>-show_format filename：展示格式<br>-show_frames filename：显示帧信息</p>
<h3 id="ffplay"><a href="#ffplay" class="headerlink" title="ffplay"></a>ffplay</h3><p>播放文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay xxx.mp3 -ast 1 -loop 10</span><br></pre></td></tr></table></figure></p>
<p>-loop num：循环次数</p>
<p>-[ast|vst] 1：选择播放[音频|视频]</p>
<h3 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h3><p>FFmpeg参数太多，以下是我举例了项目中实际用到的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -loglevel quiet &#123;[decoder]&#125;  &#123;[tcp]&#125; -i &quot;&#123;[rtsp]&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>·-re：代表按照帧率发送，尤其在作为推流工具的时候一定要加入该参数，否则ffmpeg会按照最高速率向流媒体服务器不停地发送数据</p>
<p>-loglevel [debug|quiet|error]：日志级别记录</p>
<p>·-i filename：指定输入文件名，rtsp、rtmp、摄像头地址等。</p>
<p>截图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -re -loglevel quiet &#123;[tcp]&#125; -i \&quot;&#123;[rtsp]&#125;\&quot; -an &#123;[size]&#125;  -vframes 1 -y -f image2 &#123;[pattern]&#125;.jpg</span><br></pre></td></tr></table></figure></p>
<p>-an：视频静音</p>
<p>·-y：覆盖已有文件。</p>
<p>·-f fmt：指定格式（音频或者视频格式）。</p>
<p>推流转码成h264<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -loglevel debug  -rtsp_transport tcp -i &quot;rtsp://10.128.184.34:554/01?Short=1&amp;Token=yWSkzfBj71Yja67n9Y65SXDN97TCCOzBveNwOB53Lh8=&amp;DomainCode=6a7c1a077a004406a344a1f260d86e41&amp;UserId=6&amp;&quot; -an -s 1280x720  -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp</span><br></pre></td></tr></table></figure></p>
<p>-analyzeduration：设置码流分析时间</p>
<p>-probesize：探测时长，这个设置的时间越长，视频打开得越慢</p>
<p>·-vcodec [codec|smart_h264]：强制使用codec编解码方式（’copy’代表不进行重新编码）,smart_h264实现h264编码</p>
<p>·-s size：指定分辨率（320×240）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;[ffmpeg]&#125; -loglevel error &#123;[decoder]&#125; -i &#123;[rtsp]&#125; &#123;[copy]&#125; &#123;[encoder]&#125; -an -threads 10 -tune zerolatency -crf &#123;[crf]&#125; -g 1 -r &#123;[frameRate]&#125; -preset ultrafast -vcodec smart_h264 -f flv rtmp://192.168.193.168:1935/hls/7a92e703d492aac22614ba670c85018f?secret=035c73f7-bb6b-4889-a715-d9eb2d1925ccSimp</span><br></pre></td></tr></table></figure>
<p>crf num：<br>为恒定质量（无比特率目标）和受限质量（最大比特率目标）模式设置质量/大小折衷。有效范围是0到63，数字越大表示质量越低，输出大小越小。仅在设置时使用；默认情况下，仅使用比特率目标</p>
<p>threads num：选定的编解码器实现支持多线程，则设置要使用的线程数。</p>
<p>tune [zerolatency|fastdecode|psnr|ssim]：主要配合视频类型和视觉优化的参数。zerolatency零延迟，用在需要非常低的延迟的情况下，比如电视电话会议的编码；fastdecode可以快速解码的参数； psnr为提高psnr做了优化的参数；ssim为提高ssim做了优化的参数； </p>
<p>preset type：预设类型。</p>
<p>r num：帧率</p>
<p>g size：设置GOP的大小</p>
<h2 id="项目中如何是使用"><a href="#项目中如何是使用" class="headerlink" title="项目中如何是使用"></a>项目中如何是使用</h2><p>由于ffmpeg太强大，在视频网关的项目中，我们经常会使用到ffmpeg。主要使用到有两方面，一个是截图，一个是将h265的视频数据格式转码成h264或者更改视频的分辨率功能等。为什么在项目中会使用到FFmpeg呢，其实像海康和大华第三方的厂商都会有对应的sdk,但是像截图之类的功能不能很好支持各种分辨率的截图，所以喔们考虑到使用FFmpeg来结合起来，以下是关于项目的流程图。</p>
<p><img src="/images/video/流程图.jpg" alt="FFmpeg使用流程"></p>
<p>其实在项目上，我们一般会使用FFmpeg来进行截图，如上述说因为能够定制化配置截图得大小以及色差得调节等，而第三方厂商sdk一般都是默认尺寸，扩展性不高（如海康和大华）。而且，使用FFmpeg得扩展性会比较高。但是FFmpeg并不是万能，对于有一些私有的RTSP等可能也会存在失败的情况，所以在项目中如果FFmpeg截图不成功都会采用对应厂商sdk进行兜底截图，保证图片能够生成并且可用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.ffmpeg.org/documentation.html" target="_blank" rel="noopener">FFmpeg官网</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/24/wireshark抓包并使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/24/wireshark抓包并使用/" itemprop="url">wireshark抓包并使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-24T11:16:39+08:00">
                2021-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇是记录我在平常抓包过程中如何使用wireshark</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul>
<li>wireshark工具</li>
</ul>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>使用wireshark，首先就要学会怎么抓包，很简单，在linux下使用以下命令</p>
<blockquote>
<p>tcpdump -i eth0 host [ip] -n -vv -A -w 抓包.pcap</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>将抓到的包用wireshark打开就能见到下面的界面</p>
<p><img src="/images/video/抓包界面图.png" alt="wireshark界面"></p>
<html><br><center>图一</center><br></html>


<p>这是一份在对接RTSP视频协议时候抓回来的包，很明显可以看到是基于TCP来传输的。以下记录一下我常用到的主要功能：</p>
<ol>
<li>面板使用</li>
</ol>
<p><img src="/images/video/抓包上方图.png" alt="wireshark面板"></p>
<html><br><center>图二</center><br></html>

<p>一般来说，通过面板就能看出交互的具体内容。如图二可以前三行列表可以看出TCP三次握手的交互流程。参考TCP三次握手流程</p>
<p><img src="/images/video/tcp三次握手图.png" alt="image"></p>
<ol>
<li>数据详细区</li>
</ol>
<p><img src="/images/video/抓包下方图.png" alt="wireshark下半部"></p>
<html><br><center>图三</center><br></html>


<p>整个传输过程的传输信息，具体每一层有什么具体信息可以看下相应的资料。由上往下</p>
<ol>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层（常用）</li>
<li>传输层（常用）</li>
<li>应用层（常用）</li>
</ol>
<ol>
<li>追踪流</li>
</ol>
<p>展示更具体交互信息</p>
<blockquote>
<p>右键点击面板信息&gt;追踪流&gt;TCP流</p>
</blockquote>
<p><img src="/images/video/抓包协议追踪图.png" alt="追踪流"></p>
<html><br><center>图四</center><br></html>

<ol>
<li>统计丢包率</li>
</ol>
<p>一般来说，我们也会去观察究竟数据的丢包率是多小，对于音视频的数据我们一般观察RTP包，特别是以UDP传输的时候。</p>
<blockquote>
<p>电话&gt;&gt;RTP&gt;&gt;RTP流</p>
</blockquote>
<p><img src="/images/video/抓包rtp统计包.png" alt="RTP丢包率"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/82498482" target="_blank" rel="noopener">Wireshark抓包使用指南</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/23/选型视频网关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/23/选型视频网关/" itemprop="url">选型视频网关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-23T11:16:39+08:00">
                2021-07-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着发展，视频网关也逐步完善，但后期也出现了越来越多的需求，譬如流控、鉴权、业务分发等功能。这些功能原本是直接放在视频网关上面，但是考虑到以后的易于维护、可扩展性、复用、避免代码臃肿、职责单一的问题，就将这部分功能单独抽到一个api网关上面。这样一来我们接下来首要的问题就是选型了。</p>
<h2 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h2><p><img src="/images/video/网关选型图.png" alt="网关选型对比"></p>
<p>网关说到底最重要的技术选性格是并发能力，以下是Gateway官网作者做了一个压测</p>
<p><img src="/images/video/网关压测性能对比.png" alt="image"></p>
<p>这篇文章是我看了那么多对比做得比较清晰简单的一篇：<a href="https://www.edjdhbb.com/2018/12/16/%E7%BD%91%E5%85%B3%E9%80%89%E6%8B%A9%E5%9B%B0%E9%9A%BE%E7%97%87/" target="_blank" rel="noopener">压测对比</a></p>
<h3 id="为什么选择SpringCloud-Gateway"><a href="#为什么选择SpringCloud-Gateway" class="headerlink" title="为什么选择SpringCloud Gateway"></a>为什么选择SpringCloud Gateway</h3><p>选择Gateway，基于以下几点考虑：</p>
<ol>
<li>维护成本</li>
</ol>
<p>虽然Kong的并发能力更高，但是Kong比较适合业务相对简单的网关，且公司大多都是JAVA技术人员，对于JAVA技术栈的系统来说维护起来比较困难。举个例子当业务复杂起来时，维护lua的脚本就会越来越多，因此引入一种新的技术栈成本是一个相对较高的事情。</p>
<ol>
<li>接入快</li>
</ol>
<p>相比zuul1.x与Gateway，都是可以无缝对接到spring boot或spring cloud,但相比起来Gateway能支持websocket且并发的能力相对高于zuul，而zuul2.x在后续没有整合到spring上。重要一点是，接入到Gateway相对比较快，开发对应的Filter就能满足业务。</p>
<ol>
<li>内置功能完善</li>
</ol>
<p>Gateway自带了多种Filter和Router，对于开发一个简单的网关来说是完全足够。像限流之类功能也是需要的。</p>
<h2 id="SpringCloud-Gateway"><a href="#SpringCloud-Gateway" class="headerlink" title="SpringCloud Gateway"></a>SpringCloud Gateway</h2><p>既然选择了Gateway,我们现在就简单介绍下Gateway的用法，以下是Gateway的框架图：</p>
<p><img src="/images/video/gateway网关图.png" alt="Gateway框架"></p>
<p>可以看出其实Gateway的架构其实是非常简单。Gateway有几个概念：Route、Predicate与Filter</p>
<p><strong>Route</strong><br>网关配置的基本组成模块，和Zuul的路由配置模块类似。一个Route模块由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。</p>
<p><strong>Predicate</strong></p>
<p>Predicate是一个Java8的函数，输入类型是Spring的ServerWebExchange，允许匹配来自Http的任何内容，如请求头或者参数。</p>
<p><img src="/images/video/gateway断言.png" alt="Predicate功能图"></p>
<p><strong>Filter</strong><br>使用特定工厂构建的Spring GatewayFilter实例，可以在发生下游请求之前修改请求信息或者响应请求之后修改返回内容（这一点与Zuul的过滤器一致）。</p>
<p><img src="/images/video/gateway触发器.png" alt="Filter功能图"></p>
<h2 id="如何自定义开发Filter"><a href="#如何自定义开发Filter" class="headerlink" title="如何自定义开发Filter"></a>如何自定义开发Filter</h2><ol>
<li>继承AbstractGatewayFilterFactory默认的抽象类,并实现apply的方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 替换服务地址过滤器</span><br><span class="line"> * @author: lhj</span><br><span class="line"> * @Date: 2021年1月16日 下午5:00:00</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&#123; &quot;rawtypes&quot; &#125;)</span><br><span class="line">public class ProvideServiceGatewayFilterFactory extends AbstractGatewayFilterFactory &#123;</span><br><span class="line">	private static final Logger LOG = LoggerFactory.getLogger(ProvideServiceGatewayFilterFactory.class);</span><br><span class="line">	private CrudService&lt;RuleTransformEntity&gt; ruleService;</span><br><span class="line">	public ProvideServiceGatewayFilterFactory() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">	public ProvideServiceGatewayFilterFactory(CrudService&lt;RuleTransformEntity&gt; ruleService) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.ruleService = ruleService;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public GatewayFilter apply(Object config) &#123;</span><br><span class="line">		return (exchange, chain) -&gt; &#123;</span><br><span class="line">			SimpleRespTaskEntity taskEntity = exchange.getAttribute(WebExchangeUtils.RESP_BASE_TASK_ENTITY);</span><br><span class="line">			NetworkNature networkNature = exchange.getAttribute(WebExchangeUtils.NETWORK_TYPE);</span><br><span class="line">			Object startTime = exchange.getAttribute(WebExchangeUtils.START_MILLIS);</span><br><span class="line">			Map&lt;String, String&gt; urls = taskEntity.getUrls();</span><br><span class="line">			urls.entrySet().forEach(entry -&gt; &#123;</span><br><span class="line">				String schemaUrl = entry.getKey();</span><br><span class="line">				String url = entry.getValue();</span><br><span class="line">				try &#123;</span><br><span class="line">					URI uri = URI.create(url);</span><br><span class="line">					String path = uri.getPath();</span><br><span class="line">					String key = url.substring(0, url.indexOf(path)) + &quot;-&quot; + networkNature;</span><br><span class="line">					RuleTransformEntity transform = ruleService.get(key);</span><br><span class="line">					LOG.info(&quot;key:&#123;&#125;,transform:&#123;&#125;&quot;,key,transform);</span><br><span class="line">					if (!Objects.isNull(transform)) &#123;</span><br><span class="line">						String transformUrl = url.replace(transform.getSourcePrefix(), transform.getTargetPrefix());</span><br><span class="line">						urls.put(schemaUrl, transformUrl);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					LOG.error(e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			LOG.info(&quot;transform urls:&#123;&#125;,spends &#123;&#125; ms&quot;, urls,</span><br><span class="line">					System.currentTimeMillis() - Long.parseLong(startTime.toString()));</span><br><span class="line">			return WebfluxUtil.writeResponse(ResponseResult.fromData(taskEntity), exchange.getResponse());</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>将这个工厂注入到spring容器当中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ProvideServiceGatewayFilterFactory replaceServiceGatewayFilterFactory(CrudService&lt;RuleTransformEntity&gt; ruleTransformManagerService) &#123;</span><br><span class="line">	return new ProvideServiceGatewayFilterFactory(ruleTransformManagerService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>配置yml文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cloud:</span><br><span class="line">  gateway:</span><br><span class="line">    routes:</span><br><span class="line">      - id: stream</span><br><span class="line">        uri: http://&#123;server&#125;/mag-cluster-server/</span><br><span class="line">        predicates:</span><br><span class="line">          - Path=/api/video/startTransform/**</span><br><span class="line">          - name: ReadBodyPredicateFactory </span><br><span class="line">            args:</span><br><span class="line">              inClass: &quot;#&#123;T(String)&#125;&quot;</span><br><span class="line">              predicate: &quot;#&#123;@testRequestBody&#125;&quot;</span><br><span class="line">        filters:</span><br><span class="line">          - ProvideService</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/" target="_blank" rel="noopener">Gateway官方文档</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/22/视频性能压测/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/22/视频性能压测/" itemprop="url">视频性能压测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-22T11:16:39+08:00">
                2021-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于项目接入了二千多路摄像头，三十台机器集群，应项目的要求对程序项目进行压测，目标是测试到一台流媒体服务器能同时并发支撑多小路视频，从而推测整个集群的能力，也为以后的扩展。</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul>
<li><p>服务器1台</p>
<p>配置：CPU 8核,内存 16G</p>
</li>
<li><p>客户端1台</p>
<p>配置：CPU 8核,内存 16G</p>
</li>
<li>监控服务端工具nmon：</li>
<li><p>压测工具：自研发的一款拉流工具，针对我们视频项目接口定制化开发</p>
</li>
<li><p>300个海康摄像头1920×1080P(可用正式环境)</p>
</li>
</ul>
<h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><p>在压测的时候我认为需要清楚了解整个网络架构图，这样才能发现哪些地方存在的瓶颈，便于后期针对瓶颈地方进行压测。以下是我大致画出当时项目的网络环境：</p>
<p><img src="/images/video/压测流程图.png" alt="网络架构图"></p>
<p>经过分析，存在瓶颈：</p>
<ol>
<li>客户端自研拉流程序m1存在拉流的性能瓶颈</li>
<li>流媒体北向的拉流分发能力m2的瓶颈</li>
<li>流媒体南向的推流能力m3的瓶颈</li>
<li>验证m4出口是否有千兆带宽</li>
</ol>
<h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>场景：多个用户，同时访问1路摄像头视频</p>
<p>目的：测出单台流媒体服务北向分发能力m2的极限。</p>
<p>为了减少自研发的客户端拉流程序瓶颈对本次压力测试造成影响，使用多个客户端进行拉流。  </p>
<p><img src="/images/video/压测结果一.png" alt="场景一"></p>
<p>结论：160个用户访问同一路摄像头视频时，系统能够稳定工作；北向并发能力达到160以上。</p>
<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>场景：两个客户端分别请求N路不同的视频，共请求2N路视频。每路视频1人观看。</p>
<p>目的：测出单台流媒体服务南向m3能力的极限。</p>
<p><img src="/images/video/压测结果二.png" alt="场景二"></p>
<p>结论：南向并发处理80路摄像头视频时，系统能够稳定工作；南向并发处理100路摄像头视频时，网络出现较大波动；因此，单个流媒体服务的南向处理能力，为90路视频。</p>
<h3 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h3><p>场景：两个客户端，分别请求两个不同的流媒体服务器；每个客户端请求N路视频，共请求2N路视频。</p>
<p>目的：南向交换机性能瓶颈测试。</p>
<p><img src="/images/video/压测结果三.png" alt="场景三"></p>
<p>结论：单台客户端服务器最高可以处理南向70路视频，<br>单台流媒体服务器最多可处理南向90路视频。</p>
<h3 id="场景四"><a href="#场景四" class="headerlink" title="场景四"></a>场景四</h3><p>场景：两个客户端，分别请求一台服务器上的两个流媒体服务；每个客户端请求N路视频，共请求2N路视频。</p>
<p>目的：压测m4出口带宽是否达到千兆瓶颈</p>
<p><img src="/images/video/压测结果四.png" alt="场景四"></p>
<p>结论：当请求并发90路视频时，单台流媒体服务器系统能够稳定工作，当并发请求100路视频时，网络IO出现较大波动。因此，单台流媒体服务器南向摄像头最多只能处理90路视频</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实对于我来说，有幸参与了这次压测的整个过程，其中包括了跟项目组的沟通，跟第三方供应商技术交流等等。其实对于这类压测，最好能确认好控制单一要素，控制单一要素那就需要将每个步骤分层，然后将其余部分当作整体看待。举个例子，要想测试m3南向并发处理能力，那就将m3往下的部分当作整体，将其他没关要素降到影响最低（譬如客户端是瓶颈因素，那就水平扩展客户端），逐步增大压力，观察服务器等指标，如果出现一些业务报错或者其他问题往往就是触发到瓶颈，这个需要根据业务场景来定。由于我们这里偏向于IO密集型，所以一般都是观察网络IO主要是上下行带宽的指标为主。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/25/书籍记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/25/书籍记录/" itemprop="url">书籍记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-25T12:00:00+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/书籍/" itemprop="url" rel="index">
                    <span itemprop="name">书籍</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-鸟哥linux第三版基础篇（看完整本书基本上linux入门）"><a href="#1-鸟哥linux第三版基础篇（看完整本书基本上linux入门）" class="headerlink" title="1.鸟哥linux第三版基础篇（看完整本书基本上linux入门）"></a>1.鸟哥linux第三版基础篇（看完整本书基本上linux入门）</h3><h3 id="2-鸟哥linux第四版基础篇"><a href="#2-鸟哥linux第四版基础篇" class="headerlink" title="2.鸟哥linux第四版基础篇"></a>2.鸟哥linux第四版基础篇</h3><h3 id="3-Java多线程编程核心技术-关于线程比较基础入门"><a href="#3-Java多线程编程核心技术-关于线程比较基础入门" class="headerlink" title="3.Java多线程编程核心技术 (关于线程比较基础入门)"></a>3.Java多线程编程核心技术 (关于线程比较基础入门)</h3><h3 id="4-redis入门指南2-比较详细记录了redis使用"><a href="#4-redis入门指南2-比较详细记录了redis使用" class="headerlink" title="4.redis入门指南2 (比较详细记录了redis使用)"></a>4.redis入门指南2 (比较详细记录了redis使用)</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/05/nginx原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/05/nginx原理分析/" itemprop="url">nginx原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-05T12:00:00+08:00">
                2017-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nginx总结/" itemprop="url" rel="index">
                    <span itemprop="name">nginx总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>导语:</strong></p>
<blockquote>
<p>本章主要记录一下我对nginx原理的理解，以及相关的重点与难点</p>
</blockquote>
<h3 id="一-nginx优点"><a href="#一-nginx优点" class="headerlink" title="一.nginx优点"></a>一.nginx优点</h3><h4 id="IO多路复用（重点）"><a href="#IO多路复用（重点）" class="headerlink" title="IO多路复用（重点）"></a>IO多路复用（重点）</h4><p>前一章中提及到了nginx能支撑高并发的一个主要原因就是使用到io多路复用的这种技术。</p>
<ol>
<li><p>什么是io多路复用？<br>定义上：获取并监听多个fd(文件描述符)，通过单个线程内完成IO的读写,复用指的是线程<br>例子:某快递公司快递员（<font color="red">处理线程</font>），寄件（<font color="red">IO网络请求</font>）</p>
<ul>
<li>例子一：快递员不知道哪家需要寄件，逐间逐户询问是否需要寄件，这样的话就会造成耗费时间过长，万一某一户出现某些情况，寄件人还未回来，就会一直阻塞。这就是一个典型的单线程阻塞例子。</li>
<li>例子二：快递公司觉得一个快递员收件太慢了，就聘请了多个快递员去收件。这样会造成一个问题就是收件速度确实比以前快，但这也会使快递公司成本变得高，造成不必要的人力浪费。这个就是多线程+阻塞的例子。</li>
<li>例子三：寄件方准本好需要的寄件，然后打电话通知快递员某户寄件已准备好，快递员就上门收取。这样就能用一个快递员高效的收纳寄件。这就是一个io多路复用的例子，打电话通知寄件已准备好其实可以看作io事件准备就绪主动上报的一个过程，程序机制就会对已准备好的事件做一系列的io读写操作。</li>
</ul>
</li>
<li><p>nginx的io多路复用模型有哪些？<br>nginx中提供了多种io多路复用模型的机制如select,poll,epoll等。目前，linux2.6以上才能使用epoll机制。本质上,select与epoll都是属于非阻塞的同步IO.下面，我简单介绍一下select与epoll的区别。</p>
<ul>
<li>select介绍<br><img src="/images/nginx/select.jpg" alt="selectIO模型图"></li>
</ul>
<ol>
<li>进程通过select调用，将fd集合从用户态全部复制到内核态当中，这个过程中会阻塞进程。</li>
<li>select会遍历的fd集合，如果存在准备就绪的fd，就会返回可读的指示并将对应连接放入监听队列中(表示监听IO数据)。在第二次遍历如果发现存在已经就绪的数据，则会调用recvfrom的方法,进程会将数据从内核态复制到用户态中并进行对应读写事件处理。处理完毕则会移除对应监听队列的socket。</li>
<li>在select遍历完所有的fd都没有发现可读的fd后,则会进入休眠期。当有发现新的可读写资源，则会唤醒select进程。如果超过一定超时时间，则会重新被唤醒。重新遍历fd集合。<br> <span><font color="red"><br> select总结:<pre><code>-  每次select调用都需要遍历fd集合。
-  监视的文件描述符的数量存在最大限制，可以调节，但是随着增大也会导致用户态与内核态之间的复制带来的资源开销（如内存）呈线性增大
-  每次都要将整个集合的数据在用户态与内核到之间的互相复制。
</code></pre> </font></span></li>
</ol>
<ul>
<li>epoll介绍<br>epoll的核心主要是三个函数:epoll_create(创建epoll句柄)，epoll_ctl(管理epoll注册监听事件，增删查改等)，epoll_wait(等待执行事件)</li>
</ul>
<ol>
<li>首先调用epoll_create创建一个epoll句柄对象，epoll含有一个红黑树和一个就绪队列。</li>
<li>当调用epoll_ctl创建注册监听事件时候，会为fd注册一个回调函数，并将fd从用户态复制到内核态。如果fd就绪后，会通过回掉函数将fd放入就绪队列中。</li>
<li>epoll_wait则会扫描就绪队列并执行相应事件,并把数据返回给用户。与select类似都是苏醒与睡眠交替进行，但是select是不停遍历整个fd集合，而epoll_wait只是遍历就绪列表就可以了，仅判断是否为空就OK拉。<blockquote>
<p>总结：<br>简单类比一下，其实select模型与epoll模型好比如在茶楼结账时候，服务员只告诉老板有人结账了，你过去收。此时老板并不知道具体要结账的是哪一桌，就一个一个去问（遍历fd集合是否有就绪），这是select模型做的；而epoll则是服务员具体告诉老板是那几桌要结账（利用回调函数，将就绪事件直接放到epoll队列中），老板就能直接过去结账。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>io多路复用的优缺点?</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单线程，消耗少</td>
<td style="text-align:center">不适宜处理少量的请求数</td>
</tr>
<tr>
<td style="text-align:center">能支撑大并发量的请求</td>
</tr>
<tr>
<td style="text-align:center">非阻塞</td>
</tr>
</tbody>
</table>
<h4 id="cpu的亲和性"><a href="#cpu的亲和性" class="headerlink" title="cpu的亲和性"></a>cpu的亲和性</h4><p>能够将nginx上的worker绑定到某一特定的cpu上，这样大大避免了进程中缓存的丢失以及切换带来的资源消耗。而且，nginx中还会将某些字符串转换成特定的int，再进行比较，减少了指令条数（如nginx在解释请求头中的method信息时候,会将其值（post|get）转换成int类型进行比较）</p>
<h4 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h4><p>nginx只保留核心功能模块，而且并不多，可进行相应扩展。<br>nginx模块化开发，比较易读</p>
<h3 id="二-nginx-工作原理"><a href="#二-nginx-工作原理" class="headerlink" title="二.nginx 工作原理"></a>二.nginx 工作原理</h3><p><img src="/images/nginx/worker.jpg" alt="nginx工作图解"></p>
<ul>
<li>master进程工作范围<ul>
<li>master负责接收外界的信号并分发给worker各个进程。worker进程会通过抢排斥锁accept_mutex来抢占资源（各个worker抢占资源是有一个算法，能均衡每个worker抢占到的资源）</li>
<li>master管理和监控着各个worker的运行状态。</li>
<li>master加载配置文件(如执行重启，关闭操作)。如重启操作，首先重新加载配置文件，fork出新的worker并通知旧的worker停止接收资源，等到旧worker已经完成了剩下的请求后就退出。</li>
</ul>
</li>
<li>worker进程工作范围<ul>
<li>每个抢到互斥锁的worker进程会进行读取请求、解释请求、处理请求、产生数据、返回客户端的步骤。</li>
</ul>
</li>
</ul>
<h3 id="三-nginx中对connection流程"><a href="#三-nginx中对connection流程" class="headerlink" title="三.nginx中对connection流程"></a>三.nginx中对connection流程</h3><center><br><br><div id="flowchart-0" class="flow-chart"></div><br></center>

<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><p>以上是经过我这一段时间对nginx的了解作出的总结，可能会有一些偏差或者不够完善的地方。在今后会不停地去反复完善，希望能将nginx理解得更为透彻。</p>
<h3 id="五-参考"><a href="#五-参考" class="headerlink" title="五.参考"></a>五.参考</h3><ol>
<li><a href="https://www.cnblogs.com/zingp/p/6863170.html" target="_blank" rel="noopener">io模式与IO</a></li>
<li><a href="https://www.jianshu.com/p/edb9ddd51c3d" target="_blank" rel="noopener">select模型的说明</a></li>
<li><a href="http://tengine.taobao.org/book/" target="_blank" rel="noopener">nginx从入门到精通</a></li>
</ol>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
step1=>operation: 客户端与nginx通过三次握手tcp连接,并创建好socket
step2=>operation: worker抢占锁并将connection封装到ngx_connection_t实体中
step3=>operation: 将socket设置好读写事件
step4=>operation: 与其他server创建连接与创建
ngx_connection_t实体并设置好读写事件

step5=>operation: 执行读写事件，完成后nginx与客户端交换数据
step6=>operation: 释放ngx_connection_t,nginx或客户端主动关掉连接
cond=>condition: 是否有其他server(如upstream等)
e=>end: 结束
st->step1
step1->step2
step2->step3->cond
cond(yes)->step4
cond(no)->step5
step4->step5->step6->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/30/nginx搭建与部署/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay-Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay-Luo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/30/nginx搭建与部署/" itemprop="url">nginx的搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-30T12:00:00+08:00">
                2017-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nginx总结/" itemprop="url" rel="index">
                    <span itemprop="name">nginx总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="nginx是什么"><a href="#nginx是什么" class="headerlink" title="nginx是什么"></a>nginx是什么</h3><p>nginx是一个开源且高性能、可靠的http中间件、代理服务</p>
<h3 id="为什么使用nginx（详细在下一章总结）"><a href="#为什么使用nginx（详细在下一章总结）" class="headerlink" title="为什么使用nginx（详细在下一章总结）"></a>为什么使用nginx（详细在下一章总结）</h3><ul>
<li>io多路复用(select,epoll等模型实现)</li>
<li>cpu亲和性</li>
<li>轻量级</li>
</ul>
<h3 id="nginx的使用场景-（详细在另外一章总结）"><a href="#nginx的使用场景-（详细在另外一章总结）" class="headerlink" title="nginx的使用场景 （详细在另外一章总结）"></a>nginx的使用场景 （详细在另外一章总结）</h3><ol>
<li>代理服务<ol>
<li>正向代理</li>
<li>反向代理</li>
</ol>
</li>
<li>缓存服务</li>
<li>https服务</li>
<li>静态web服务<ol>
<li>跨域</li>
<li>防盗链</li>
<li>客户端缓存</li>
</ol>
</li>
<li>动静分离</li>
<li>nginx+lua <ol>
<li>流量监控</li>
<li>waf</li>
<li>灰度发布(建议使用openresty)</li>
</ol>
</li>
<li>rewrite规则<ol>
<li>后台维护页面</li>
<li>seo搜索优化</li>
<li>安全（伪静态）</li>
<li>url访问跳转（新旧域名替换）</li>
</ol>
</li>
</ol>
<h3 id="nginx下linux的部署-fedora27"><a href="#nginx下linux的部署-fedora27" class="headerlink" title="nginx下linux的部署(fedora27)"></a>nginx下linux的部署(fedora27)</h3><pre><code>简单说明下安装nginx的所需要的依赖，并不做详细讲解
</code></pre><ol>
<li>下载prec,zlib,openssl</li>
<li>yum install -y gcc g++ (c编译工具)</li>
<li>yum install -y pcre pcre-devel(重写rewrite,正则表达式)</li>
<li>yum install -y zlib zlib-devel(gzip压缩)</li>
<li>yum install -y openssl openssl-devel</li>
<li>下载nginx（可到官网上下载.tar文件）</li>
<li>解压 tar -zxvf nginx-xxxx.tar.gz</li>
<li>进入解压目录，并执行./configure –prefix=/usr/local/nginx  </li>
<li>make &amp;&amp; make install</li>
</ol>
<h3 id="nginx的目录配置说明"><a href="#nginx的目录配置说明" class="headerlink" title="nginx的目录配置说明"></a>nginx的目录配置说明</h3><p>├── auto            自动检测系统环境以及编译相关的脚本<br>│   ├── cc          关于编译器相关的编译选项的检测脚本<br>│   ├── lib         nginx编译所需要的一些库的检测脚本<br>│   ├── os          与平台相关的一些系统参数与系统调用相关的检测<br>│   └── types       与数据类型相关的一些辅助脚本<br>├── conf            存放默认配置文件，在make install后，会拷贝到安装目录中去<br>├── contrib         存放一些实用工具，如geo配置生成工具（geo2nginx.pl）<br>├── html            存放默认的网页文件，在make install后，会拷贝到安装目录中去<br>├── man             nginx的man手册<br>└── src             存放nginx的源代码<br>    ├── core        nginx的核心源代码，包括常用数据结构的定义，以及nginx初始化运行的核心代码如main函数<br>    ├── event       对系统事件处理机制的封装，以及定时器的实现相关代码<br>    │   └── modules 不同事件处理方式的模块化，如select、poll、epoll、kqueue<br>    ├── http        nginx作为http服务器相关的代码<br>    │   └── modules 包含http的各种功能模块<br>    ├── mail        nginx作为邮件代理服务器相关的代码<br>    ├── misc        一些辅助代码，测试c++头的兼容性，以及对google_perftools的支持<br>    └── os          主要是对各种不同体系统结构所提供的系统函数的封装，对外提供统一的系统调用接口</p>
<h3 id="nginx相关命令"><a href="#nginx相关命令" class="headerlink" title="nginx相关命令"></a>nginx相关命令</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./nginx 启动</span><br><span class="line">./nginx -s stop 关闭</span><br><span class="line">./nginx -s reload 重启</span><br><span class="line">./nginx -tc nginx 配置文件   检测nginx配置文件语法</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title=" 注意 "></a><strong><font color="red"> 注意 </font></strong></h3><ul>
<li>在重新编译nginx时候，先将原有的nginx二进制文件备份,再执行./configure &amp;&amp; make &amp;&amp; make install 以免被新的nginx覆盖</li>
<li>若直接使用yum最新版本的openssl,则会在编译某些旧版本nginx的时候出现不兼容的情况。原因是由于openssl新版本改动得挺大导致。解决方案<ul>
<li>升级nginx版本</li>
<li>降级openssl的版本(额外章会记录如何降级，这里遇到了一个坑) </li>
</ul>
</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="http://tengine.taobao.org/book/" target="_blank" rel="noopener">nginx从入门到精通</a></li>
<li><a href="http://www.nginx.cn/doc/" target="_blank" rel="noopener">nginx中文官方文档</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Jay-Luo" />
            
              <p class="site-author-name" itemprop="name">Jay-Luo</p>
              <p class="site-description motion-element" itemprop="description">小小的天，大大的梦</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yourname" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jay-Luo</span>

  
</div>


  <div class="powered-by">个人专属</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">博客 &mdash; NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
